<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>First learning record</title>
    <url>/2022/04/24/record01/</url>
    <content><![CDATA[<p>分享第一周学习内容</p>
<span id="more"></span>
<h1 id="leetcode-热题HOT-100"><a href="#leetcode-热题HOT-100" class="headerlink" title="leetcode 热题HOT 100"></a>leetcode 热题HOT 100</h1><h2 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h2><p>给定一个整数数组nums和一个整数目标值target请你在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<img src="/2022/04/24/record01/example01.jpg" class="" title="这是一张图片">

<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a; </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            a.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(nums[i],i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">count</span>(target - nums[i]) != <span class="number">0</span> &amp;&amp; (a[target - nums[i]] != i))&#123;</span><br><span class="line">                b[<span class="number">0</span>] = i;</span><br><span class="line">                b[<span class="number">1</span>] = a[target - nums[i]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常的作法为逐步尝试，首先第一个加第二个，再第一个加第三个……思路虽然简单暴力但运行速度慢且内存空间消耗大<br>此代码采用的</p>
<ul>
<li><p>开始逐行分析与知识点回顾</p>
  <figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a; <span class="regexp">//</span>创建名为a的<span class="keyword">map</span>容器，key与val的类型均为<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>  回顾map容器的相关知识：<br>  1.map容器里的数值都是pair—&gt;成对出现 分别为键值key与实值val<br>  2.我们可以通过key的索引查到对应的val<br>  3.map不允许有重复的键值key存在<br>  3.所有元素都会根据你所存的键值key进行自动排序<br>  4.其中&lt;int,int&gt;  左边int代表key的类型为int  右边的int代表val为int</p>
<p>  作用为：存储nums里的元素</p>
  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vector</span>&lt;int&gt; b(<span class="number">2</span>,-<span class="number">1</span>);//创建名为b的vector容器，<span class="number">2</span>代表初始长度，里面的值均为-<span class="number">1</span>，存储nums里能满足target的两个值</span><br></pre></td></tr></table></figure>

<p>  回顾vector容器的相关知识：<br>  1.与数组结构非常相似，与数组不同点在于数组是静态，而vector是动态扩展</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; nums.size<span class="literal">()</span>;i++)</span><br><span class="line">    a.insert(map&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;::value<span class="constructor">_type(<span class="params">nums</span>[<span class="params">i</span>],<span class="params">i</span>)</span>);</span><br></pre></td></tr></table></figure>
<p>  涉及到的知识：<br>  1.nums.size()表示的是整数数组nums的长度<br>  2.a.insert是调用map容器里的函数insert：在map中插入元素<br>  3.map&lt;int,int&gt;::value_type：令元素的类型为map中含有key与val的pair类型<br>  4.map&lt;int,int&gt;::mapped_type：令元素的类型为map中的val类型<br>  5.map&lt;int,int&gt;::key_type：令元素的类型为map中的key类型<br>  所以 我们把nums里的元素分别以key-val的pair形式传到名为a的map容器里</p>
  <figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for(int i = 0;i &lt; nums.size();i++)&#123;</span><br><span class="line">        if(a.count(target - nums<span class="comment">[i]</span>) != 0 &amp;&amp; (a<span class="comment">[target - nums<span class="comment">[i]</span>]</span> != i))&#123;</span><br><span class="line">            b<span class="comment">[0]</span> = i;</span><br><span class="line">            b<span class="comment">[1]</span> = a<span class="comment">[target - nums<span class="comment">[i]</span>]</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br></pre></td></tr></table></figure>
<p>  涉及到的知识：<br>  1.map容器的函数count(key)：如果key键值存在，则返回1，否则返回0<br>  思路：通过target依次减去nums[i]，得到的结果通过count函数搜索是否存在于名为a的map容器中。且通过&amp;&amp;算法来满足“同一个元素在答案里不能重复出现”这一条件。if条件满足后，则赋予名为b的vector容器，最后返回b容器</p>
</li>
</ul>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字0之外，这两个数都不会以0开头。</p>
<img src="/2022/04/24/record01/example02.jpg" class="" title="这是一张图片">

<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> *next;</span><br><span class="line"> *     <span class="type">ListNode</span><span class="literal">()</span> : <span class="keyword">val</span>(<span class="number">0</span>), next(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x, <span class="type">ListNode</span> *next) : <span class="keyword">val</span>(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">ListNode</span>* addTwoNumbers(<span class="type">ListNode</span>* l1, <span class="type">ListNode</span>* l2) &#123;</span><br><span class="line">        <span class="type">ListNode</span>* <span class="type">H</span> = <span class="keyword">new</span> <span class="type">ListNode</span><span class="literal">()</span>;</span><br><span class="line">        <span class="type">ListNode</span>* ptr = <span class="type">H</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || carry)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="keyword">val</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1) <span class="keyword">val</span> += l1-&gt;<span class="keyword">val</span>,l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) <span class="keyword">val</span> += l2-&gt;<span class="keyword">val</span>,l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">val</span> +=carry;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span>* node = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="keyword">val</span> % <span class="number">10</span>);</span><br><span class="line">            ptr-&gt;next = node;</span><br><span class="line">            ptr = node;</span><br><span class="line">            carry = <span class="keyword">val</span> / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return <span class="type">H</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>开始逐行分析与知识点回顾<br>  创建链表的详细过程<br>  1.链表的概念<br>  通过一组任意的存储单元来存储线性表中的数据元素，有一个个结点组成。<br>  2.节点(Node)的框架  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int data<span class="comment">;</span></span><br><span class="line">    ListNode* next<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
  节点分为头节点和首元节点<br>  a.头节点<br>  设置链表前会额外增设一个节点，该节点一般不存放数据。好处是可以使问题简单化。对于链表来讲，不一定非得增设头节点。<br>  b.首元节点<br>  头节点后边的第一个节点，也是链表中的第一个节点。<br>  节点包括数据data和指针Next<br>  a.指针的概念<br>  指针是一个变量，存储另一个变量的地址<br>  <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span>* p;<span class="comment">//定义指针的格式为 数据类型* 指针变量名字</span></span><br><span class="line">p = &amp;a;<span class="comment">//&amp;代表取址符号</span></span><br></pre></td></tr></table></figure><br>  b.结构体指针<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;<span class="comment">//创建一个结构体</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="number">1.</span>创建结构体变量</span><br><span class="line">    student s =&#123;<span class="string">&quot;haha&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    <span class="number">2.</span>通过指针指向结构体变量</span><br><span class="line">    student* p = &amp;s;<span class="comment">//p的类型必须跟s一致</span></span><br><span class="line">    <span class="number">3.</span>指针访问结构体变量中的数据</span><br><span class="line">    cout &lt;&lt; p-&gt;name;<span class="comment">//通过-&gt;访问结构体里的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  结点的框架图：<img src="/2022/04/24/record01/node_structure.jpg" class="" title="这是一张图片">
  创建链表的流程：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*创建一个链表*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createList</span><span class="params">(ListNode* pHead)</span></span>&#123;</span><br><span class="line">    ListNode* p = pHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        ListNode* pNewNode = <span class="keyword">new</span> ListNode;</span><br><span class="line">        pNewNode-&gt;data = i;</span><br><span class="line">        pNewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next = pNewNode;</span><br><span class="line">        p = pNewNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ListNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">createList</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  现来逐个分析   <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    ListNode* head <span class="operator">=</span> NULL<span class="comment">;</span></span><br><span class="line">    head-&gt;data <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    head-&gt;next <span class="operator">=</span> NULL<span class="comment">;</span></span><br><span class="line">    createList(head)<span class="comment">;</span></span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  首先在main函数创建一个名为head的指针结构体变量，在这我们可以把head看成头节点，分配相应内存和初始化成员后如下图所示  <img src="/2022/04/24/record01/createList01.jpg" class="" title="这是一张图片">
  把head指针代入函数createList，开始创建链表  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createList</span>(<span class="params">ListNode* pHead</span>)&#123;</span><br><span class="line">    <span class="title class_">ListNode</span>* p = pHead;</span><br></pre></td></tr></table></figure>
  <img src="/2022/04/24/record01/createList02.jpg" class="" title="这是一张图片">
  创造p节点，令结构体指针p等于pHead，此时p的地址与pHead的地址一样，对p操作就是对pHead操作，所以p也是头节点。  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">    for(int i <span class="operator">=</span> <span class="number">0</span><span class="comment">;i &lt; 10;i++)&#123;</span></span><br><span class="line">        //i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        ListNode* pNewNode <span class="operator">=</span> new ListNode<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  进入for循环，处于i&#x3D;0时。在堆区new一个新内存，存放pNewNode。作为中间结构体为存放新节点提供过渡。<br>  a.new的相关知识<br>  new返回的使 该数据类型的指针<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">new</span> <span class="type">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  b.内存四区<br>  程序运行前：<br>  代码区：存放函数体的二进制代码，由操作系统进行管理<br>  全局区：存放全局变量和静态变量以及常量<br>  程序运行后：<br>  堆区：堆区的数据由程序员开辟，程序员管理使用(delete)<br>  栈区：栈区的数据由系统分配，一般存放函数的参数以及局部变量。函数执行完，栈区的数据都会自动释放。<br>  指针本质是局部变量，放在栈上，但指针保存的数据使放在堆区。<br>  回到链表创建上来  <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i = 0</span></span><br><span class="line"><span class="function"><span class="title">pNewNode</span>-&gt;</span><span class="keyword">data</span> = i;</span><br><span class="line"><span class="function"><span class="title">pNewNode</span>-&gt;</span>next = NULL;</span><br></pre></td></tr></table></figure>
  <img src="/2022/04/24/record01/createList03.jpg" class="" title="这是一张图片">
  当i&#x3D;0时，在pNewNode里存放数据  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">p-&gt;next <span class="operator">=</span> pNewNode<span class="comment">;</span></span><br></pre></td></tr></table></figure>
  <img src="/2022/04/24/record01/createList04.jpg" class="" title="这是一张图片">
  头节点p指向我们的创建的链表的第一个节点 i&#x3D;0下的pNewNode，i&#x3D;0下的pNewNode也称之为首元节点。  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">p</span> <span class="operator">=</span> pNewNode<span class="comment">;</span></span><br></pre></td></tr></table></figure>
  <img src="/2022/04/24/record01/createList05.jpg" class="" title="这是一张图片">
  将i&#x3D;1下的pNewNode的地址赋予给p，所以p与pHead没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。<br>  我们进入下一个循环  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//i <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">ListNode* pNewNode <span class="operator">=</span> new ListNode<span class="comment">;</span></span><br><span class="line">pNewNode-&gt;data <span class="operator">=</span> i<span class="comment">;</span></span><br><span class="line">pNewNode-&gt;next <span class="operator">=</span> NULL<span class="comment">;</span></span><br></pre></td></tr></table></figure>
  <img src="/2022/04/24/record01/createList06.jpg" class="" title="这是一张图片">
  当i&#x3D;1时，在pNewNode里存放数据  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//i <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">p-&gt;next <span class="operator">=</span> pNewNode<span class="comment">;</span></span><br></pre></td></tr></table></figure>
  <img src="/2022/04/24/record01/createList07.jpg" class="" title="这是一张图片">
  节点p指向我们的创建的链表的第一个节点 i&#x3D;1下的pNewNode  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//i <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">p</span> <span class="operator">=</span> pNewNode<span class="comment">;</span></span><br></pre></td></tr></table></figure>
  <img src="/2022/04/24/record01/createList08.jpg" class="" title="这是一张图片">
  将i&#x3D;1下的pNewNode的地址赋予给p，所以p与i&#x3D;0下的pNewNode没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。<br>  我们的创建链表的详细过程就结束了，回到LeetCode题上。</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ListNode* H <span class="operator">=</span> new ListNode()<span class="comment">;</span></span><br><span class="line">ListNode* ptr <span class="operator">=</span> H<span class="comment">;</span></span><br><span class="line">int carry <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>H为定义的头节点，ptr是中间节点，H存放的地址与ptr存放的地址一致。carry为进位数</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">while</span><span class="params">(l1 || l2 || carry)</span></span>&#123;</span><br></pre></td></tr></table></figure>
<p>个人的看法只要当l1 l2的val为0(结构体里的data)及carry为0，才返回false，其他情况一律为true。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l1) <span class="keyword">val</span> += l1-&gt;<span class="keyword">val</span>,l1 = l1-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(l2) <span class="keyword">val</span> += l2-&gt;<span class="keyword">val</span>,l2 = l2-&gt;next;</span><br><span class="line"><span class="keyword">val</span> +=carry;</span><br></pre></td></tr></table></figure>
<p>当l1不为0是 执行if语句 val为l1链表的第一个数字，l1从第一个链表转换成l1的第二个链表<br>第二行代码同理<br>carry是进位制</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="keyword">node</span> <span class="title">= new</span> ListNode(val % <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>创建新链表的第一个节点，存储的数据为 val除以10的余数</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ptr-&gt;next <span class="operator">=</span> node<span class="comment">;</span></span><br><span class="line"><span class="attribute">ptr</span> <span class="operator">=</span> node<span class="comment">;</span></span><br><span class="line"><span class="attribute">carry</span> <span class="operator">=</span> val / <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>因为node存放的数据是我们想要的数据，所以利用ptr的next指针即H的next指针指向node节点，ptr切断与H的联系，令ptr与node指向同一块内存，手法跟创建链表一样。通过相除判断carry是否进1位。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> H-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>H为头节点，头节点下一个next才是链表中的节点。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>第一次写博客，刚开始上手不是很熟悉，所以暂时就写了这周学的LeetCode。下次尝试把参与的项目学到的知识分享在博客中。暂定每周日更新博客，如果有研究僧考试那就咕咕咕~See you next week</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Second learning record in April</title>
    <url>/2022/05/01/record02/</url>
    <content><![CDATA[<p>分享四月第二周学习内容</p>
<span id="more"></span>
<h1 id="leetcode-热题HOT-100"><a href="#leetcode-热题HOT-100" class="headerlink" title="leetcode 热题HOT 100"></a>leetcode 热题HOT 100</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。</p>
<img src="/2022/05/01/record02/example01.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; Mirror;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            Mirror[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(Mirror[s[i]] &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                Mirror[s[l++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret,i - l +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的思路为：定义两个索引箭头指向字符串的两端，左端点的箭头先固定不动，右端点箭头右移进行索引，如果碰到重复字符，记录此时的长度，同时左端点往右移，直到没有重复字符为止。右端指针继续右移操作。重复上述过程</p>
<ul>
<li><p>开始逐行分析与知识点回顾</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int n <span class="operator">=</span> s.length()<span class="comment">;</span></span><br><span class="line">int ret <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">int l <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>  n为字符串长度，ret代表我们想返回的值，也就是最长子串的长度。l代表左端点指针</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; Mirror;</span><br></pre></td></tr></table></figure>
<p>  定义一个名为Mirror的map容器，键值类型为char，用来存放单个字符。实值类型为int，用来存放字符在字符串的个数<br>  特点是：<br>  1.键只能有一个，但实值能有许多个<br>  2.无序排列<br>  3.通过 容器名[] 能直接添加键值</p>
  <figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for(int i = 0;i &lt; n;i++)&#123;</span><br><span class="line">        Mirror<span class="comment">[s<span class="comment">[i]</span>]</span>++;</span><br><span class="line">        while(Mirror<span class="comment">[s<span class="comment">[i]</span>]</span> &gt;= 2)&#123;</span><br><span class="line">            Mirror<span class="comment">[s<span class="comment">[l++]</span>]</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret,i - l +1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br></pre></td></tr></table></figure>
<p>  i代表右端点索引箭头，i++代表右端点箭头右移<br>  Mirror[s[i]]++; 表示的是右端点指向字符存进map容器中，相应的实值从默认的0增加1个单位。<br>  while(Mirror[s[i]] &gt;&#x3D; 2){    当存放的数量大于1时候 我们就需要将左端点右移<br>  Mirror[s[l++]]–;     l++代表左端点右移。要注意l先执行之前的数字，执行完后才进行自身的加1操作。与++l要区分开。 左端点指针右移的同时(也就是l++)，map容器里存放的相应的字符数量-1。因为右端点索引箭头指向重复字符时，左端点右移要移动到“重复字符的右边一个单位”，这样才能使两端点内的字符不会有重复的字符，移动的同时会“损失一部分字符” ，所以要-1。<br>  ret记录最长长度，循环结束后返回。</p>
</li>
</ul>
<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><p>给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。</p>
<img src="/2022/05/01/record02/example02.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> find<span class="constructor">Kth(<span class="params">const</span> <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">a</span>,<span class="params">int</span> <span class="params">sta</span>,<span class="params">const</span> <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">b</span>,<span class="params">int</span> <span class="params">stb</span>,<span class="params">int</span> <span class="params">kth</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sta &gt;= a.size<span class="literal">()</span>) return b<span class="literal">[<span class="identifier">kth</span> - <span class="number">1</span> + <span class="identifier">stb</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span>(stb &gt;= b.size<span class="literal">()</span>) return a<span class="literal">[<span class="identifier">kth</span> - <span class="number">1</span> + <span class="identifier">sta</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth<span class="operator"> == </span><span class="number">1</span>) return min(a<span class="literal">[<span class="identifier">sta</span>]</span> , b<span class="literal">[<span class="identifier">stb</span>]</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> h = kth<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> vala = a.size<span class="literal">()</span> - sta &gt;= h ? a<span class="literal">[<span class="identifier">sta</span> + <span class="identifier">h</span> - <span class="number">1</span>]</span> : a.back<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> h_a = a.size<span class="literal">()</span> - sta &gt;= h ? h : a.size<span class="literal">()</span> - sta;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> valb = b.size<span class="literal">()</span> - stb &gt;= h ? b<span class="literal">[<span class="identifier">stb</span> + <span class="identifier">h</span> - <span class="number">1</span>]</span> : b.back<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> h_b = b.size<span class="literal">()</span> - stb &gt;= h ? h : b.size<span class="literal">()</span> - stb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vala &gt;= valb)&#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">a</span>,<span class="params">sta</span>,<span class="params">b</span>,<span class="params">stb</span> + <span class="params">h_b</span>,<span class="params">kth</span> - <span class="params">h_b</span>)</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">a</span>,<span class="params">sta</span> + <span class="params">h_a</span>,<span class="params">b</span>,<span class="params">stb</span>,<span class="params">kth</span> - <span class="params">h_a</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    double find<span class="constructor">MedianSortedArrays(<span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">a</span>, <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> n = a.size<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> m = b.size<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> k = n + m;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> k1 = (k + <span class="number">1</span>)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> k2 = (k + <span class="number">2</span>)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> ava_1 = find<span class="constructor">Kth(<span class="params">a</span>,0,<span class="params">b</span>,0,<span class="params">k1</span>)</span>;</span><br><span class="line">        <span class="built_in">int</span> ava_2 = find<span class="constructor">Kth(<span class="params">a</span>,0,<span class="params">b</span>,0,<span class="params">k2</span>)</span>;</span><br><span class="line"></span><br><span class="line">        return <span class="number">1.</span>*(ava_1 + ava_2)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题用到数据结构中的二分查找法。<br>二分查找法的基本思路：<br>目标数组必须有序，我们找数组里的数通常会一个一个查找，这样的话效率非常低。二分查找是直接在有序数组中找到中间元素，我们想查找的数与中间元素进行对比，如果小就代表想找的数在中间元素的左方向(假设)，大的话就是右方向。于是我们在左边这一段找到左边这段的中间元素，通过比大小找到目标数字的区间，再从区间里继续寻找中间元素，反复比较，最后找到目标数字。<br>以上介绍的思路为一个数组，而这题涉及到两个数组，换种查找思路。</p>
<img src="/2022/05/01/record02/Binary_search01.jpg" class="" title="这是一张图片">
<p>首先计算两个数组的整体长度，中位数即为最中间的数或者是中间两数的平均数，所以我们只需要找到整体长度前半段，就能找到我们需要的中位数。因为这里有两个数组，因此，我们把整体长度前半段“一分为二”，一半放第一个数组的数字，另一半放第二个数组里的数字。(均为从小到大，不是随意抽取数组数字)。</p>
<img src="/2022/05/01/record02/Binary_search02.jpg" class="" title="这是一张图片">
<p>我们把第一个数组放入“一半”里的最大数字(即最右边的数字)和第二个数组放入“另一半”里的最大数字(即最右边的数字)进行比较，假设第一组的最大数字比第二组大，那么可以判断中位数不在第二组放入“一半”的数字里，即中位数应当存在于第一组和第二组剩余的数字里。</p>
<img src="/2022/05/01/record02/Binary_search03.jpg" class="" title="这是一张图片">
<ul>
<li><p>开始逐行分析与知识点回顾<br>  为了方便介绍思路:我们假定a&#x3D;{3，6，11，13}，b&#x3D;{4，9，12，14，16，20}，</p>
  <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = a.<span class="keyword">size</span>();<span class="comment">//n = 4</span></span><br><span class="line"><span class="keyword">int</span> m = b.<span class="keyword">size</span>();<span class="comment">//m = 6</span></span><br><span class="line"><span class="keyword">int</span> k = n + m;<span class="comment">//k = 10</span></span><br></pre></td></tr></table></figure>
<p>  先看主函数，m和n分别是向量a与向量b的长度，k为总长度。</p>
  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> k1 = (k + <span class="number">1</span>) / <span class="number">2</span>; //k1 = <span class="number">5</span></span><br><span class="line"><span class="attribute">int</span> k2 = (k + <span class="number">2</span>) / <span class="number">2</span>; //k2 = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>  常规来讲，长度可分为奇数与偶数，所以中位数位置都会有所不同。但通过c++环境的特性，我们可以把奇数偶数找中位数的算法统一为一个方式。如果是奇数，他们的+1 +2再除以2的结果是相同的，我们把这两个结果相加再除以2就能得到奇数的中位数的下标位置。同理，偶数+1 +2再除以2得到的是中间两个数的下标位置。</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> ava_1 = find<span class="constructor">Kth(<span class="params">a</span>,0,<span class="params">b</span>,0,<span class="params">k1</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> ava_2 = find<span class="constructor">Kth(<span class="params">a</span>,0,<span class="params">b</span>,0,<span class="params">k2</span>)</span>;</span><br><span class="line">return <span class="number">1.</span>*(ava_1 + ava_2)<span class="operator"> / </span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>  通过算法找到下标所对应的数字，最后返回中位数</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int ava_1 = findKth(a,0,b,0,k1);</span></span><br><span class="line"><span class="built_in">int</span> find<span class="constructor">Kth(<span class="params">const</span> <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">a</span>,<span class="params">int</span> <span class="params">sta</span>,<span class="params">const</span> <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">b</span>,<span class="params">int</span> <span class="params">stb</span>,<span class="params">int</span> <span class="params">kth</span>)</span></span><br></pre></td></tr></table></figure>
<p>  接下来看ava_1函数部分：a和b代表我们输入进来的向量，sta和stb是a向量与b向量输入进来的起始下标。kth为我们索引的长度。kth &#x3D; k1;</p>
  <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//int ava_1 = findKth(a,0,b,0,k1);</span></span><br><span class="line"><span class="built_in">if</span>(sta &gt;= a.size()) return <span class="selector-tag">b</span><span class="selector-attr">[kth - 1 + stb]</span>;</span><br><span class="line"><span class="built_in">if</span>(stb &gt;= b.size()) return <span class="selector-tag">a</span><span class="selector-attr">[kth - 1 + sta]</span>;</span><br><span class="line"><span class="built_in">if</span>(kth == <span class="number">1</span>) return <span class="built_in">min</span>(a[sta] , b[stb]);</span><br></pre></td></tr></table></figure>
<p>  此为结束递归函数的三种条件，即我们需要的初始下标大于a的长度时，就代表还没找到需要的数字，我们的a数组就已经索引完了，所以肯定我们需要找的数在b数组。第三种条件为我们找到最后索引长度为1，意味着我们找的数字要么在a数组或者b数组剩余的数字的第一位，所以只要比较a和b最小的数字就能找到我们需要找的数字</p>
  <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> h = kth / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> vala = a.<span class="built_in">size</span>() - sta &gt;= h ? a[sta + h - <span class="number">1</span>] : a.back();</span><br><span class="line"><span class="built_in">int</span> h_a = a.<span class="built_in">size</span>() - sta &gt;= h ? h : a.<span class="built_in">size</span>() - sta;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> valb = b.<span class="built_in">size</span>() - stb &gt;= h ? b[stb + h - <span class="number">1</span>] : b.back();</span><br><span class="line"><span class="built_in">int</span> h_b = b.<span class="built_in">size</span>() - stb &gt;= h ? h : b.<span class="built_in">size</span>() - stb;</span><br></pre></td></tr></table></figure>
  <img src="/2022/05/01/record02/Binary_search04.jpg" class="" title="这是一张图片">
<p>  h为索引长度的一半，也可理解每个向量需要索引数字的个数<br>  vala后面跟着三目运算，当a的长度减去起始长度大于需要索引的数字，就证明a数组是有空间提供“需要索引数字的个数”，于是vala&#x3D;“需要索引数字的个数”的最大值，也就是最右边的数，h_a意味着实际索引数字的个数，因为a是有空间提供，所以h_a&#x3D;h。如果a数组没有空间提供“需要索引数字的个数”，就直接vala&#x3D;a数组最右边的数组，h_a&#x3D;a的长度-a的索引的起始位置。</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(vala &gt;= valb)&#123;</span><br><span class="line">    return find<span class="constructor">Kth(<span class="params">a</span>,<span class="params">sta</span>,<span class="params">b</span>,<span class="params">stb</span> + <span class="params">h_b</span>,<span class="params">kth</span> - <span class="params">h_b</span>)</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    return find<span class="constructor">Kth(<span class="params">a</span>,<span class="params">sta</span> + <span class="params">h_a</span>,<span class="params">b</span>,<span class="params">stb</span>,<span class="params">kth</span> - <span class="params">h_a</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当a索引的最大数字大于b索引的最大数字时，说明中位数绝对不在b索引的数字里。于是a的起始下标不动，b的起始下标移动到索引数字的右边一个单位，索引长度由之前的h更新为h-h_b，进行递归迭代。后面的过程看图即可。</p>
  <img src="/2022/05/01/record02/Binary_search05.jpg" class="" title="这是一张图片"></li>
</ul>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给你一个字符串s，找到s中最长的回文子串。</p>
<img src="/2022/05/01/record02/example03.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">string</span> longestPalindrome(<span class="type">string</span> s) &#123;</span><br><span class="line">        <span class="type">int</span> m = s.length();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; f(m , vector&lt;<span class="type">bool</span>&gt;(m , <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> p_left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            f[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">len</span> = <span class="number">2</span>;<span class="built_in">len</span> &lt;= m;<span class="built_in">len</span>++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i + <span class="built_in">len</span> &lt;= m;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j = i + <span class="built_in">len</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">len</span> &gt; <span class="number">2</span> &amp;&amp; f[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                f[i][j] = <span class="literal">true</span>;</span><br><span class="line">                p_left = i;</span><br><span class="line">                maxlen =<span class="built_in">len</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(p_left,maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题用到数据结构中的动态规划算法。<br>思路：跟第三题类似，需要定义一个左指针和右指针，长度由小到大进行递增。一个满足条件的回文子串的&#x3D;他的两端字符相等+剩下的子串是回文子串。</p>
<ul>
<li><p>开始逐行分析与知识点回顾</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = s.<span class="built_in">length</span>();<span class="comment">//字符串长度</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(m , <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m , <span class="literal">false</span>)); <span class="comment">//定义了bool类型的二维数组，默认为false</span></span><br><span class="line"><span class="type">int</span> p_left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxlen = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>  bool类型二维数组[i][j]含义：如果字符串从i到j是回文子串，则返回true，否则就是false<br>  p_left为最长回文子串的左端点索引箭头，maxlen记录最长的回文子串长度</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">for(int i <span class="operator">=</span> <span class="number">0</span><span class="comment">;i &lt; m;i++)&#123;</span></span><br><span class="line">    f[i][i] <span class="operator">=</span> true<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  因为单个字符某种意义上也是回文子串，所以单个字符的字符串为true。</p>
  <figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">for(<span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">2</span>;<span class="built_in">len</span> &lt;= m;<span class="built_in">len</span>++)&#123;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>;i + <span class="built_in">len</span> &lt;= m;i++)</span><br></pre></td></tr></table></figure>
<p>  长度从2开始递增，i为左端点索引箭头。</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = i + <span class="built_in">len</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[i] != s[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span> &gt; <span class="number">2</span> &amp;&amp; f[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>  j为右端点索引箭头<br>  如果目标字符串左端点与右端点不相同，则不是回文子串，continue跳过此次循环<br>  如果长度大于2，即使认证了两个端点相同也要鉴定里面一层是否为字符串，如果为false，依然continue跳过此次循环</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">f[i][j] <span class="operator">=</span> true<span class="comment">;</span></span><br><span class="line">p_left <span class="operator">=</span> i<span class="comment">;</span></span><br><span class="line"><span class="attribute">maxlen</span> <span class="operator">=</span>len<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>  如果前面的满足都满足 证明此为回文子串，则p_left记录该指索引左端点，maxlen记录此时的长度</p>
  <figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> s.<span class="title">substr</span><span class="params">(p_left,maxlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>  最后通过string里的函数substr获得最长回文子串<br>  substr(pos,len)：从pos位置开始拷贝len长度的字符</p>
</li>
</ul>
<h1 id="动态规划的入门学习"><a href="#动态规划的入门学习" class="headerlink" title="动态规划的入门学习"></a>动态规划的入门学习</h1><p>动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。<br>步骤：<br>1.确定dp数组(dp table)以及下标的含义<br>2.确认状态转移方程，即递推公式<br>3.dp数组如何初始化<br>4.遍历顺序的确定<br>5.推导整个dp数组</p>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p>斐波那契数（通常用 F(n)表示）形成的序列称为斐波那契数列。该数列由0和1开始，后面的每一项数字都是前面两项数字的和。</p>
<img src="/2022/05/01/record02/example04.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> fib(<span class="built_in">int</span> N) &#123;</span><br><span class="line">        <span class="built_in">int</span> dp[<span class="number">31</span>];<span class="comment">//定义dp数组</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化数组</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];<span class="comment">//状态方程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>斐波那契数是动态规划中最简单直观的题。它直接把步骤2的状态转移方程、步骤3初始化的数字和步骤4的遍历顺序直接告诉你，而且步骤1的dp数组有现成且下标含义也简单易懂，所以推导起来很容易</p>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<img src="/2022/05/01/record02/example05.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> dp[<span class="number">46</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>爬楼梯这题稍微抽象点，但也简单。我们先从最底层开始理解起 假设我们的起始台阶为第0阶，爬到第一个台阶的方法只有1个，爬到第二个台阶的方法有两个，分别是2，1+1。<br>如果我们想要爬到第三个台阶，有两种方式，从第一阶跨2个台阶或者从第二阶跨1个台阶。有两种方式但有几种方法呢？所以我们要得到跨第一个台阶的方法数量以及跨第二台阶的方法数量分别是1，2，所以爬到第三个台阶的方法数量为1+2&#x3D;3。<br>如果我们想要爬到第四个台阶，依然有两种方式，从第二阶跨2个台阶或者从第三阶跨1个台阶。有两种方式但有几种方法呢？我们得到跨第二个台阶的方法数量为2以及跨第三台阶的方法数量为3，所以爬到第四个台阶的方法数量为2+3&#x3D;5。 跟之前的斐波那契数很相似<br>所以<br>1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[46]; 下标代表从0到下标位置需要的方法数量<br>2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; dp[i - 1] + dp[i - 2]; 想要爬到第i个台阶，有两种方式，两种方式对应的方法数量为dp[i - 1]和dp[i - 2]。<br>3.dp数组如何初始化  &#x3D;&gt;爬第一个阶梯和第二阶梯方法是很容易推导，所以我们定义dp[1] &#x3D; 1;dp[2] &#x3D; 2;<br>4.遍历顺序的确定 &#x3D;&gt;从第三阶梯开始，故从3开始<br>5.推导整个dp数组</p>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p>给你一个整数数组cost，其中cost[i]是从楼梯第i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为0或下标为1的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。</p>
<img src="/2022/05/01/record02/example06.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">( m + <span class="number">1</span>, <span class="number">0</span> )</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先理解一下题意 如果你从i台阶想向上爬，就需支付i对应的cost，你可以选择爬1台阶或者选择爬2台阶。<br>这题跟之前的爬楼梯类似，但是增加了费用这一选项。如果跟之前一样dp数组的下标代表从0到下标位置需要的方法数量，我们的cost无法考虑进去，所以变换一种思路，dp数组表示从0到i台阶的费用，这样我们就把cost考虑进去，这里不需要考虑方法数量，题目只要求最小的费用。但是这种定义很难求得最小的费用，于是继续变换思路，dp数组表示从0到i台阶的最小费用。从“从下标为0或下标为1的台阶开始爬楼梯”得知，我们从0台阶到0台阶，或者0台阶到1台阶的最小费用都为0，所以初始化确定。假如我们到下标为2的台阶，他有两种方式，一种是0台阶选择跨2台阶，费用为0 + 0阶对应的cost；另一种是1台阶选择跨1台阶，费用为0 + 1阶对应的cost，我们需要求最小的费用所以就有了min(dp[0]+cost[0],dp[1]+cost[1])，这就是我们的状态转移方程了，遍历顺序从2起步<br>1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector<int> dp( m + 1, 0 ); 下标代表从0到下标位置需要的最小费用<br>2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); 爬到第i个台阶，有两种付费方式，两种付费方式对应为dp[i-1]+cost[i-1]和dp[i-2]+cost[i-2]。<br>3.dp数组如何初始化  &#x3D;&gt;dp[0] &#x3D; 0;dp[1] &#x3D; 0;<br>4.遍历顺序的确定 &#x3D;&gt;从第二阶梯开始，故从2开始<br>5.推导整个dp数组</p>
<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h2><p>一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？</p>
<img src="/2022/05/01/record02/example07.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int dp<span class="comment">[m]</span><span class="comment">[n]</span> ;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i &lt; m;i++)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[0]</span> = 1;</span><br><span class="line"></span><br><span class="line">        for(int i = 0;i &lt; n;i++)</span><br><span class="line">            dp<span class="comment">[0]</span><span class="comment">[i]</span> = 1;</span><br><span class="line"></span><br><span class="line">        for(int i = 1;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 1;j &lt; n;j++)&#123;</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i]</span><span class="comment">[j - 1]</span> + dp <span class="comment">[i-1]</span><span class="comment">[j]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp<span class="comment">[m-1]</span><span class="comment">[n-1]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先从简单的2x2网格入手。我们从起始点1x1出发，移动到1x2或者是2x1因为机器人只能右移或者左移，所以只有一条路径选择。移动到2x2有两种方式，一个从1x2或者2x1，两种方式都是1种选择，所以不难判断移动到2x2的路径选择有1+1&#x3D;2种。所以dp数组得建立一个二维数组。[i][j]下标代表到达ixj的路径个数。我们的初始化很容易确定，即第一行和第一列的路径选择都是1。状态转移方程为dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j];从下标1还是遍历<br>1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[m][n] ; 下标代表到达对应位置的路径数量<br>2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和<br>3.dp数组如何初始化  &#x3D;&gt;dp[i][0] &#x3D; 1;  dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种<br>4.遍历顺序的确定 &#x3D;&gt;从1x1开始<br>5.推导整个dp数组</p>
<h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h2><p>一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用1和0来表示。</p>
<img src="/2022/05/01/record02/example08.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> uniquePathsWithObstacles(<span class="type">vector</span>&lt;<span class="type">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        <span class="type">int</span> raws = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> <span class="built_in">cols</span> = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">vector</span>&lt;<span class="type">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp(raws, <span class="type">vector</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">cols</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; raws &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">cols</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; raws;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; <span class="built_in">cols</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp [i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[raws - <span class="number">1</span>][<span class="built_in">cols</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这题思路跟之前的一样，只不过需要判断所到的点是否有障碍物。dp数组的含义依然是到达对应位置的路径数量，但是初始化的时候第一行或者第一列如果遇到障碍物则令其对应位置的路径数量为0，且这位置往右或者往下的所有位置都为0，因为有了阻碍所以让后面的位置不能初始化，先暂定为0。然后就判断当我们到达的位置判断0或1，如果是0则表示无障碍，可以进行动态规划，如果不可以则跳过此次循环。<br>1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector&lt;vector<int>&gt; dp(raws, vector<int>(cols, 0)); 下标代表到达对应位置的路径数量<br>2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和<br>3.dp数组如何初始化  &#x3D;&gt;dp[i][0] &#x3D; 1;  dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种<br>4.遍历顺序的确定 &#x3D;&gt;从1x1开始<br>5.推导整个dp数组</p>
<p>OK~动态规划就学这么多，因为之前在leetcode遇到的题以及接下来的题都遇到动态规划，所以特地先去网上找了些资料当专题刷了一下。leetcode先暂停更新，等动态规划所有题型刷完就回来继续刷热题100道！</p>
<p>分享最近读的书《掌握习惯》<br>很喜欢里面的几句话<br>–你可能会出于某种动机而培养一种习惯，但让你长期保持这种习惯的唯一原因是它已经与你的身份融为一体。<br>–你此时此刻是成就辉煌还是一事无成并不重要，重要的是你当前的习惯是否让你走上了通向成功的道路。<br>希望我能坚持把Blog更新下去，然后培养读书的习惯，就像那本书所说，习惯培养起来了，目标不会太远。希望每一步一步脚印能让我变得更好~下周见</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>First learning record in May</title>
    <url>/2022/05/06/record03/</url>
    <content><![CDATA[<p>分享五月第一周学习内容</p>
<span id="more"></span>
<h1 id="动态规划的入门学习"><a href="#动态规划的入门学习" class="headerlink" title="动态规划的入门学习"></a>动态规划的入门学习</h1><p>动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。<br>步骤：<br>1.确定dp数组(dp table)以及下标的含义<br>2.确认状态转移方程，即递推公式<br>3.dp数组如何初始化<br>4.遍历顺序的确定<br>5.推导整个dp数组</p>
<h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><p>给定一个正整数n，将其拆分为k个正整数的和（k &gt;&#x3D; 2），并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p>
<img src="/2022/05/06/record03/dpExample01.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i/<span class="number">2</span>+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],<span class="built_in">max</span>(dp[i-j]*j,(i-j)*j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先举个栗子<br>当n&#x3D;2时，拆分的数字为1和1。乘积为1。<br>当n&#x3D;3时，拆分的数字为2和1。乘积为2。<br>当n&#x3D;4时，拆分的数字为2和2。乘积为4。<br>当n&#x3D;5时，拆分的数字为2和3。乘积为6。<br>当n&#x3D;6时，拆分的数字为3和3。乘积为9。<br>当n&#x3D;7时，拆分的数字为2、3和2或者4和3。乘积为12。<br>当n&#x3D;8时，拆分的数字为2、3和3。乘积为18。<br>当n&#x3D;9时，拆分的数字为3、3和3。乘积为27。<br>当n&#x3D;10时，拆分的数字为2、3、2和3。乘积为36。<br>首先第一步要从这些栗子中找到动态规划的规律，我们才能列出dp的含义以及动态方程。<br>乍一看没啥思路，其实我们可以把栗子作进一步拆解。<br>当n&#x3D;2时，拆分的数字为1和1。最大乘积为1。<br>当n&#x3D;3时，拆分的数字为2和1。2的最大乘积乘以1等于1，2的本身乘以1等于2。于是3的最大乘积等于2。<br>当n&#x3D;4时，第一种拆分的数字为3和1。3的最大乘积乘以1等于2，3的本体乘以1等于3；第二种拆分的数字为2和2，2的最大乘积乘以2等于2，2的本身乘以2等于4。于是4的最大乘积等于4。<br>当n&#x3D;5时，第一种拆分方式为4和1。4的最大乘积乘以1等于4，4的本身乘以1等于4。第二种拆分方式为3和2，3的最大乘积乘以2等于4，3的本身乘以2等于6。于是5的最大乘积等于6。<br>当n&#x3D;6时，第一种拆分方式为4和2(1直接略过)。4的最大乘积乘以2等于8，4的本身乘以2等于8。第二种拆分方式为3和3。3的最大乘积乘以3等于6，3的本身乘以3等于9。于是6的最大乘积等于9。<br>当n&#x3D;7时，第一种拆分方式为5和2(1直接略过)。5的最大乘积乘以2等于12，5的本身乘以2等于10。第二种拆分方式为4和3。4的最大乘积乘以3等于12，4的本身乘以3等于12。于是7的最大乘积等于12。<br>当n&#x3D;8时，第一种拆分方式为6和2(1直接略过)。6的最大乘积乘以2等于18，6的本身乘以2等于12。第二种拆分方式为5和3。5的最大乘积乘以3等于18，5的本身乘以3等于15。第三种拆分方式为4和4。4的最大乘积乘以4等于16，4的本身乘以4等于16。于是8的最大乘积等于18。<br>当n&#x3D;9时，第一种拆分方式为7和2(1直接略过)。7的最大乘积乘以2等于24，7的本身乘以2等于14。第二种拆分方式为6和3。6的最大乘积乘以3等于27，6的本身乘以3等于18。第三种拆分方式为5和4。5的最大乘积乘以4等于24，5的本身乘以4等于20。于是9的最大乘积等于27。<br>当n&#x3D;10时，第一种拆分方式为8和2(1直接略过)。8的最大乘积乘以2等于36，8的本身乘以2等于16。第二种拆分方式为7和3。7的最大乘积乘以3等于36，7的本身乘以3等于21。第三种拆分方式为6和4。6的最大乘积乘以4等于36，6的本身乘以4等于24。第四种拆分方式为5和5。5的最大乘积乘以5等于30，5的本身乘以5等于25。于是10的最大乘积等于36。<br>现在思路清晰了，我们先把数字A拆成1和A-1，直接讨论A-1的最大乘积大还是A-1本身大，最大的那个数乘以1得到的结果就是在1状态下数字A的最大乘积。继续把A拆成2和A-2，直接讨论A-2的最大乘积大还是A-2本身大，最大的那个数乘以2得到的结果就是在2状态下数字A的最大乘积……最后比较这些状态下的最大乘积，我们就能得到A的最大乘积。</p>
<p>1.确定dp数组(dp table)以及下标的含义    dp[i]的含义是在第i个数下的最大乘积。<br>2.确认状态转移方程，即递推公式      dp[i] &#x3D; max(dp[i],max(dp[i-j]*j,(i-j)*j))   max(dp[i-j]*j,(i-j)*j)代表j状态下的i最大乘积，max里的dp[i]代表之前也就是j-1状态下的i最大乘积，两者需要相互比较。<br>3.dp数组如何初始化      dp[2] &#x3D; 1;<br>4.遍历顺序的确定        i表示从第2个数字，按照正序遍历到n。j就代表拆分下的j状态数字。<br>5.推导整个dp数组</p>
<h2 id="背包二维"><a href="#背包二维" class="headerlink" title="背包二维"></a>背包二维</h2><p>有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p>
<img src="/2022/05/06/record03/dpExample02.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_weibagPromble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span> , <span class="number">3</span> , <span class="number">4</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span> , <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">	<span class="type">int</span> bagweight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = bagweight; i &gt;= weight[<span class="number">0</span>]; i--) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = value[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; weight[i]) &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test_weibagPromble</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。<br>首先我们联想一下上一道拆分数组。拆分数组的思路是把数字A拆分成1状态和A-1，然后搜寻A-1的最大值。然后拆分成2状态和A-2，然后搜寻1-2的最大值。我们照葫芦画瓢，运用到这题上：<br>假设第一个物品重量为weight[0]，价值为value[0]。背包重量为j，我们就理解成当j&gt;weight[0]时，j此时的最大价值&#x3D;背包重量为j-weight[0]时的最大价值+value[0]。j&lt;weight[0]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。<br>假设第二个物品重量为weight[1]，价值为value[1]。背包重量为j，我们就理解成当j&gt;weight[1]时，j此时的最大价值&#x3D;背包重量为j-weight[1]时的最大价值+value[1]。j&lt;weight[1]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。<br>但怎么求“背包重量为W-weight[0]时的最大价值”呢？<br>于是我们要遍历从0到W的背包重量，那么很容易看出dp应该是二维数组，dp[i][j]为背包重量为j时装第i个物品的最大价值。<br>那么dp[i][j]是怎么来的？<br>当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。<br>当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。<br>那怎么初始化？<br>背包重量为0时，装不下任何物品，故dp[i][0]都为0。<br>讨论第一个物品时，应该背包里没有其他物品，所以当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。</p>
<p>1.确定dp数组(dp table)以及下标的含义    dp[i][j]为背包重量为j时装第i个物品的最大价值。<br>2.确认状态转移方程，即递推公式      当j&lt;weight[i]时，dp[i][j]&#x3D; dp[i - 1][j]。 当j&gt;weight[i]时，dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);<br>3.dp数组如何初始化      dp[0][i] &#x3D; value[0]  当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。<br>4.遍历顺序的确定        i代表物品，因为C++数组的原因，本应从0开始遍历，但之前初始化了，所以从1开始（也就是从第二个物品）开始遍历。j代表背包重量，从0开始<br>5.推导整个dp数组</p>
<h2 id="背包一维"><a href="#背包一维" class="headerlink" title="背包一维"></a>背包一维</h2><p>有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p>
<img src="/2022/05/06/record03/dpExample02.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_weibagPromble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; weight = &#123; <span class="number">1</span> , <span class="number">3</span> , <span class="number">4</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; value = &#123; <span class="number">15</span> , <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">	<span class="type">int</span> bagweight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(bagweight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = bagweight; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">			dp1[j] = <span class="built_in">max</span>(dp1[j], dp1[j - weight[i]] + value[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test_weibagPromble</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。<br>之前的dp为二维数组。那怎么运用到一维数组？<br>二维dp数组的含义是 dp[i][j]为背包重量为j时装第i个物品的最大价值，dp[i]如果表示第i个物品的最大价值显然不行，那么表示成dp[j]为背包重量为j时的最大价值呢。<br>那么dp[j]怎么来呢？<br>回顾一下二维数组的dp来源<br>当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。<br>当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。<br>那么更换成一维数组dp<br>当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[j]应等于重量为j的背包装第i-1件时的物品时的最大值。<br>当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。<br>那么可以确认 dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i]) max里的dp[j]就是重量为j的背包装第i-1件时的物品时的最大值。<br>那怎么初始化？<br>众所周知重量为0时啥也装不下，所以价值必为0，所以dp[0] &#x3D; 0；从max和value不可能为负数可以得知，我们也可以把dp整个数组的数都初始为0，定义为0对之后在max里取最大值也没啥影响。<br>遍历顺序怎么确定？<br>如果是正序，那么会遇到一个问题。假如物品重量为1，价值为value[1]<br>当j&#x3D;1时，dp[1]&#x3D;value[1]。<br>当j&#x3D;2时候，因为dp[2] &#x3D; max(dp[2],dp[2 - weight[1]] + value[1])，max里的dp[2]&#x3D;0，dp[2 - weight[1]] + value[1]&#x3D;dp[1]+value[1]&#x3D;2xvalue[1]。也就是说在j&#x3D;2的时候value取了两次值。<br>所以不能正序遍历，那逆序呢？<br>当j&#x3D;4时，因为dp[4] &#x3D; max(dp[4],dp[4 - weight[1]] + value[1])，max里的dp[4]&#x3D;0，dp[4 - weight[1]] + value[1]&#x3D;dp[3]+value[1]&#x3D;value[1]。<br>当j&#x3D;3时候，因为dp[3] &#x3D; max(dp[3],dp[3 - weight[1]] + value[1])，max里的dp[3]&#x3D;0，dp[3 - weight[1]] + value[1]&#x3D;dp[2]+value[1]&#x3D;value[1]。这样就不会产生取两次值的情况。</p>
<p>1.确定dp数组(dp table)以及下标的含义    dp[j]为背包重量为j时的最大价值。<br>2.确认状态转移方程，即递推公式      dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i])<br>3.dp数组如何初始化      dp[j]&#x3D; 0<br>4.遍历顺序的确定        逆序。<br>5.推导整个dp数组</p>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<img src="/2022/05/06/record03/dpExample03.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> sumHalf = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sumHalf + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = sumHalf;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[sumHalf] == sumHalf) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两个子集的元素和相等，可以推断出两个子集的元素和相加等于原数组nums各个数字之和，换句话说两个子集元素的和是nums各个元素和的一半，所以不难判断如果nums各个元素和为奇数，那么false。<br>那么怎么确认dp[i]还是dp[i][j]？<br>刚才我们分析出两个子集的元素和等于nums各个元素和的一半，我们令nums的和为sum，子集元素和为sumHalf。我们可以能把这题转换为刚才的背包问题，两个子集就是两个背包，sumHalf为背包重量，nums里的元素即为物品重量，这里的价值可以看成放入背包物品的最大重量，最大容量不能超过背包重量。根据之前的背包一维dp[j]为背包重量为j时的最大价值可以推断出dp[i]为背包重量为i时候的放入物品的最大重量。那么我要做的就是在背包重量为sumHalf时(dp[sumHalf])放入物品的最大重量等于sumHalf，那样的话另一个背包放入物品的最大重量必定sum-dp[sumHalf],如果sumHalf &#x3D;&#x3D; sum-dp[sumHalf]，或者dp[sumHalf] &#x3D; sumHalf，那直接返回true。<br>那怎么初始化？<br>跟之前一维背包一样，全部定义为0即可。<br>遍历顺序跟一维背包一样，采用逆序。<br>1.确定dp数组(dp table)以及下标的含义    dp[j]为背包重量为j时的放入物品的最大重量。<br>2.确认状态转移方程，即递推公式      dp[j] &#x3D; max(dp[j],dp[j - nums[i]] + nums[i])<br>3.dp数组如何初始化      dp[j]&#x3D; 0<br>4.遍历顺序的确定        逆序。<br>5.推导整个dp数组</p>
<p>OK~动态规划就学这么多(其实还有一题- -)，因为最近学校解封，跟同学各种聚餐…所以就更了这么点- -下周好好干会来！！多学点知识！！</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Second learning record in May</title>
    <url>/2022/05/15/record04/</url>
    <content><![CDATA[<p>分享五月第二周学习内容</p>
<span id="more"></span>
<h1 id="动态规划的入门学习"><a href="#动态规划的入门学习" class="headerlink" title="动态规划的入门学习"></a>动态规划的入门学习</h1><p>动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。<br>步骤：<br>1.确定dp数组(dp table)以及下标的含义<br>2.确认状态转移方程，即递推公式<br>3.dp数组如何初始化<br>4.遍历顺序的确定<br>5.推导整个dp数组</p>
<h2 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a>1049. 最后一块石头的重量 II</h2><p>有一堆石头，用整数数组stones表示。其中 stones[i] 表示第i块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x &lt;&#x3D; y。那么粉碎的可能结果如下：<br>如果x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果x !&#x3D; y，那么重量为x的石头将会完全粉碎，而重量为y的石头新重量为y-x。<br>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回0。</p>
<img src="/2022/05/15/record04/dpExample01.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> lastStoneWeightII(vector&lt;<span class="built_in">int</span>&gt;&amp; stones) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; dp(<span class="number">15001</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">sum</span> += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">target</span> = <span class="built_in">sum</span> / <span class="number">2</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            for(<span class="built_in">int</span> j = <span class="keyword">target</span>;j &gt;= stones[i];j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span> - dp[<span class="keyword">target</span>] - dp[<span class="keyword">target</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp的含义？<br>这题跟上周写的“分割等和子集”类似，只不过换了种表达方式。“石头碰撞后最小重量”可以翻译为：石头分为两个背包，两个背包的和尽可能相近，最好相等。所以dp跟“分割等和子集”类似。在“分割等和子集”理，dp[j]的含义为背包重量为j时能容量最大的数字和。所以在这题可以理解为背包重量之和为j时能能容量最大的数字和<br>dp来源？<br>“分割等和子集”的dp[j]来源为dp[j]自身的重量与dp[j-nums[i]]+nums[i]的最大值。<br>因此本题的dp来源为 dp[j]与dp[j - stones[i]] + stones[i]的最大值。<br>dp的初始化？<br>默认为0。<br>遍历顺序？<br>石头的选择从头开始遍历到最后，背包的重量从最大开始遍历。</p>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h2><p>给你一个整数数组nums和一个整数target。向数组中的每个整数前添加’+’或’-‘，然后串联起所有整数，可以构造一个表达式：<br>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式”+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于target的不同表达式的数目。</p>
<img src="/2022/05/15/record04/dpExample02.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findTargetSumWays(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">int</span> sums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            sums += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> &gt; sums)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">target</span> + sums) % <span class="number">2</span> == <span class="number">1</span> || (<span class="keyword">target</span> + sums) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> targetBag = (sums + <span class="keyword">target</span>) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; dp(targetBag + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            for(<span class="built_in">int</span> j = targetBag;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[targetBag];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.确定dp数组(dp table)以及下标的含义<br>本题比较特殊，之前求的要么是背包的最大重量要么是背包里的物品的最大价值。但本题求的是不同表达式的组合数目，但思路还是能借鉴。比如之前的dp都是求最大物品重量，那么我们把这题分成两个背包，一个背包数字和为A，另一个背包数字和为B。A+B&#x3D;整数数组nums所有元素之和，A-B为target。所以我们只要讨论A和B其中一个背包，另一个背包也就直接出来。我们这里讨论A背包。dp[j]理解为当A背包里的数字和j时的不同组合方式最多为dp[j]种。<br>2.确认状态转移方程，即递推公式<br>模仿之前的题，我们的dp[j]的来源就为dp[j]本身与dp[j - nums[i]]的最大值，但这种方法是求最大“重量数”，而我们要求的是最大的“组合数”。打个比方：5的的组合方法有很多：1+4，2+3,3+2,4+1。当1为已知时，我们就得确认4的组合方法数量。当2为已知时，我们就得确认3的组合方法数量。当3为已知时，我们就得确认2的组合方法数量……所以5的最大组合方法数量为1+4，2+3,3+2,4+1的最大组合数之和，所以我们dp来源应该是某种数量的叠加。继续打比方：5的的组合方法有很多，但物品栏只有1和3，因此我们只需探求1和3时候的最大组合数量。即当1为已知时，我们就得确认4的组合方法数量。当3为已知时，我们就得确认2的组合方法数量，5的最大组合数量应为1+4,3+2的最大组合数之和。所以dp[j]的来源应为dp[j]+dp[j - nums[i]]。<br>3.dp数组如何初始化<br>因为dp[j]的来源应为dp[j]与dp[j - nums[i]]叠加，所以如果令dp[0]初始值为0，那后面的叠加全是0。然后根据我们对题目的分析，如果target为0的话也就是j&#x3D;0，那我们dp[0]初始值为1？说实话，在[代码随想录].pdf的解释为“装满容量为0的背包，有1种⽅法，就是装0件物品。”我觉得还是有点牵强，但我也不晓得如何解释(恼火)。<br>4.遍历顺序的确定<br>首先确定dp的末端数字，我们已经整数数组nums和一个整数target，我们可以根据一个背包数字和为A，另一个背包数字和为B。A+B&#x3D;整数数组nums所有元素之和，A-B为target得到(A的大小为nums所有元素之和+target)&#x2F;2，物品(nums元素)从头遍历，背包从end开始往前遍历。<br>5.推导整个dp数组</p>
<h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a>474. 一和零</h2><p>给你一个二进制字符串数组strs和两个整数m和n。请你找出并返回strs的最大子集的长度，该子集中最多有m个0和n个1。如果x的所有元素也是y的元素，集合x是集合y的子集。</p>
<img src="/2022/05/15/record04/dpExample03.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getZeroOnes</span><span class="params">(string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">zeroOnes</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            zeroOnes[str[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zeroOnes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>;l &lt; strs.<span class="built_in">size</span>();l++)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; zero0nes = <span class="built_in">getZeroOnes</span>(strs[l]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = m;i&gt;=zero0nes[<span class="number">0</span>];i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = n;j&gt;=zero0nes[<span class="number">1</span>];j--)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i - zero0nes[<span class="number">0</span>]][j - zero0nes[<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这题首先算出字符串数组strs里各个元素所含的0和1的个数，通过getZeroOnes函数，构建一个1x2向量，向量第0个位置代表0的数量，向量第1个位置代表1的数量。利用str[i]-‘0’的特性实现对元素含有1和0个数的计算。<br>1.确定dp数组(dp table)以及下标的含义<br>本题要求所选的元素的0和1个数和分别小于m和n，其实可以看做背包装一个物品，0的个数代表物品重量，1的个数代表物品价值。这个物品既要满足重量小于m，又要满足价值小于n。相比以往的题目即重量小于背包重量，价值取最大。多了一个限制条件。因此我们要在以往的题型基础上进行一个改进。以往对于只有一个条件即重量小于背包重量我们可以列dp[i][j]，又能dp[j]，我们一般采用后者，即dp[j]。现在多了一个条件即价值小于n，所以我们在这采用dp[i][j]。含义为0的个数最多为i，1的个数最多为j时，能在字符串数组sts中最多能挑选的元素个数为l。<br>2.确认状态转移方程，即递推公式<br>dp[i][j]的最大值要么来源于上次循环保留下来的dp[i][j]或者i&gt;&#x3D;zero0nes[0],j&gt;&#x3D;zero0nes[1]时，计算dp[i-zero0nes[0]][j - zero0nes[1]]的元素个数，再+1。即dp[i][j] &#x3D; max(dp[i][j],dp[i - zero0nes[0]][j - zero0nes[1]] + 1)。<br>3.dp数组如何初始化<br>再以往的题即“重量小于背包重量，价值取最大”中，一维数组dp默认为0.这题虽然有两个限制条件，但内核跟以往的题一模一样。所以同理，此题的初始化应全为0。<br>4.遍历顺序的确定<br>再以往的题即“重量小于背包重量，价值取最大”中，一维数组dp都是从后往前遍历，本题也如此，两个条件从后往前遍历。<br>5.推导整个dp数组</p>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有N件物品和⼀个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品都有⽆限个（也就是可以放⼊背包多次），求解将哪些物品装⼊背包⾥物品价值总和最⼤。<br>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_weibagPromble2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; weight = &#123; <span class="number">1</span> , <span class="number">3</span> , <span class="number">4</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; value = &#123; <span class="number">15</span> , <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">	<span class="type">int</span> bagweight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(bagweight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = bagweight; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">			<span class="type">int</span> we = j / weight[i];</span><br><span class="line">			dp1[j] = <span class="built_in">max</span>(dp1[j], dp1[j - weight[i]*we] + value[i] * we);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test_weibagPromble2</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">\\本人写的</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_weibagPromble2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; weight = &#123; <span class="number">1</span> , <span class="number">3</span> , <span class="number">4</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; value = &#123; <span class="number">15</span> , <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">	<span class="type">int</span> bagweight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(bagweight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagweight; j++) &#123; </span><br><span class="line">            dp1[j] = <span class="built_in">max</span>(dp1[j], dp1[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test_weibagPromble2</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">\\代码随想录上的</span><br></pre></td></tr></table></figure>
<p>此题为[代码随想录].pdf上的一道完全背包题目，所以运行环境不在LeetCode上而是在VS studio上。<br>1.确定dp数组(dp table)以及下标的含义<br>完全背包跟之前的背包不同，之前的背包有物品数量限制，但是完全背包是没有物品数量限制，也就是说可以同样的物品可以重复叠加。虽然有所区别，但原理还是一样。dp[j]意为背包重量为j时的最大价值。<br>2.确认状态转移方程，即递推公式<br>dp[j]来源于上一个循环的dp[j]与j&gt;&#x3D;weight[i]时 dp[j - weight[i]] + value[i]。<br>3.dp数组如何初始化<br>背包初始价值全部为0即可。<br>4.遍历顺序的确定<br>之前我们限制物品数量时都是从后往前遍历的。现在没有了物品数量限制，直接从前往后遍历，从前往后遍历能使同样的物品放在重量为j的背包中重复叠加。<br>5.推导整个dp数组</p>
<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518.零钱兑换 II"></a>518.零钱兑换 II</h2><p>给你一个整数数组coins表示不同面额的硬币，另给一个整数amount表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回0。假设每一种面额的硬币有无限个。 <br>题目数据保证结果符合32位带符号整数。</p>
<img src="/2022/05/15/record04/dpExample04.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = coins[i];j &lt;= amount;j++)&#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.确定dp数组(dp table)以及下标的含义<br>本题为完全背包+组合(组合不分排序)。amount看成背包重量，“硬币组合数”可以看成物品的组合数，所以拿之前的[完全背包]与[目标和]两题进行一个缝合。dp[j]为重量为j时，最大的排列数为dp[j]，<br>2.确认状态转移方程，即递推公式<br>dp[j] +&#x3D; dp[j - coins[i]];<br>3.dp数组如何初始化<br>dp[0]&#x3D;1<br>4.遍历顺序的确定<br>物品重量也就是组合数，从<br>5.推导整个dp数组</p>
<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h2><p>给你一个由不同整数组成的数组nums，和一个目标整数target。请你从nums中找出并返回总和为target的元素组合的个数。<br>题目数据保证答案符合 32 位整数范围。</p>
<img src="/2022/05/15/record04/dpExample05.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> combinationSum4(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; dp(<span class="keyword">target</span>+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= <span class="keyword">target</span>;i++)&#123;</span><br><span class="line">            for(<span class="built_in">int</span> j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt;= i &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]])&#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="keyword">target</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.确定dp数组(dp table)以及下标的含义<br>本题为完全背包+组合(组合分排序)。amount看成背包重量，“硬币组合数”可以看成物品的组合数，所以拿之前的[完全背包]与[目标和]两题进行一个缝合。dp[j]为重量为j时，最大的排列数为dp[j]，<br>2.确认状态转移方程，即递推公式<br>dp[j] +&#x3D; dp[j - coins[i]];<br>3.dp数组如何初始化<br>dp[0]&#x3D;1<br>4.遍历顺序的确定<br>如果求组合数就是外层for循环遍历物品，内层for遍历背包。<br>如果求排列数就是外层for遍历背包，内层for循环遍历物品。<br>5.推导整个dp数组</p>
<h2 id="70-爬楼梯-重制版"><a href="#70-爬楼梯-重制版" class="headerlink" title="70. 爬楼梯(重制版)"></a>70. 爬楼梯(重制版)</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<img src="/2022/05/15/record04/dpExample06.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">2</span>;j++)&#123;</span><br><span class="line">                dp[i] += dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>OK~动态规划就学这么多，预计学到单词拆分就继续回到刷LeetCode题目。如果遇到新的算法就跟着[代码随想录].pdf刷算法专题(周末去的新区图书馆，但新区uu的特别招待，下午KTV晚上出去干饭- -，所以周一连忙补上学习内容T_T)。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Third learning record in May</title>
    <url>/2022/05/30/record05/</url>
    <content><![CDATA[<p>分享五月第三周学习内容</p>
<span id="more"></span>
<h1 id="动态规划入门学习"><a href="#动态规划入门学习" class="headerlink" title="动态规划入门学习"></a>动态规划入门学习</h1><p>动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。<br>步骤：<br>1.确定dp数组(dp table)以及下标的含义<br>2.确认状态转移方程，即递推公式<br>3.dp数组如何初始化<br>4.遍历顺序的确定<br>5.推导整个dp数组</p>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p>给你一个整数数组coins，表示不同面额的硬币；以及一个整数amount，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1 。你可以认为每种硬币的数量是无限的。</p>
<img src="/2022/05/30/record05/dpExample01.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= amount;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; coins.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i &amp;&amp; dp[i - coins[j]] != INT_MAX) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i],dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体分析：<br>把不同面额的硬币视为物品，面额视为物品的重量，总金额amount视为背包重量。本题要求的是最少的银币个数，所以要求的不是“组合”个数，而是“物品个数”，因此并不是“组合”问题。而且每种硬币的数量是无限的，所以是“完全背包”问题。<br>1.确定dp数组(dp table)以及下标的含义<br>因为这里只有一个限制条件，即背包重量，所以dp肯定是一维。所以dp[i]的含义为：重量为i的背包能容纳最少的物品数量&lt;&#x3D;&gt;凑成总金额为i的最少银币个数。<br>2.确认状态转移方程，即递推公式<br>本题求的是最少的“物品个数”，所以dp[i] &#x3D; min(dp[i],dp[i - coins[j]] + 1)<br>3.dp数组如何初始化<br>首先dp[0] &#x3D; 0，因为面额为0个数也为0.但dp其他数字默认为0，那么在min(dp[i],dp[i - coins[j]] + 1)就一直为0，所以我们因把dp其他数字初始化为INT_MAX。<br>4.遍历顺序的确定<br>这题涉及的是完全背包的问题。完全背包的背包遍历顺序是从前往后遍历。物品由前往后遍历即可。<br>5.推导整个dp数组</p>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给你一个整数n，返回和为n的完全平方数的最少数量。完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和16都是完全平方数，而3和11不是。</p>
<img src="/2022/05/30/record05/dpExample02.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i*i&lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - i*i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j],dp[j-i*i] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体分析：<br>整数n视为背包最大重量为n，完全平方数为物品的重量，且不限制数量，因此为“完全背包”问题。<br>1.确定dp数组(dp table)以及下标的含义<br>因为这里只有一个限制条件，即背包重量，所以dp肯定是一维。所以dp[i]的含义为：重量为i的背包能容纳最少的物品数量&lt;&#x3D;&gt;整数i最少能划分完全平方数的个数。<br>2.确认状态转移方程，即递推公式<br>dp[j] &#x3D; min(dp[j],dp[j-i<em>i] + 1);<br>3.dp数组如何初始化<br>首先dp[0] &#x3D; 0，因为整数0最少能划分完全平方数的个数也为0.但dp其他数字默认为0，那么在min(dp[j],dp[j-i</em>i] + 1)就一直为0，所以我们因把dp其他数字初始化为INT_MAX。<br>4.遍历顺序的确定<br>这题涉及的是完全背包的问题。完全背包的背包遍历顺序是从前往后遍历。物品由前往后遍历即可。<br>5.推导整个dp数组</p>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><p>给你一个字符串s和一个字符串列表wordDict作为字典。请你判断是否可以利用字典中出现的单词拼接出s。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<img src="/2022/05/30/record05/dpExample03.jpg" class="" title="这是一张图片">
<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">bool</span> word<span class="constructor">Break(<span class="params">string</span> <span class="params">s</span>, <span class="params">vector</span>&lt;<span class="params">string</span>&gt;&amp; <span class="params">wordDict</span>)</span> &#123;</span><br><span class="line">        unordered_set&lt;<span class="built_in">string</span>&gt; word<span class="constructor">Set(<span class="params">wordDict</span>.<span class="params">begin</span>()</span>, wordDict.<span class="keyword">end</span><span class="literal">()</span>);</span><br><span class="line">        <span class="built_in">int</span> m = s.length<span class="literal">()</span>;</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; dp(m + <span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        dp<span class="literal">[<span class="number">0</span>]</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="built_in">string</span> word = s.substr( j , i - j );</span><br><span class="line">                <span class="keyword">if</span> (wordSet.find(word) != wordSet.<span class="keyword">end</span><span class="literal">()</span><span class="operator"> &amp;&amp; </span>dp<span class="literal">[<span class="identifier">j</span>]</span>) &#123;</span><br><span class="line">                    dp<span class="literal">[<span class="identifier">i</span>]</span> = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp<span class="literal">[<span class="identifier">m</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体分析：<br>字符串s为背包，字典里的字符串为物品。本题跟之前的题不同，以往的题要么求“最大重量”要么是“组合数量”，他们的“限制条件”我们直接无脑堆物品就完事了。但这题的“限制条件”不允许我们无脑堆物品，而是只允许“符合条件的物品”。“限制条件”比以前更严格，但思路依旧能用借鉴以前的题。假设整个字符串s为dp，背包从0开始，先搜索dp第一个字符，相当于dp里有两个指针，左指针j在0，右指针i在1，说明我们要确定从字典里的字符是否匹配得上指针j到i里的字符，指针里的字符数量逐渐递减，即左指针j右移。如果有匹配的字符，则右指针返回一个true。之和我们的左指针j在0，右指针i在2，判断字典里的字符是否匹配得上指针j到i里的字符，如果有匹配的字符，且左指针j是true即左指针j之前的字符串都能从字典里匹配到相应的字符串，则右指针返回一个true。<br>1.确定dp数组(dp table)以及下标的含义<br>dp类型为bool，dp[i]表示字符串前i个字符是否能匹配上。<br>2.确认状态转移方程，即递推公式<br>如果指针里的字符能匹配到字典里的字符且左指针为true，那么右指针为true。dp[i] &#x3D; true;<br>3.dp数组如何初始化<br>当字符串s啥也没有的时候，那一定为true。所以dp[0] &#x3D; true;其他都为false<br>4.遍历顺序的确定<br>因为字典里的字符串能重复使用，所以类似于“完全背包”问题，所以字典里的字符串从前往后遍历。<br>5.推导整个dp数组</p>
<h1 id="leetcode-热题HOT-100"><a href="#leetcode-热题HOT-100" class="headerlink" title="leetcode 热题HOT 100"></a>leetcode 热题HOT 100</h1><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配。<br>‘.’ 匹配任意单个字符<br>‘</em>‘ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<img src="/2022/05/30/record05/example01.jpg" class="" title="这是一张图片">

<p>先贴出答案，然后一步步讲解。</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">class <span class="symbol">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int m = s.length();</span><br><span class="line">        int n = p.length();</span><br><span class="line">        s.insert(s.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        p.insert(p.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(m + <span class="number">1</span>,vector&lt;bool&gt;(n + <span class="number">1</span>,false));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = true;</span><br><span class="line"></span><br><span class="line">        for(int j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            if(p[j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;else if(j + <span class="number">1</span> &gt; n || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            for(int j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                if(p[j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j + <span class="number">1</span> &lt;= n &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">                     || (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]))</span><br><span class="line">                     || (dp[i - <span class="number">1</span>][j] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]));</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这题运用到了动态规划的知识。首先对整体进行分析：<br>一个字符串 s 与一个字符规律 p 相匹配，我们首先在s和p字符最前面添加一个‘0’字符，为了之后能很好的描述此题。比如s第i个字符不再是s[i - 1]而是s[i]。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">bool</span> is<span class="constructor">Match(<span class="params">string</span> <span class="params">s</span>, <span class="params">string</span> <span class="params">p</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> m = s.length<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> n = p.length<span class="literal">()</span>;</span><br><span class="line">        s.insert(s.<span class="keyword">begin</span><span class="literal">()</span>,<span class="character">&#x27;0&#x27;</span>);</span><br><span class="line">        p.insert(p.<span class="keyword">begin</span><span class="literal">()</span>,<span class="character">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果s选取前i个字符能与p前j个字符相匹配，而且本题的函数类型为bool。于是我们可以令dp[i][j]为：s前i个字符能与p前j个字符相匹配。我们把框架写下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">length</span>();</span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">begin</span>(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来讨论状态方程。<br>先理解题意。“ ‘*’ 匹配零个或多个前面的那一个元素 ”说明 *跟前面一个字符是绑定在一起，比如a *,要么是0个a，要么是1个a，要么是好几个a。因为当我们讨论s前i个字符能与否p前j个字符相匹配时，还得看p的第j+1字符是否为’ * ‘。不考虑’.’。<br>当p的第j个字符为英文小写，先判断p的第j+1字符是否为’ * ‘。如果不是或者是超过字符串p的最长长度，说明p的第j个字符是独立的，不与第j+1字符绑定。我们想判断dp[i][j]是否为true，只需判断s的第i个字符与p的第j个字符相等以及之前的字符能匹配得上，这里就发生了“状态转移”。</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">if(j + <span class="number">1</span> &gt; n || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; ( s[i] == p[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当p的第j个字符为英文小写，且p的第j+1字符为’ * ‘。说明p的第j个字符与第j+1字符是绑定在一起的，于是我们把第j个字符与第j+1个字符看成一个整体A。所以这里分三种情况，这个整体A视为没有第j字符、一个第j字符和多个第j字符。<br>当s的第i个字符不等于p的第j个字符时，如要满足题意，这个整体A需视为没有第j字符。即</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">if(j + <span class="number">1</span> &lt;= n &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当s的第i个字符等于p的第j个字符时，且s的第i个字符与相邻的字符不重复，整体A视为一个第j字符，即</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(j + <span class="number">1</span> &lt;= n &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span></span>&#123;</span><br><span class="line">    dp<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = dp<span class="selector-attr">[i - 1]</span><span class="selector-attr">[j - 1]</span> &amp;&amp; (s<span class="selector-attr">[i]</span> == <span class="selector-tag">p</span><span class="selector-attr">[j]</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当s的第i个字符等于p的第j个字符时，且s的第i个字符与相邻的字符有重复，整体A视为多第j字符，即</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">if(j + <span class="number">1</span> &lt;= n &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; (s[i] == p[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当p的第j个字符为’ * ‘。因为’ * ‘都会跟前一个字符绑定，所以当前状态因与第j-1字符状态一样。即</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">if(p[j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑’.’的情况。只要出现’.’，就相当于“s[i] &#x3D;&#x3D; p[j]”。所以在之前的状态转移补充一个或条件即可。</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">class <span class="symbol">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int m = s.length();</span><br><span class="line">        int n = p.length();</span><br><span class="line">        s.insert(s.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        p.insert(p.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(m + <span class="number">1</span>,vector&lt;bool&gt;(n + <span class="number">1</span>,false));</span><br><span class="line"></span><br><span class="line">        for(int i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            for(int j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                if(p[j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j + <span class="number">1</span> &lt;= n &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">                     || (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]))</span><br><span class="line">                     || (dp[i - <span class="number">1</span>][j] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]));</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来讨论初始化问题。<br>首先当s的第0个字符与p的第0个字符毫无疑问是相同的。所以dp[0][0]&#x3D;true。另外得考虑一个极端情况，比如s字符串为空串，而p字符和a* b* c<em>，因为a</em>可以视为空串，所以这种情况也是符合的。所以</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">class <span class="symbol">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int m = s.length();</span><br><span class="line">        int n = p.length();</span><br><span class="line">        s.insert(s.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        p.insert(p.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(m + <span class="number">1</span>,vector&lt;bool&gt;(n + <span class="number">1</span>,false));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = true;</span><br><span class="line"></span><br><span class="line">        for(int j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            if(p[j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;else if(j + <span class="number">1</span> &gt; n || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            for(int j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                if(p[j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j + <span class="number">1</span> &lt;= n &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">                     || (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]))</span><br><span class="line">                     || (dp[i - <span class="number">1</span>][j] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]));</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="二叉树入门学习"><a href="#二叉树入门学习" class="headerlink" title="二叉树入门学习"></a>二叉树入门学习</h1><p>一棵树是一些节点(node)的集合。可以为空集，如果不是空集，则树由根节点以及0个或多个子树组成，根节点没有前驱结点。</p>
<img src="/2022/05/30/record05/bt01.jpg" class="" title="这是一张图片">
<p>图中根节点就是没有父结点的结点，叶子结点就是没有子节点的结点。</p>
<img src="/2022/05/30/record05/bt02.jpg" class="" title="这是一张图片">
<p>下面介绍一些与树相关的概念（以上面的树为例）：<br>（1）结点的度：一个节点含有的子树的个数称为该节点的度；如上图：A的为6，即B、C、D、E、F、G。<br>（2）叶结点：度为0的节点称为叶结点；如上图：B、C、H、I…等为叶结点。<br>（3）双亲结点或父结点：若一个节点含有子结点，则这个结点称为其子结点的父结点；如上图：A是B的父结点。<br>（4）孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；如上图：B是A的孩子节点。<br>（5）兄弟结点：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点。<br>（6）树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6。<br>（7）结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。<br>（8）树的高度或深度：树中结点的最大层次； 如上图：树的高度为4。<br>（9）节点的祖先：从根到某一结点所经分支上的所有结点；如上图：D、A是H的祖先；A是所有结点的公共祖先。<br>（10）子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙。<br>（11）森林：多棵互不相交的树的集合称为森林。</p>
<p>二叉树的储存方式为链式存储。</p>
<img src="/2022/05/30/record05/bt03.jpg" class="" title="这是一张图片">
<p>因此代码可编写为：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="constructor">TreeNode(<span class="params">int</span> <span class="params">x</span>)</span> : <span class="keyword">val</span>(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如我们想创建如下图这样的一棵树</p>
<img src="/2022/05/30/record05/bt04.jpg" class="" title="这是一张图片">
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span>&lt;stdio.h&gt;</span><br><span class="line">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span><br><span class="line"><span class="keyword">struct</span> treeNode &#123;       <span class="comment">//树的结点</span></span><br><span class="line">	<span class="built_in">char</span> data;           <span class="comment">//保存数据</span></span><br><span class="line">	treeNode *left;     <span class="comment">//左子树</span></span><br><span class="line">	treeNode *right;    <span class="comment">//右子树</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建树</span></span><br><span class="line"><span class="keyword">struct</span> treeNode* create<span class="constructor">Node(<span class="params">char</span> <span class="params">data</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* newNode = (<span class="keyword">struct</span> treeNode*)malloc(sizeof(<span class="keyword">struct</span> treeNode));</span><br><span class="line">	newNode-&gt;data = data;</span><br><span class="line">	newNode-&gt;left = NULL;</span><br><span class="line">	newNode-&gt;right = NULL;</span><br><span class="line">	return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.连接结点</span></span><br><span class="line">void insert<span class="constructor">Node(<span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">curNode</span>, <span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">leftNode</span>, <span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">rightNode</span>)</span> &#123;</span><br><span class="line">	curNode-&gt;left = leftNode;</span><br><span class="line">	curNode-&gt;right = rightNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.递归中序遍历</span></span><br><span class="line">void print<span class="constructor">Data(<span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">curNode</span>)</span> &#123;</span><br><span class="line">	printf(<span class="string">&quot;%c&quot;</span>, curNode-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">void mid<span class="constructor">Order(<span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">tree</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree != NULL) &#123;</span><br><span class="line">		mid<span class="constructor">Order(<span class="params">tree</span>-&gt;<span class="params">left</span>)</span>;	<span class="comment">//左</span></span><br><span class="line">		print<span class="constructor">Data(<span class="params">tree</span>)</span>;		<span class="comment">//根</span></span><br><span class="line">		mid<span class="constructor">Order(<span class="params">tree</span>-&gt;<span class="params">right</span>)</span>;	<span class="comment">//右</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.递归前序遍历</span></span><br><span class="line">void pre<span class="constructor">Order(<span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">tree</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree != NULL) &#123;</span><br><span class="line">		print<span class="constructor">Data(<span class="params">tree</span>)</span>;		<span class="comment">//根</span></span><br><span class="line">		pre<span class="constructor">Order(<span class="params">tree</span>-&gt;<span class="params">left</span>)</span>;	<span class="comment">//左</span></span><br><span class="line">		pre<span class="constructor">Order(<span class="params">tree</span>-&gt;<span class="params">right</span>)</span>;	<span class="comment">//右</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.递归后序遍历</span></span><br><span class="line">void last<span class="constructor">Order(<span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">tree</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree != NULL) &#123;</span><br><span class="line">		last<span class="constructor">Order(<span class="params">tree</span>-&gt;<span class="params">left</span>)</span>;	<span class="comment">//左</span></span><br><span class="line">		last<span class="constructor">Order(<span class="params">tree</span>-&gt;<span class="params">right</span>)</span>;	<span class="comment">//右</span></span><br><span class="line">		print<span class="constructor">Data(<span class="params">tree</span>)</span>;		<span class="comment">//根</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.非遍历的方式</span></span><br><span class="line">void mid<span class="constructor">OrderByStact(<span class="params">struct</span> <span class="params">treeNode</span><span class="operator">*</span> <span class="params">tree</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* stack<span class="literal">[<span class="number">10</span>]</span>;</span><br><span class="line">	<span class="built_in">int</span> stackTop = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* pMove = tree;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (stackTop != -<span class="number">1</span><span class="operator"> || </span>pMove != NULL) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pMove != NULL) &#123;</span><br><span class="line">			stack<span class="literal">[<span class="operator">++</span><span class="identifier">stackTop</span>]</span> = pMove;</span><br><span class="line">			pMove = pMove-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (stackTop != -<span class="number">1</span>) &#123;</span><br><span class="line">			pMove = stack<span class="literal">[<span class="identifier">stackTop</span>--]</span>;</span><br><span class="line">			printf(<span class="string">&quot;%c\t&quot;</span>, pMove-&gt;data);</span><br><span class="line">			pMove = pMove-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span> &#123;</span><br><span class="line">	<span class="comment">//1.创建所有的结点</span></span><br><span class="line">	<span class="keyword">struct</span> treeNode* A = create<span class="constructor">Node(&#x27;A&#x27;)</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* B = create<span class="constructor">Node(&#x27;B&#x27;)</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* C = create<span class="constructor">Node(&#x27;C&#x27;)</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* D = create<span class="constructor">Node(&#x27;D&#x27;)</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* E = create<span class="constructor">Node(&#x27;E&#x27;)</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* F = create<span class="constructor">Node(&#x27;F&#x27;)</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* G = create<span class="constructor">Node(&#x27;G&#x27;)</span>;</span><br><span class="line">	<span class="keyword">struct</span> treeNode* K = create<span class="constructor">Node(&#x27;K&#x27;)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//做连接操作</span></span><br><span class="line">	insert<span class="constructor">Node(A, B, C)</span>;</span><br><span class="line">	insert<span class="constructor">Node(B, D, E)</span>;</span><br><span class="line">	insert<span class="constructor">Node(C, F, G)</span>;</span><br><span class="line">	insert<span class="constructor">Node(F, NULL, K)</span>;</span><br><span class="line">	mid<span class="constructor">Order(A)</span>;</span><br><span class="line">	printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	last<span class="constructor">Order(A)</span>;</span><br><span class="line">	printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	pre<span class="constructor">Order(A)</span>;</span><br><span class="line">	printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	mid<span class="constructor">OrderByStact(A)</span>;</span><br><span class="line">	printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来对此树进行遍历。遍历顺序分为前序遍历、中序遍历和后序遍历。<br>前序遍历： 中 左 右<br>中序遍历： 左 中 右<br>后序遍历： 左 右 中<br>对于上题来说<br>前序遍历： ABDECFKG<br>中序遍历： DBEAFKCG<br>后序遍历： DEBKFGCA<br>3、4、5用了递归的思想。<br>6非遍历的方式用了栈的思路，即先进后出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">midOrderByStact</span><span class="params">(<span class="keyword">struct</span> treeNode* tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="comment">//先判断是否是空树</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* stack[<span class="number">10</span>]; <span class="comment">//初始化一个栈</span></span><br><span class="line">	<span class="type">int</span> stackTop = <span class="number">-1</span>; <span class="comment">//入栈一个元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* pMove = tree; <span class="comment">//定义一个指针，初始指向树的根节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (stackTop != <span class="number">-1</span> || pMove != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pMove != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			stack[++stackTop] = pMove;</span><br><span class="line">			pMove = pMove-&gt;left;</span><br><span class="line">		&#125; <span class="comment">//遍历到树的最左边</span></span><br><span class="line">		<span class="keyword">if</span> (stackTop != <span class="number">-1</span>) &#123;</span><br><span class="line">			pMove = stack[stackTop--];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, pMove-&gt;data); <span class="comment">//输出pMove指向的结点数据</span></span><br><span class="line">			pMove = pMove-&gt;right;   <span class="comment">//遍历右边</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的前序遍历。</p>
<img src="/2022/05/30/record05/btExample01.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        traversal(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec.push_back(node-&gt;val);</span><br><span class="line">        traversal(node-&gt;<span class="built_in">left</span>,vec);</span><br><span class="line">        traversal(node-&gt;<span class="built_in">right</span>,vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的后序遍历。</p>
<img src="/2022/05/30/record05/btExample02.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traversal(root,vec);</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">    void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traversal(node-&gt;<span class="built_in">left</span>,vec);</span><br><span class="line">        traversal(node-&gt;<span class="built_in">right</span>,vec);</span><br><span class="line">        vec.push_back(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的中序遍历。</p>
<img src="/2022/05/30/record05/btExample03.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traversal(root,vec);</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">    void traversal(TreeNode* root,vector&lt;int&gt;&amp; vec)&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traversal(root-&gt;<span class="built_in">left</span>,vec);</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        traversal(root-&gt;<span class="built_in">right</span>,vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>First learning record in June</title>
    <url>/2022/06/05/record06/</url>
    <content><![CDATA[<p>分享六月第一周学习内容</p>
<span id="more"></span>
<h1 id="二叉树入门学习"><a href="#二叉树入门学习" class="headerlink" title="二叉树入门学习"></a>二叉树入门学习</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的前序遍历。</p>
<img src="/2022/06/05/record06/btExample01.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(root);</span><br><span class="line">        while(!st.empty())&#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(node -&gt; val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;<span class="built_in">right</span>) st.push(node-&gt;<span class="built_in">right</span>);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;<span class="built_in">left</span>) st.push(node-&gt;<span class="built_in">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的后序遍历。</p>
<img src="/2022/06/05/record06/btExample02.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(root);</span><br><span class="line">        while(!st.empty())&#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(node -&gt; val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;<span class="built_in">left</span>) st.push(node-&gt;<span class="built_in">left</span>);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;<span class="built_in">right</span>) st.push(node-&gt;<span class="built_in">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(),result.<span class="keyword">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的中序遍历。</p>
<img src="/2022/06/05/record06/btExample03.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        while(cur != NULL |<span class="type">| !st</span>.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != NULL)&#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;<span class="built_in">left</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;<span class="built_in">right</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了方便理解，放c++环境中进行测试。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span> &#123;       <span class="comment">//树的结点</span></span><br><span class="line">	<span class="type">char</span> data;          <span class="comment">//保存数据</span></span><br><span class="line">	treeNode *left;     <span class="comment">//左子树</span></span><br><span class="line">	treeNode *right;    <span class="comment">//右子树</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span>* <span class="built_in">createNode</span>(<span class="type">char</span> data) &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* newNode = (<span class="keyword">struct</span> treeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> treeNode));</span><br><span class="line">	newNode-&gt;data = data;</span><br><span class="line">	newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">	newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">struct</span> treeNode* curNode, <span class="keyword">struct</span> treeNode* leftNode, <span class="keyword">struct</span> treeNode* rightNode)</span> </span>&#123;</span><br><span class="line">	curNode-&gt;left = leftNode;</span><br><span class="line">	curNode-&gt;right = rightNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">iNorderTraversal</span><span class="params">(treeNode* root)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">char</span>&gt; result;</span><br><span class="line">	stack&lt;treeNode*&gt; st;</span><br><span class="line">	treeNode* cur = root;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			st.<span class="built_in">push</span>(cur);</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cur = st.<span class="built_in">top</span>();</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">			result.<span class="built_in">push_back</span>(cur-&gt;data);</span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建所有的结点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* A = <span class="built_in">createNode</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* B = <span class="built_in">createNode</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* C = <span class="built_in">createNode</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* D = <span class="built_in">createNode</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* E = <span class="built_in">createNode</span>(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* F = <span class="built_in">createNode</span>(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* G = <span class="built_in">createNode</span>(<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">treeNode</span>* K = <span class="built_in">createNode</span>(<span class="string">&#x27;K&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//做连接操作</span></span><br><span class="line">	<span class="built_in">insertNode</span>(A, B, C);</span><br><span class="line">	<span class="built_in">insertNode</span>(B, D, E);</span><br><span class="line">	<span class="built_in">insertNode</span>(C, F, G);</span><br><span class="line">	<span class="built_in">insertNode</span>(F, <span class="literal">NULL</span>, K);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">char</span>&gt; result1 = <span class="built_in">iNorderTraversal</span>(A);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;result1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; result1[i] &lt;&lt; <span class="string">&quot;	&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过insertNode和createNode创建如图所示的树</p>
<img src="/2022/06/05/record06/iNorderTraversal01.jpg" class="" title="这是一张图片">
<p>直接从iNorderTraversal的while循环开始：<br>第一次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	st.<span class="built_in">push</span>(cur);</span><br><span class="line">	cur = cur-&gt;<span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal02.jpg" class="" title="这是一张图片">
<p>第二次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	st.<span class="built_in">push</span>(cur);</span><br><span class="line">	cur = cur-&gt;<span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal03.jpg" class="" title="这是一张图片">
<p>第三次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	st.<span class="built_in">push</span>(cur);</span><br><span class="line">	cur = cur-&gt;<span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal04.jpg" class="" title="这是一张图片">
<p>第四次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">		cur <span class="operator">=</span> st.top()<span class="comment">;</span></span><br><span class="line">		st.pop()<span class="comment">;</span></span><br><span class="line">		result.push_back(cur-&gt;data)<span class="comment">;</span></span><br><span class="line">		cur <span class="operator">=</span> cur-&gt;right<span class="comment">;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal05.jpg" class="" title="这是一张图片">
<p>第五次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">		cur <span class="operator">=</span> st.top()<span class="comment">;</span></span><br><span class="line">		st.pop()<span class="comment">;</span></span><br><span class="line">		result.push_back(cur-&gt;data)<span class="comment">;</span></span><br><span class="line">		cur <span class="operator">=</span> cur-&gt;right<span class="comment">;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal06.jpg" class="" title="这是一张图片">
<p>第六次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	st.<span class="built_in">push</span>(cur);</span><br><span class="line">	cur = cur-&gt;<span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal07.jpg" class="" title="这是一张图片">
<p>第七次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">		cur <span class="operator">=</span> st.top()<span class="comment">;</span></span><br><span class="line">		st.pop()<span class="comment">;</span></span><br><span class="line">		result.push_back(cur-&gt;data)<span class="comment">;</span></span><br><span class="line">		cur <span class="operator">=</span> cur-&gt;right<span class="comment">;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal08.jpg" class="" title="这是一张图片">
<p>第八次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">		cur <span class="operator">=</span> st.top()<span class="comment">;</span></span><br><span class="line">		st.pop()<span class="comment">;</span></span><br><span class="line">		result.push_back(cur-&gt;data)<span class="comment">;</span></span><br><span class="line">		cur <span class="operator">=</span> cur-&gt;right<span class="comment">;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/05/record06/iNorderTraversal09.jpg" class="" title="这是一张图片">
<p>…………<br>后面跟前面一样就不再赘述了~</p>
<h2 id="94-二叉树的中序遍历-统一迭代法"><a href="#94-二叉树的中序遍历-统一迭代法" class="headerlink" title="94. 二叉树的中序遍历(统一迭代法)"></a>94. 二叉树的中序遍历(统一迭代法)</h2><p>给你二叉树的根节点 root ，返回它节点值的中序遍历。</p>
<img src="/2022/06/05/record06/btExample03.jpg" class="" title="这是一张图片">
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector<span class="tag">&lt;int&gt;</span> inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack<span class="tag">&lt;TreeNode*&gt;</span> st;</span><br><span class="line">        vector<span class="tag">&lt;int&gt;</span> result;</span><br><span class="line">        if(root != NULL)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!st.empty())&#123;</span><br><span class="line">            TreeNode* <span class="keyword">node</span> <span class="title">= st</span>.top();</span><br><span class="line">            if(<span class="keyword">node</span> <span class="title">!= NULL</span>)&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                if(<span class="keyword">node</span> <span class="title">-&gt; right</span>)&#123;</span><br><span class="line">                    st.push(<span class="keyword">node</span> <span class="title">-&gt; right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                st</span>.push(NULL);</span><br><span class="line">                if(<span class="keyword">node</span> <span class="title">-&gt; left</span>)&#123;</span><br><span class="line">                    st.push(<span class="keyword">node</span> <span class="title">-&gt; left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= st</span>.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(<span class="keyword">node</span><span class="title">-&gt;val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="94-二叉树的前序遍历-统一迭代法"><a href="#94-二叉树的前序遍历-统一迭代法" class="headerlink" title="94. 二叉树的前序遍历(统一迭代法)"></a>94. 二叉树的前序遍历(统一迭代法)</h2><p>给你二叉树的根节点 root ，返回它节点值的前序遍历。</p>
<img src="/2022/06/05/record06/btExample01.jpg" class="" title="这是一张图片">
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector<span class="tag">&lt;int&gt;</span> preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack<span class="tag">&lt;TreeNode*&gt;</span> st;</span><br><span class="line">        vector<span class="tag">&lt;int&gt;</span> result;</span><br><span class="line">        if(root != NULL)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!st.empty())&#123;</span><br><span class="line">            TreeNode* <span class="keyword">node</span> <span class="title">= st</span>.top();</span><br><span class="line">            if(<span class="keyword">node</span> <span class="title">!= NULL</span>)&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                if(<span class="keyword">node</span><span class="title">-&gt;right</span>)&#123;</span><br><span class="line">                    st.push(<span class="keyword">node</span><span class="title">-&gt;right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                if(<span class="keyword">node</span><span class="title">-&gt;left</span>)&#123;</span><br><span class="line">                    st.push(<span class="keyword">node</span><span class="title">-&gt;left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                st</span>.push(NULL);   </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= st</span>.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(<span class="keyword">node</span><span class="title">-&gt;val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Second learning record in June</title>
    <url>/2022/06/19/record07/</url>
    <content><![CDATA[<p>分享六月第二周学习内容</p>
<span id="more"></span>
<h1 id="动态规划往期回顾"><a href="#动态规划往期回顾" class="headerlink" title="动态规划往期回顾"></a>动态规划往期回顾</h1><p>进行一个温故而知新！<br>常规题目如果只有一个条件限制，一般设dp为一维数组。如果有多个条件，那就设dp为多维数组。<br>限制条件分两种：①最多数量②最多组合<br>最多组合分两种：①不分顺序②分顺序<br>背包分为①01背包，即限制物品的数量②完全背包，即不限制物品的数量</p>
<h2 id="最多数量-01背包"><a href="#最多数量-01背包" class="headerlink" title="最多数量 + 01背包"></a>最多数量 + 01背包</h2><p>解决模板：先遍历物品，从小到大；再遍历背包重量，从大到小遍历。<br>常用的状态方程：dp[j] &#x3D; max(dp[j] , dp[j - value[i]] + weight[i]) </p>
<h2 id="最多数量-完全背包"><a href="#最多数量-完全背包" class="headerlink" title="最多数量 + 完全背包"></a>最多数量 + 完全背包</h2><p>解决模板：先遍历物品，从小到大；再遍历背包重量，从小到大遍历。<br>常用的状态方程：dp[j] &#x3D; max(dp[j] , dp[j - value[i]] + weight[i]) </p>
<h2 id="最多组合-不分顺序-01背包"><a href="#最多组合-不分顺序-01背包" class="headerlink" title="最多组合 + 不分顺序 + 01背包"></a>最多组合 + 不分顺序 + 01背包</h2><p>解决模板：先遍历物品，从小到大；再遍历背包重量，从大到小遍历。<br>常用的状态方程：dp[j] +&#x3D; dp[j - coins[i]] </p>
<h2 id="最多组合-不分顺序-完全背包"><a href="#最多组合-不分顺序-完全背包" class="headerlink" title="最多组合 + 不分顺序 + 完全背包"></a>最多组合 + 不分顺序 + 完全背包</h2><p>解决模板：先遍历物品，从小到大；再遍历背包重量，从小到大遍历。<br>常用的状态方程：dp[j] +&#x3D; dp[j - coins[i]]</p>
<h2 id="最多组合-分顺序-完全背包"><a href="#最多组合-分顺序-完全背包" class="headerlink" title="最多组合 + 分顺序 + 完全背包"></a>最多组合 + 分顺序 + 完全背包</h2><p>解决模板：先遍历背包重量，从小到大；再遍历物体，从小到大遍历。<br>常用的状态方程：dp[j] +&#x3D; dp[j - coins[i]]</p>
<h1 id="二叉树入门学习"><a href="#二叉树入门学习" class="headerlink" title="二叉树入门学习"></a>二叉树入门学习</h1><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p>给你二叉树的根节点 root ，返回其节点值的层序遍历 。（即逐层地，从左到右访问所有节点）。</p>
<img src="/2022/06/19/record07/btExample01.jpg" class="" title="这是一张图片">
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层序遍历-1"><a href="#102-二叉树的层序遍历-1" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p>给你二叉树的根节点root，返回其节点值自底向上的层序遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历)</p>
<img src="/2022/06/19/record07/btExample02.jpg" class="" title="这是一张图片">
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>给定一个二叉树的根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<img src="/2022/06/19/record07/btExample03.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root != NULL)&#123;</span><br><span class="line">            que.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(i == (size - <span class="number">1</span>))&#123;</span><br><span class="line">                    result.push_back(cur-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a>637. 二叉树的层平均值</h2><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p>
<img src="/2022/06/19/record07/btExample04.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="built_in">double</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root != NULL)&#123;</span><br><span class="line">            que.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">double</span> size = que.size();</span><br><span class="line">            <span class="built_in">double</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="built_in">sum</span> += cur-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(<span class="built_in">sum</span>/size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但我写成这样：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="built_in">double</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root != NULL)&#123;</span><br><span class="line">            que.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">double</span> size = que.size();</span><br><span class="line">            <span class="built_in">double</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="built_in">sum</span> = <span class="built_in">sum</span> + (cur-&gt;val)/size;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(<span class="built_in">sum</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就会报错！！</p>
<img src="/2022/06/19/record07/btExample05.jpg" class="" title="这是一张图片">

<h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a>429. N 叉树的层序遍历</h2><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。<br>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<img src="/2022/06/19/record07/btExample06.jpg" class="" title="这是一张图片">
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; node-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;children[i])&#123;</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a>515. 在每个树行中找最大值</h2><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p>
<img src="/2022/06/19/record07/btExample07.jpg" class="" title="这是一张图片">
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> for a binary tree node.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">TreeNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">TreeNode</span> *left;</span><br><span class="line"> *     <span class="type">TreeNode</span> *right;</span><br><span class="line"> *     <span class="type">TreeNode</span><span class="literal">()</span> : <span class="keyword">val</span>(<span class="number">0</span>), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">TreeNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">TreeNode</span>(<span class="built_in">int</span> x, <span class="type">TreeNode</span> *left, <span class="type">TreeNode</span> *right) : <span class="keyword">val</span>(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; largestValues(<span class="type">TreeNode</span>* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; result;</span><br><span class="line">        queue&lt;<span class="type">TreeNode</span>*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="type">NULL</span>)&#123;</span><br><span class="line">            que.push(root);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(!que.empty<span class="literal">()</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> size = que.size<span class="literal">()</span>;</span><br><span class="line">            <span class="built_in">int</span> m = <span class="type">INT_MIN</span>;</span><br><span class="line">            for(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span>* cur = que.front<span class="literal">()</span>;</span><br><span class="line">                que.pop<span class="literal">()</span>;</span><br><span class="line">                <span class="keyword">if</span>(m &lt; cur-&gt;<span class="keyword">val</span>)&#123;</span><br><span class="line">                    m = cur-&gt;<span class="keyword">val</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    que.push(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    que.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<img src="/2022/06/19/record07/btExample08.jpg" class="" title="这是一张图片">
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// <span class="type">Definition</span> for a <span class="type">Node</span>.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Node</span> &#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    int val;</span></span><br><span class="line"><span class="class">    <span class="type">Node</span>* left;</span></span><br><span class="line"><span class="class">    <span class="type">Node</span>* right;</span></span><br><span class="line"><span class="class">    <span class="type">Node</span>* next;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="type">Node</span>() : val(0), left(<span class="type">NULL</span>), right(<span class="type">NULL</span>), next(<span class="type">NULL</span>) &#123;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="type">Node</span>(<span class="title">int</span> <span class="title">_val</span>) : val(<span class="title">_val</span>), left(<span class="type">NULL</span>), right(<span class="type">NULL</span>), next(<span class="type">NULL</span>) &#123;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="type">Node</span>(<span class="title">int</span> <span class="title">_val</span>, <span class="type">Node</span>* <span class="title">_left</span>, <span class="type">Node</span>* <span class="title">_right</span>, <span class="type">Node</span>* <span class="title">_next</span>)</span></span><br><span class="line"><span class="class">        : val(<span class="title">_val</span>), left(<span class="title">_left</span>), right(<span class="title">_right</span>), next(<span class="title">_next</span>) &#123;&#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class">*/</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    <span class="type">Node</span>* connect(<span class="type">Node</span>* <span class="title">root</span>) &#123;</span></span><br><span class="line"><span class="class">        queue&lt;<span class="type">Node</span>*&gt; que;</span></span><br><span class="line"><span class="class">        if(<span class="title">root</span> != <span class="type">NULL</span>)&#123;</span></span><br><span class="line"><span class="class">            que.push(<span class="title">root</span>);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        while(!<span class="title">que</span>.<span class="title">empty</span>())&#123;</span></span><br><span class="line"><span class="class">            <span class="type">Node</span>* cur;</span></span><br><span class="line"><span class="class">            <span class="type">Node</span>* preCur;</span></span><br><span class="line"><span class="class">            int size = que.size();</span></span><br><span class="line"><span class="class">            for(<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">size</span>;<span class="title">i</span>++)&#123;</span></span><br><span class="line"><span class="class">                if(<span class="title">i</span> == 0)&#123;</span></span><br><span class="line"><span class="class">                    preCur = que.front();</span></span><br><span class="line"><span class="class">                    que.pop();</span></span><br><span class="line"><span class="class">                    cur = preCur;</span></span><br><span class="line"><span class="class">                &#125;else&#123;</span></span><br><span class="line"><span class="class">                    cur = que.front();</span></span><br><span class="line"><span class="class">                    que.pop();</span></span><br><span class="line"><span class="class">                    preCur-&gt;next = cur;</span></span><br><span class="line"><span class="class">                    preCur = preCur-&gt;next;</span></span><br><span class="line"><span class="class">                &#125;  </span></span><br><span class="line"><span class="class">                if(<span class="title">cur</span>-&gt;<span class="title">left</span>)&#123;</span></span><br><span class="line"><span class="class">                    que.push(<span class="title">cur</span>-&gt;<span class="title">left</span>);</span></span><br><span class="line"><span class="class">                &#125; </span></span><br><span class="line"><span class="class">                if(<span class="title">cur</span>-&gt;<span class="title">right</span>)&#123;</span></span><br><span class="line"><span class="class">                    que.push(<span class="title">cur</span>-&gt;<span class="title">right</span>);</span></span><br><span class="line"><span class="class">                &#125;      </span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            cur-&gt;next = <span class="type">NULL</span>; </span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        return root;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h2><p>给定一个 二叉树 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<img src="/2022/06/19/record07/btExample09.jpg" class="" title="这是一张图片">
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">public</span>:</span><br><span class="line">    int val;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">* left</span>;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">* right</span>;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">* next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Node</span><span class="title">() : val</span>(<span class="number">0</span>), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Node</span><span class="title">(int</span> _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Node</span><span class="title">(int</span> _val, <span class="keyword">Node</span><span class="title">* _left</span>, <span class="keyword">Node</span><span class="title">* _right</span>, <span class="keyword">Node</span><span class="title">* _next</span>)</span><br><span class="line">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">Node</span><span class="title">* connect</span>(<span class="keyword">Node</span><span class="title">* root</span>) &#123;</span><br><span class="line">        queue<span class="tag">&lt;Node*&gt;</span> que;</span><br><span class="line">        if(root != NULL)&#123;</span><br><span class="line">            que.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">Node</span><span class="title">* node</span>;</span><br><span class="line">            <span class="keyword">Node</span><span class="title">* nodePre</span>;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for(int i = <span class="number">0</span>;i <span class="tag">&lt; size;i++)&#123;</span></span><br><span class="line"><span class="tag">                if( i == 0 )&#123;</span></span><br><span class="line"><span class="tag">                    nodePre = que.front();</span></span><br><span class="line"><span class="tag">                    que.pop();</span></span><br><span class="line"><span class="tag">                    node = nodePre;</span></span><br><span class="line"><span class="tag">                &#125;else&#123;</span></span><br><span class="line"><span class="tag">                    node = que.front();</span></span><br><span class="line"><span class="tag">                    que.pop();</span></span><br><span class="line"><span class="tag">                    nodePre-&gt;</span>next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                    nodePre</span> = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                if(<span class="keyword">node</span><span class="title">-&gt;left</span>)&#123;</span><br><span class="line">                    que.push(<span class="keyword">node</span><span class="title">-&gt;left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                if(<span class="keyword">node</span><span class="title">-&gt;right</span>)&#123;</span><br><span class="line">                    que.push(<span class="keyword">node</span><span class="title">-&gt;right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<img src="/2022/06/19/record07/btExample10.jpg" class="" title="这是一张图片">
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        queue<span class="tag">&lt;TreeNode*&gt;</span> que;</span><br><span class="line">        if(root != NULL)&#123;</span><br><span class="line">            que.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            TreeNode* <span class="keyword">node</span> <span class="title">= que</span>.front();</span><br><span class="line">            TreeNode* cur = <span class="keyword">node</span><span class="title">-&gt;left</span>;</span><br><span class="line">            <span class="keyword">node</span><span class="title">-&gt;left</span> = <span class="keyword">node</span><span class="title">-&gt;right</span>;</span><br><span class="line">            <span class="keyword">node</span><span class="title">-&gt;right</span> = cur;</span><br><span class="line">            que.pop();</span><br><span class="line">            if(<span class="keyword">node</span><span class="title">-&gt;left</span>)&#123;</span><br><span class="line">                que.push(<span class="keyword">node</span><span class="title">-&gt;left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            if(<span class="keyword">node</span><span class="title">-&gt;right</span>)&#123;</span><br><span class="line">                que.push(<span class="keyword">node</span><span class="title">-&gt;right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给你一个二叉树的根节点 root ，检查它是否轴对称。</p>
<img src="/2022/06/19/record07/btExample11.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool <span class="built_in">compare</span>(TreeNode* <span class="built_in">left</span>,TreeNode* <span class="built_in">right</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">left</span> == NULL &amp;&amp; <span class="built_in">right</span> != NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">left</span> != NULL &amp;&amp; <span class="built_in">right</span> == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">left</span> == NULL &amp;&amp; <span class="built_in">right</span> == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="built_in">left</span>-&gt;val != <span class="built_in">right</span>-&gt;val))&#123;</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line">        bool compareOutside = <span class="built_in">compare</span>(<span class="built_in">left</span>-&gt;<span class="built_in">left</span>,<span class="built_in">right</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">        bool compareInside = <span class="built_in">compare</span>(<span class="built_in">left</span>-&gt;<span class="built_in">right</span>,<span class="built_in">right</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        bool compareLast = compareOutside &amp;&amp; compareInside;</span><br><span class="line">        <span class="keyword">return</span> compareLast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;<span class="built_in">left</span>,root-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        que.push(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            TreeNode* leftNode = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            TreeNode* rightNode = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( !leftNode &amp;&amp; !rightNode )&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( !leftNode |<span class="type">| !rightNode</span> |<span class="type">| (leftNode</span>-&gt;val != rightNode-&gt;val))&#123;</span><br><span class="line">                <span class="keyword">return</span> false;</span><br><span class="line">            &#125;</span><br><span class="line">            que.push(leftNode-&gt;<span class="built_in">left</span>);</span><br><span class="line">            que.push(rightNode-&gt;<span class="built_in">right</span>);</span><br><span class="line">            que.push(leftNode-&gt;<span class="built_in">right</span>);</span><br><span class="line">            que.push(rightNode-&gt;<span class="built_in">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>二叉树</tag>
        <tag>往期回顾</tag>
      </tags>
  </entry>
  <entry>
    <title>Third learning record in June</title>
    <url>/2022/06/27/record08/</url>
    <content><![CDATA[<p>分享六月第三周学习内容</p>
<span id="more"></span>
<h1 id="二叉树入门学习"><a href="#二叉树入门学习" class="headerlink" title="二叉树入门学习"></a>二叉树入门学习</h1><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p>
<img src="/2022/06/27/record08/btExample01.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(root);</span><br><span class="line">        int num = <span class="number">0</span>;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a>559. N 叉树的最大深度</h2><p>给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>
<img src="/2022/06/27/record08/btExample02.jpg" class="" title="这是一张图片">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxDepth(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="keyword">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">size</span> = que.<span class="keyword">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">size</span>;i++)&#123;</span><br><span class="line">                Node* node = que.front();</span><br><span class="line">                que.<span class="keyword">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; node-&gt;children.<span class="keyword">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;children[i])&#123;</span><br><span class="line">                        que.<span class="keyword">push</span>(node-&gt;children[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p>
<img src="/2022/06/27/record08/btExample03.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(root);</span><br><span class="line">        int num = <span class="number">0</span>;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(!cur-&gt;<span class="built_in">left</span> &amp;&amp; !cur-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h2><p>给你一棵完全二叉树的根节点 root ，求出该树的节点个数</p>
<img src="/2022/06/27/record08/btExample04.jpg" class="" title="这是一张图片">
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode() : val(<span class="number">0</span>), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>) : val(x), <span class="built_in">left</span>(<span class="built_in">left</span>), <span class="built_in">right</span>(<span class="built_in">right</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root == NULL)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(root);</span><br><span class="line">        int num = <span class="number">0</span>;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">                    que.push(cur-&gt;<span class="built_in">right</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<img src="/2022/06/27/record08/btExample05.jpg" class="" title="这是一张图片">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> getDepth(TreeNode* curNode)&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(curNode == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="keyword">push</span>(curNode);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">size</span> = que.<span class="keyword">size</span>();</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">size</span>;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.<span class="keyword">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    que.<span class="keyword">push</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    que.<span class="keyword">push</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="keyword">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.<span class="keyword">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">abs</span>(getDepth(node-&gt;left) - getDepth(node-&gt;right)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                st.<span class="keyword">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                st.<span class="keyword">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：<br>二叉树的高度：从下往上数<br>二叉树的深度：从上往下数</p>
<h1 id="回溯入门学习"><a href="#回溯入门学习" class="headerlink" title="回溯入门学习"></a>回溯入门学习</h1><h2 id="110-平衡二叉树-1"><a href="#110-平衡二叉树-1" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按任何顺序返回答案。</p>
<img src="/2022/06/27/record08/backExample01.jpg" class="" title="这是一张图片">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= n;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(n,k,i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h2><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：<br>只使用数字1到9<br>每个数字 最多使用一次 <br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回</p>
<img src="/2022/06/27/record08/backExample02.jpg" class="" title="这是一张图片">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> newSum,<span class="type">int</span> startIndex,<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newSum == n)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            newSum += i;</span><br><span class="line">            <span class="built_in">backtracking</span>(newSum,i + <span class="number">1</span>,n,k);</span><br><span class="line">            newSum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">0</span>,<span class="number">1</span>,n,k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>每周学习</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Third Study Record of internship</title>
    <url>/2022/11/30/internship03/</url>
    <content><![CDATA[<p>2022-11-30 ~ 2022-12-31</p>
<span id="more"></span>
<h1 id="嵌入式学习"><a href="#嵌入式学习" class="headerlink" title="嵌入式学习"></a>嵌入式学习</h1><h2 id="配置VS-code远程控制linux"><a href="#配置VS-code远程控制linux" class="headerlink" title="配置VS code远程控制linux"></a>配置VS code远程控制linux</h2><p>参考网址：<br><a href="https://blog.csdn.net/thisway_diy/article/details/127556249">https://blog.csdn.net/thisway_diy/article/details/127556249</a></p>
<h3 id="Windows上的操作"><a href="#Windows上的操作" class="headerlink" title="Windows上的操作"></a>Windows上的操作</h3><p>使用浏览器从从<a href="https://code.visualstudio.com/%E4%B8%8B%E8%BD%BDvscode%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%8C%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E3%80%82%E6%88%91%E4%BB%AC%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E5%9C%A8Windows%E4%B8%8A%E8%BF%90%E8%A1%8Cvscode%EF%BC%8C%E4%BD%BF%E7%94%A8vscode%E9%98%85%E8%AF%BBLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E3%80%82%E8%BF%99%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%E5%BE%88%E5%A4%9A%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%8F%92%E4%BB%B6%E6%98%AF%E5%AE%89%E8%A3%85%E5%9C%A8windows%E4%B8%8A%E8%BF%98%E6%98%AFLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%EF%BC%9F">https://code.visualstudio.com/下载vscode安装包，双击安装。我们的目的是在Windows上运行vscode，使用vscode阅读Linux服务器上的内核源码。这需要安装很多插件，这些插件是安装在windows上还是Linux服务器上？</a><br>vscode的插件有两种类型：<br>全局插件：只需要安装在Windows上，打开远程服务器的代码后也可以使用这些插件<br>远程插件：即使在Windows上使用vscode，这类插件也必须安装在远程服务器上<br>但是我们并不知道插件属于全局插件还是远程插件，怎么办呢？<br>先在Windows安装所需的全部插件。以后打开远程服务器文件夹时，再查看已经安装的插件，它会有相应的提示。<br>依次输入下列插件名字，安装：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">C</span><span class="operator">/</span><span class="built_in">C</span><span class="operator">++</span></span><br><span class="line"><span class="built_in">C</span><span class="operator">/</span><span class="built_in">C</span><span class="operator">++</span> <span class="built_in">Extension</span> <span class="variable">Pack</span></span><br><span class="line"><span class="built_in">C</span><span class="operator">/</span><span class="built_in">C</span><span class="operator">++</span> <span class="variable">Snippets</span></span><br><span class="line"><span class="variable">Clangd</span></span><br><span class="line"><span class="variable">Remote</span> <span class="variable">SSH</span></span><br><span class="line"><span class="variable">Code</span> <span class="variable">Runner</span></span><br><span class="line"><span class="variable">Code</span> <span class="variable">Spell</span> <span class="variable">Checker</span></span><br><span class="line"><span class="variable">vscode</span><span class="operator">-</span><span class="variable">icons</span></span><br><span class="line"><span class="variable">compareit</span></span><br><span class="line"><span class="variable">DeviceTree</span></span><br><span class="line"><span class="variable">Tabnine</span> <span class="variable">AI</span> <span class="built_in">Autocomplete</span></span><br><span class="line"><span class="variable">Bracket</span> <span class="variable">Pair</span> <span class="variable">Colorization</span> <span class="built_in">Toggler</span></span><br><span class="line"><span class="variable">Rainbow</span> <span class="variable">Highlighter</span></span><br><span class="line">高亮文字：<span class="variable">shift</span> <span class="operator">+</span> <span class="variable">alt</span> <span class="operator">+</span> <span class="variable">z</span></span><br><span class="line">取消高亮：<span class="variable">shift</span> <span class="operator">+</span> <span class="variable">alt</span> <span class="operator">+</span> <span class="variable">a</span></span><br><span class="line"><span class="variable">Arm</span> <span class="variable">Assembly</span></span><br><span class="line"><span class="variable">Chinese</span></span><br><span class="line"><span class="variable">Hex</span> <span class="variable">Editor</span></span><br><span class="line"><span class="variable">One</span> <span class="variable">Dark</span> <span class="variable">Pro</span></span><br><span class="line"><span class="variable">Markdown</span> <span class="built_in">All</span> <span class="variable">in</span> <span class="variable">One</span></span><br><span class="line"><span class="variable">Markdown</span> <span class="variable">Preview</span> <span class="variable">Enhanced</span></span><br></pre></td></tr></table></figure>
<p>我们安装插件后，设置SSH。vscode自带的ssh程序有Bug，我们需要替换ssh。可以使用GIT工具自带的ssh，所以先安装Git</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">下载：https:<span class="regexp">//gi</span>tforwindows.org/</span><br><span class="line">安装：双击即可</span><br></pre></td></tr></table></figure>
<p>然后替换ssh，修改环境变量，替换Path中ssh的路径即可。先打开”编辑系统环境变量”：</p>
<img src="/2022/11/30/internship03/vscode01.jpg" class="" title="这是一张图片">
<p>然后替换ssh，确保GIT工具的路径下有ssh.exe后，如下替换：</p>
<img src="/2022/11/30/internship03/vscode02.jpg" class="" title="这是一张图片">
<h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><p>安装好插件后，即可远程登录服务器，如下操作：</p>
<img src="/2022/11/30/internship03/vscode03.jpg" class="" title="这是一张图片">
<img src="/2022/11/30/internship03/vscode04.jpg" class="" title="这是一张图片">
<img src="/2022/11/30/internship03/vscode05.jpg" class="" title="这是一张图片">
<p>免密登录不是必须的，后续使用vscode访问远程服务器时，你可以一直使用密码登录。如果想免密登录的话，需要生成ssh秘钥。<br>先在windows的命令行执行：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh-keygen</span></span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/vscode06.jpg" class="" title="这是一张图片">
<img src="/2022/11/30/internship03/vscode07.jpg" class="" title="这是一张图片">
<p>最后把前面生成的id_rsa.pub复制到Ubuntu目录&#x2F;home&#x2F;book</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir <span class="regexp">/home/</span>book/.ssh</span><br><span class="line">cat <span class="regexp">/home/</span>book<span class="regexp">/id_rsa.pub &gt;&gt; /</span>home<span class="regexp">/book/</span>.ssh/authorized_keys</span><br><span class="line">chmod <span class="number">700</span> <span class="regexp">/home/</span>book/.ssh</span><br><span class="line">chmod <span class="number">600</span> <span class="regexp">/home/</span>book<span class="regexp">/.ssh/</span>authorized_keys</span><br><span class="line">sudo <span class="regexp">/usr/</span>sbin/sshd restart</span><br></pre></td></tr></table></figure>
<p>然后在服务器上安装插件，vscode连接上服务器后，查看本地插件，发现有如下字样的插件就点击”Install in SSH”：</p>
<img src="/2022/11/30/internship03/vscode08.jpg" class="" title="这是一张图片">
<p>安装完后，可以如下图查看，确保远程服务器上已经有了clangd插件：</p>
<img src="/2022/11/30/internship03/vscode09.jpg" class="" title="这是一张图片">
<p>前面只是安装clangd插件，它的使用还需要一个运行在Linux服务器上的clangd程序。我们以后使用vscode打开C文件时，会提示你安装clangd程序，它会安装最新版本(版本15)，但是这个版本有一些Bug，所以我们手工安装版本13。在Ubuntu中使用浏览器打开<a href="https://github.com/clangd/clangd/releases/tag/13.0.0%EF%BC%8C%E4%B8%8B%E8%BD%BDLinux%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%9A">https://github.com/clangd/clangd/releases/tag/13.0.0，下载Linux安装包：</a></p>
<img src="/2022/11/30/internship03/vscode10.jpg" class="" title="这是一张图片">
<p>把下载到的clangd-linux-13.0.0.zip放到&#x2F;home&#x2F;book目录下，执行解压命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /home/book</span><br><span class="line"><span class="attribute">unzip</span> clangd-linux-<span class="number">13</span>.<span class="number">0</span>.<span class="number">0</span>.zip</span><br></pre></td></tr></table></figure>
<p>在Windows的vscode界面按下图步骤打开setting.json文件:</p>
<img src="/2022/11/30/internship03/vscode11.jpg" class="" title="这是一张图片">
<p>在setting.json中写入如下内容(我们第1次打开源码目录后，这个文件可能被自动修改，你需要再次修改它)：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;C_Cpp.default.intelliSenseMode&quot;</span>: <span class="string">&quot;linux-gcc-arm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;C_Cpp.intelliSenseEngine&quot;</span>: <span class="string">&quot;Disabled&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clangd.path&quot;</span>: <span class="string">&quot;/home/book/clangd_13.0.0/bin/clangd&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clangd.arguments&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;--log=verbose&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C&#x2F;C++插件里的intellisense和clangd是冲突的，如果我们没有手工设置setting.json，当使用vscode打开C文件时也会提示禁止intellisense，点击鼠标即可禁止。它的本质也是修改setting.json，它会写入如下文字：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;C_Cpp.intelliSenseEngine&quot;</span><span class="punctuation">:</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>上面代码有Bug，其中的”disabled”应该改为”Disabled”。</p>
<h1 id="C与C-学习"><a href="#C与C-学习" class="headerlink" title="C与C++学习"></a>C与C++学习</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>指针是一个数据类型，类似于int char等数据类型，但不同的是多了一个 * 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Address of p:%d\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Address of *p:%d\n&quot;</span>,*p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/Cpoint01.jpg" class="" title="这是一张图片">
<p>分析整个代码。首先int a在内存中给a开辟了4个字节大小的空间，并把4个字节的首字节地址赋予给了a，存放的内容为32位0的二进制。然后我们声明了一个指针变量p，指针变量p存放地址，所以我们令p等于a的地址，直接打印p的结果为6422036。但指针特殊就特殊在它有个<em>，如果在p前面加上</em>，就相当于“解引用”，意思是 * 能把p存放的地址进行解析，得到地址里存放的数据，所以 *p 打印的结果为地址6422036存放的值，也就是a的值为0。</p>
<h3 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h3><p>数组指针：指向数组的指针，本质是指针。<br>指针数组：数组内存放了指针，本质是数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> *p = a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of p:%d\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of *p:%d\n&quot;</span>,*p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/Cpoint02.jpg" class="" title="这是一张图片">
<p>我们可以看到，数组名字a，其实也代表着这个数组的首地址，即a等于a[ 0 ]的地址,即a&#x3D;&amp;a[ 0 ]。所以指针p指向地址的时候，a是不用加取址符号 &amp; 。换句话来说，a的类型其实是int *类型的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">int</span> (*p)[<span class="number">5</span>] = &amp;a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of p:%d\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of *p:%d\n&quot;</span>,*p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of **p:%d\n&quot;</span>,**p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/Cpoint03.jpg" class="" title="这是一张图片">
<p>如何判断int ( * p)[ 5 ]是一个数组指针还是指针数组。只要看名字p是跟哪个结合。如果( * p)没括号，那么p会优先跟身后的[ 5 ]结合，那么本质是数组，所以int  * p[ 5 ]是指针数组，int ( * p)[ 5 ]是数组指针。打印的时候，无论是p还是 * p都只能得到数组a的地址6422016，因为a本身是一个int * 类型的指针。<br>p打印的值6422016指的是数组a的地址，换句话说是int * 类型的a指针的地址。<br>*p打印的值6422016指的是p的值解引用后得到内容，换句话说是int * 类型的a指针，即 * p打印的值数组名a，也就是a的首元素地址，即&amp;a[ 0 ].<br>为什么int ( * p)[ 5 ] &#x3D; &amp; a不能写成int ( * p)[ 5 ] &#x3D; a????<br>因为 &#x3D; 两边的类型需要相同, &amp; a是数组a的地址,a是数组a首元素的地址.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">int</span> (*p)[<span class="number">5</span>] = &amp;a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Value of p:%d\n&quot;</span>,(*p + i));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Value of *p:%d\n&quot;</span>,*(*p + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/Cpoint04.jpg" class="" title="这是一张图片">
<p>以上提供了一种通过指针打印数组内容的方法.</p>
<h1 id="leetCode刷题"><a href="#leetCode刷题" class="headerlink" title="leetCode刷题"></a>leetCode刷题</h1><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<img src="/2022/11/30/internship03/leetCode1_01.jpg" class="" title="这是一张图片">
<p>自己编写的代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; restart<span class="constructor">Nums(<span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">nums</span> , <span class="params">int</span> <span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = i;(j + <span class="number">1</span>) &lt; nums.size<span class="literal">()</span>;j++)&#123;</span><br><span class="line">            nums<span class="literal">[<span class="identifier">j</span>]</span> = nums<span class="literal">[<span class="identifier">j</span> + <span class="number">1</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> remove<span class="constructor">Element(<span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">nums</span>, <span class="params">int</span> <span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> numsLength = nums.size<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; numsLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">val</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span>]</span>)&#123;</span><br><span class="line">                numsLength--;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="operator"> == </span>numsLength)&#123;</span><br><span class="line">                    return numsLength;</span><br><span class="line">                &#125;</span><br><span class="line">                nums = restart<span class="constructor">Nums(<span class="params">nums</span>,<span class="params">i</span>)</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numsLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看代码随想录介绍的快慢指针思路后优化的代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> remove<span class="constructor">Element(<span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">nums</span>, <span class="params">int</span> <span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> pSlow = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pFast = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> numsLength = nums.size<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; numsLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">val</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">pFast</span>]</span>)&#123;</span><br><span class="line">                pFast++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums<span class="literal">[<span class="identifier">pSlow</span>]</span> = nums<span class="literal">[<span class="identifier">pFast</span>]</span>;</span><br><span class="line">                pSlow++;</span><br><span class="line">                pFast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pSlow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<img src="/2022/11/30/internship03/leetCode_02.jpg" class="" title="这是一张图片">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> numsLength = nums.<span class="built_in">size</span> ();</span><br><span class="line">        <span class="type">int</span> pRight = numsLength - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(numsLength)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = numsLength - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[pLeft]) &gt; <span class="built_in">abs</span>(nums[pRight]))&#123;</span><br><span class="line">                ret[i] = nums[pLeft]*nums[pLeft];</span><br><span class="line">                pLeft++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ret[i] = nums[pRight]*nums[pRight];</span><br><span class="line">                pRight--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<img src="/2022/11/30/internship03/leetCode_03.jpg" class="" title="这是一张图片">
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minSubArrayLen(<span class="built_in">int</span> <span class="keyword">target</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> pLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pRight = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pLength = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> pSize = INT_MAX;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sum</span> &gt; <span class="keyword">target</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((pRight + <span class="number">1</span>) &lt; nums.<span class="built_in">size</span>() || <span class="built_in">sum</span> &gt;= <span class="keyword">target</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sum</span> &lt; <span class="keyword">target</span> &amp;&amp; pRight &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>))&#123;</span><br><span class="line">                pRight++;</span><br><span class="line">                <span class="built_in">sum</span> += nums[pRight];</span><br><span class="line">                pLength++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sum</span> &gt;= <span class="keyword">target</span>)&#123;</span><br><span class="line">                <span class="built_in">sum</span> -= nums[pLeft];</span><br><span class="line">                pLeft++;</span><br><span class="line">                pSize = <span class="built_in">min</span>(pSize,pLength);</span><br><span class="line">                pLength--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pSize == INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看了代码随想录后优化的代码</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minSubArrayLen(<span class="built_in">int</span> <span class="keyword">target</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> pLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pSize = INT_MAX;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">        for(<span class="built_in">int</span> pRight = <span class="number">0</span>;pRight &lt; nums.<span class="built_in">size</span>();pRight++)&#123;</span><br><span class="line">            <span class="built_in">sum</span> += nums[pRight];</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">sum</span> &gt;= <span class="keyword">target</span>)&#123;</span><br><span class="line">                pLength = pRight - pLeft + <span class="number">1</span>;</span><br><span class="line">                pSize = <span class="built_in">min</span>(pSize,pLength);</span><br><span class="line">                <span class="built_in">sum</span> -= nums[pLeft];</span><br><span class="line">                pLeft++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pSize == INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<img src="/2022/11/30/internship03/leetcode59.jpg" class="" title="这是一张图片">
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">ret</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> xStart = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> yStart = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = yStart;j &lt; n - <span class="number">1</span> - yStart;j++)&#123;</span><br><span class="line">                ret[xStart][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = xStart;i &lt; n <span class="number">-1</span> - xStart;i++)&#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j &gt; yStart;j--)&#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i &gt; xStart;i--)&#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            xStart++;</span><br><span class="line">            yStart++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ret[(n / <span class="number">2</span>)][(n / <span class="number">2</span>)] = count;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p>
<img src="/2022/11/30/internship03/leetcode203.jpg" class="" title="这是一张图片">
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> *next;</span><br><span class="line"> *     <span class="type">ListNode</span><span class="literal">()</span> : <span class="keyword">val</span>(<span class="number">0</span>), next(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x, <span class="type">ListNode</span> *next) : <span class="keyword">val</span>(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">ListNode</span>* removeElements(<span class="type">ListNode</span>* head, <span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span>* <span class="type">VirtualNode</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">VirtualNode</span>-&gt;next = head;</span><br><span class="line">        <span class="type">ListNode</span>* cur = <span class="type">VirtualNode</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="type">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;<span class="keyword">val</span> == <span class="keyword">val</span>)&#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="type">VirtualNode</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。<br>在链表类中实现这些功能：<br>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<img src="/2022/11/30/internship03/leetCode707.jpg" class="" title="这是一张图片">

<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    struct ListNode&#123;</span><br><span class="line">        <span class="built_in">int</span> val;</span><br><span class="line">        ListNode* <span class="keyword">next</span>;</span><br><span class="line">        ListNode(<span class="built_in">int</span> val):val(val),<span class="keyword">next</span>(nullptr)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">sum</span>;</span><br><span class="line">    ListNode* VirtualNode;</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        VirtualNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">int</span> get(<span class="built_in">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = VirtualNode;</span><br><span class="line">        <span class="keyword">index</span>++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">index</span>--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!tmp)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> addAtHead(<span class="built_in">int</span> val) &#123;</span><br><span class="line">        ListNode* headNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        headNode-&gt;<span class="keyword">next</span> = VirtualNode-&gt;<span class="keyword">next</span>;</span><br><span class="line">        VirtualNode-&gt;<span class="keyword">next</span> = headNode;</span><br><span class="line">        <span class="keyword">sum</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> addAtTail(<span class="built_in">int</span> val) &#123;</span><br><span class="line">        ListNode* tmp = VirtualNode;</span><br><span class="line">        ListNode* lastNoode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;<span class="keyword">next</span>)&#123;</span><br><span class="line">            tmp = tmp-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;<span class="keyword">next</span> = lastNoode;</span><br><span class="line">        <span class="keyword">sum</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> addAtIndex(<span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span> &gt; <span class="keyword">sum</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">index</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = VirtualNode;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">index</span>--)&#123;</span><br><span class="line">            tmp = tmp-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;<span class="keyword">next</span> = tmp-&gt;<span class="keyword">next</span>;</span><br><span class="line">        tmp-&gt;<span class="keyword">next</span> = newNode;</span><br><span class="line">        <span class="keyword">sum</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> deleteAtIndex(<span class="built_in">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span> &lt; <span class="number">0</span> || <span class="keyword">index</span> &gt;= <span class="keyword">sum</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = VirtualNode;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">index</span>--)&#123;</span><br><span class="line">            tmp = tmp-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;<span class="keyword">next</span> = tmp-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">sum</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="研二公司实习"><a href="#研二公司实习" class="headerlink" title="研二公司实习"></a>研二公司实习</h1><h2 id="基于海龟的ros基础学习（微信公众号文章撰写）"><a href="#基于海龟的ros基础学习（微信公众号文章撰写）" class="headerlink" title="基于海龟的ros基础学习（微信公众号文章撰写）"></a>基于海龟的ros基础学习（微信公众号文章撰写）</h2><p>ROS是机器人操作系统（Robot Operating System）的英文缩写，是用于编写机器人软件程序的一种具有高度灵活性的软件架构。它具备通讯机制，开发工具，应用功能，生态系统四大功能。首先我们需要知道的一件事情是，在ROS中，所有的节点都需要通过ROS Master进行管理，节点其实就是进程，只不过在ROS 1中给它起了个名字叫节点。</p>
<h3 id="启动小海龟"><a href="#启动小海龟" class="headerlink" title="启动小海龟"></a>启动小海龟</h3><p>打开一个终端，键入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">roscore</span></span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/wechat01.jpg" class="" title="这是一张图片">
<p>如果没有报错的话，master已经启动起来了。需要注意的是，这个终端窗口不能关闭，关闭这个终端就等于终止了master。再打开一个终端，键入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosrun turtlesim turtlesim_node</span></span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/wechat02.jpg" class="" title="这是一张图片">
<p>如果没有出现意外的话，此时界面上应该出现了一只小海龟，这就是ROS的吉祥物。需要注意，每次启动小海龟，小海龟的样子都不一样，这是正常现象。再开一个终端，键入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosnode list</span></span><br></pre></td></tr></table></figure>
<p>会出现</p>
<img src="/2022/11/30/internship03/wechat03.jpg" class="" title="这是一张图片">
<p>第二个&#x2F;turtlesim，这就是小海龟这个进程的节点名称。ROS提供了命名重映射功能，关闭之前的小海龟，重新键入</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node __<span class="built_in">na</span><span class="symbol">me:</span>=my_turtle</span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/wechat04.jpg" class="" title="这是一张图片">
<p>再次查看节点，会显示</p>
<img src="/2022/11/30/internship03/wechat05.jpg" class="" title="这是一张图片">

<h3 id="话题topic"><a href="#话题topic" class="headerlink" title="话题topic"></a>话题topic</h3><p>ROS提供了话题topic作为最主要的通讯机制。还是通过小海龟来理解topic通讯机制。首先启动ROS Master，再启动一只小海龟。再打开一个新终端，键入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosrun turtlesim turtle_teleop_key</span></span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/wechat06.jpg" class="" title="这是一张图片">
<p>把光标放在这个终端内，通过方向键就可以控制小海龟的运动。查看当前节点，就可以发现，这个键盘控制也是一个节点。那么这两个节点之间是如何通讯的呢？我们可以通过ROS自带的一些工具来理解这件事。打开一个新终端，键入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosrun rqt_graph rqt_graph</span></span><br></pre></td></tr></table></figure>
<p>rqt是ROS自带的一种图形化工具，可以呈现节点之间的通讯关系。按回车之后，会弹出如下界面</p>
<img src="/2022/11/30/internship03/wechat07.jpg" class="" title="这是一张图片">
<p>&#x2F;teleop_turtle这个节点将按下的方向键信息发布到&#x2F;turtle1&#x2F;cmd_vel这个话题，而&#x2F;turtlesim节点订阅了&#x2F;turtle1&#x2F;cmd_vel这个话题。topic本质上是一种异步通讯，也就是说发布消息的节点并不在乎有没有其他节点接收到它发布的消息，而订阅消息的节点也同样不在乎接收到的消息来自于哪个节点。同样的，我们可以键入如下命令，来查看当前存在的话题名称</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rostopic list</span></span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/wechat08.jpg" class="" title="这是一张图片">
<p>可以通过如下命令，查看话题类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic <span class="built_in">type</span> /turtle1/cmd_vel</span><br></pre></td></tr></table></figure>
<p>结果显示geometry_msgs&#x2F;Twist。这个类型似乎跟我们预期的不太一样，看起来很奇怪。这其实是ROS自带的一种标准消息类型，有点类似于C语言中的结构体。通过一下命令，可以查看这个消息类型的具体形式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">rosmsg <span class="keyword">show</span> geometry_msgs/Twist</span><br></pre></td></tr></table></figure>
<p>结果显示如下</p>
<img src="/2022/11/30/internship03/wechat09.jpg" class="" title="这是一张图片">
<p>不难理解，这个消息类型其实定义的就是三个平动和三个转动。以上就是基于海龟的ros基础学习。</p>
<h2 id="通过nomachine远程连接工控机"><a href="#通过nomachine远程连接工控机" class="headerlink" title="通过nomachine远程连接工控机"></a>通过nomachine远程连接工控机</h2><p>要想实现nomachine远程连接工控机，那么win10电脑和工控机的linux各自都需要下载nomachine。如果工控机没有安装ssh。需要外接显示器和键鼠来安装ssh。<br>Step1：通过外接显示器和键鼠在工控机上安装ssh，在终端输入</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p>Step2：通过win10命令窗口远程连接,在cmd输入 ssh 用户名@ip地址</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> ros@<span class="number">192.168.1.102</span></span><br></pre></td></tr></table></figure>
<p>如果出现这种情况</p>
<img src="/2022/11/30/internship03/nomachine01.jpg" class="" title="这是一张图片">
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span>-keygen -R <span class="number">192.168.1.102</span></span><br></pre></td></tr></table></figure>
<img src="/2022/11/30/internship03/nomachine02.jpg" class="" title="这是一张图片">
<p>然后再输入</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> ros@<span class="number">192.168.1.102</span></span><br></pre></td></tr></table></figure>
<p>即可连接上</p>
<img src="/2022/11/30/internship03/nomachine03.jpg" class="" title="这是一张图片">
<p>Step3：在linux上安装nomachine<br>nomachine软件包已经保存在gitee上了，所以我们直接从gitee上下载。先安装gitee相关的软件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure>
<p>安装完后，进入gitee网址，复制http网页，在终端输入</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo git clone https:<span class="regexp">//gi</span>tee.com<span class="regexp">/lizhenke/</span>zhuangji.git</span><br><span class="line">sudo dpkg -i nomachine_7.<span class="number">6.2</span>_4_amd64.deb</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>如果想卸载可以输入如下指令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo dpkg -r nomachine</span></span><br></pre></td></tr></table></figure>

<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="ROS导航move-base"><a href="#ROS导航move-base" class="headerlink" title="ROS导航move_base"></a>ROS导航move_base</h2><p>ROS Failed to create the dwa_local_planner&#x2F;DWAPlannerROS planner</p>
<img src="/2022/11/30/internship03/OtherQ01.jpg" class="" title="这是一张图片">
<p>解决办法：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-melodic-dwa-<span class="keyword">local</span>-planner</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>公司实习</tag>
      </tags>
  </entry>
  <entry>
    <title>Second Study Record of internship</title>
    <url>/2022/10/30/internship02/</url>
    <content><![CDATA[<p>2022-10-30 ~ 2022-11-30</p>
<span id="more"></span>
<h1 id="嵌入式学习"><a href="#嵌入式学习" class="headerlink" title="嵌入式学习"></a>嵌入式学习</h1><h2 id="ubuntu操作学习"><a href="#ubuntu操作学习" class="headerlink" title="ubuntu操作学习"></a>ubuntu操作学习</h2><p>修改文件权限，在安装ros为了能执行rosdep update需要修改一些文件，而这些文件的权限只有“只读”，为了修改文件，比如想修改usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;rosdep2里的sources_list.py文件可以在根目录下执行如下指令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo chmod <span class="number">777</span> <span class="regexp">/usr/</span>lib<span class="regexp">/python2.7/</span>dist-packages<span class="regexp">/rosdep2/</span>sources_list.py</span><br></pre></td></tr></table></figure>
<p>根目录下的次目录：&#x2F;dev &#x2F;mnt<br>&#x2F;dev是一个关于设备接口的目录。在Linux系统上，任何装置与接口设备都是以档案的形态存在于dev目录当中。<br>&#x2F;mnt是一个关于挂载的目录。如果要暂时挂载某些额外的装置，一般在这个目录下操作。<br>cat,“ concatenate ”的缩写,常用来查看多个文件的内容</p>
<img src="/2022/10/30/internship02/cat01.jpg" class="" title="这是一张图片">
<p>echo：可以将内容写入目标文件。如果目标文件不存在，将创建它。&gt;使用时，文件将被覆盖；&gt;&gt;使用时，会将输出附加到文件中。</p>
<img src="/2022/10/30/internship02/echo01.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/echo02.jpg" class="" title="这是一张图片">
<p>grep能找到匹配指定字符的文件</p>
<img src="/2022/10/30/internship02/grep01.jpg" class="" title="这是一张图片">
<p>gedit以图形化方式编辑文本。</p>
<img src="/2022/10/30/internship02/gedit01.jpg" class="" title="这是一张图片">
<h2 id="驱动分层思想"><a href="#驱动分层思想" class="headerlink" title="驱动分层思想"></a>驱动分层思想</h2><p>Linux驱动&#x3D;驱动框架+硬件操作&#x3D;驱动框架+单片机，而整个驱动代码的编写运用了分层思想。上层leddrv.c为通用的框架，抽象出file_operations结构体并注册了驱动。下层board_A.c为硬件操作，抽象出并实现自己的led_operations结构体，led_operations结构体用来表示LED硬件的操作。</p>
<img src="/2022/10/30/internship02/led01.jpg" class="" title="这是一张图片">
<h3 id="led-opr-h"><a href="#led-opr-h" class="headerlink" title="led_opr.h"></a>led_opr.h</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifndef _LED_OPR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_OPR_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations &#123;</span><br><span class="line">	<span class="built_in">int</span> num;</span><br><span class="line">	<span class="built_in">int</span> (*<span class="keyword">init</span>) (<span class="built_in">int</span> which); <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">	<span class="built_in">int</span> (*ctl) (<span class="built_in">int</span> which, <span class="built_in">char</span> status); <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> led_operations *get_board_led_opr(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中#ifndef与#endif是为了防止文件之间重复声明了同样的定义或声明。如果引用led_operations时_LED_OPR_H之前没有被定义，那么#ifndef与#endif之间的文件就会被执行。*init函数指针的作用初始化led,里面的which是指定哪个led; *ctl函数指针的作用是控制led的灯。</p>
<h3 id="leddrv-c"><a href="#leddrv-c" class="headerlink" title="leddrv.c"></a>leddrv.c</h3><p>头文件</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">module.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">fs.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">errno.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">miscdevice.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">kernel.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">major.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">mutex.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">proc_fs.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">seq_file.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">stat.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">init.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">device.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">tty.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">kmod.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">gfp.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &quot;<span class="string">led_opr.h</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>声明全局变量以及*p_led_opr指针，p_led_opr用来访问led_opr.h文件。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">class</span> *led_class;</span><br><span class="line"><span class="keyword">struct</span> led_operations *p_led_opr;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br></pre></td></tr></table></figure>
<p>实现对应的oread&#x2F;close等函数。(不重要)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">led_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现write&#x2F;open函数。我们可以看到在write函数里指针p_led_opr，它的结构体为led_operations，能直接访问ctl，根据次设备号minor与status控制led。open函数里p_led_opr能直接访问init，根据次设备号minor初始化led。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">char</span> status;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="built_in">file_inode</span>(file);</span><br><span class="line">	<span class="type">int</span> minor = <span class="built_in">iminor</span>(inode);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	err = <span class="built_in">copy_from_user</span>(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">	p_led_opr-&gt;<span class="built_in">ctl</span>(minor, status);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">led_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> minor = <span class="built_in">iminor</span>(node);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">	p_led_opr-&gt;<span class="built_in">init</span>(minor);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义file_operations结构体，结构体内含有所有操作的函数</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> led_drv = &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = led_drv_open,</span><br><span class="line">	.read    = led_drv_read,</span><br><span class="line">	.write   = led_drv_write,</span><br><span class="line">	.release = led_drv_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册入口函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> __init led<span class="constructor">_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> err;</span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	major = register<span class="constructor">_chrdev(0, <span class="string">&quot;100ask_led&quot;</span>, &amp;<span class="params">led_drv</span>)</span>;  <span class="comment">/* /dev/led */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	led_class = <span class="keyword">class</span><span class="constructor">_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>)</span>;</span><br><span class="line">	err = <span class="constructor">PTR_ERR(<span class="params">led_class</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="constructor">IS_ERR(<span class="params">led_class</span>)</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister<span class="constructor">_chrdev(<span class="params">major</span>, <span class="string">&quot;led&quot;</span>)</span>;</span><br><span class="line">		return -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p_led_opr = get<span class="constructor">_board_led_opr()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_led_opr-&gt;num; i++)</span><br><span class="line">		device<span class="constructor">_create(<span class="params">led_class</span>, NULL, MKDEV(<span class="params">major</span>, <span class="params">i</span>)</span>, NULL, <span class="string">&quot;100ask_led%d&quot;</span>, i); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义出口函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void __exit led<span class="constructor">_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_led_opr-&gt;num; i++)</span><br><span class="line">		device<span class="constructor">_destroy(<span class="params">led_class</span>, MKDEV(<span class="params">major</span>, <span class="params">i</span>)</span>); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line"></span><br><span class="line">	device<span class="constructor">_destroy(<span class="params">led_class</span>, MKDEV(<span class="params">major</span>, 0)</span>);</span><br><span class="line">	<span class="keyword">class</span><span class="constructor">_destroy(<span class="params">led_class</span>)</span>;</span><br><span class="line">	unregister<span class="constructor">_chrdev(<span class="params">major</span>, <span class="string">&quot;100ask_led&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供设备信息，自动创建设备节点</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">led_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">led_exit</span>)</span>;</span><br><span class="line"><span class="constructor">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="board-stm32157-c"><a href="#board-stm32157-c" class="headerlink" title="board_stm32157.c"></a>board_stm32157.c</h3><p>头文件</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">module.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">fs.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">errno.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">miscdevice.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">kernel.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">major.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">mutex.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">proc_fs.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">seq_file.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">stat.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">init.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">device.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">tty.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">kmod.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">gfp.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">asm</span>/<span class="string">io.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &quot;<span class="string">led_opr.h</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>驱动led涉及的硬件的物理地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RCC_PLL4CR地址：0x50000000 + 0x894</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *RCC_PLL4CR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RCC_MP_AHB4ENSETR 地址：0x50000000 + 0xA28</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *RCC_MP_AHB4ENSETR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIOA_MODER 地址：0x50002000 + 0x00</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIOA_MODER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIOA_BSRR 地址： 0x50002000 + 0x18</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIOA_BSRR;</span><br></pre></td></tr></table></figure>
<p>编写stm32mp157相关的init与ctl的函数，board_demo_led_init与led_operations结构体里的*init相对应；board_demo_led_ctl与led_operations结构体里的 *ctl相对应；</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">static int board_demo_led_init (int <span class="keyword">which</span>) <span class="comment">/* 初始化LED, which-哪个LED */</span>	   </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!RCC_PLL4CR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// RCC_PLL4CR地址：0x50000000 + 0x894</span></span><br><span class="line">		RCC_PLL4CR = ioremap(0x50000000 + 0x894, 4);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// RCC_MP_AHB4ENSETR 地址：0x50000000 + 0xA28</span></span><br><span class="line">		RCC_MP_AHB4ENSETR = ioremap(0x50000000 + 0xA28, 4);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// GPIOA_MODER 地址：0x50002000 + 0x00</span></span><br><span class="line">		GPIOA_MODER = ioremap(0x50002000 + 0x00, 4);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// GPIOA_BSRR 地址： 0x50002000 + 0x18</span></span><br><span class="line">		GPIOA_BSRR = ioremap(0x50002000 + 0x18, 4);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">which</span> == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* enalbe PLL4, it is clock source for all gpio */</span></span><br><span class="line"><span class="comment">		*RCC_PLL4CR |= (1&lt;&lt;0);</span></span><br><span class="line">		<span class="keyword">while</span> ((*RCC_PLL4CR &amp; (1&lt;&lt;1)) == 0);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* enable gpioA */</span></span><br><span class="line"><span class="comment">		*RCC_MP_AHB4ENSETR |= (1&lt;&lt;0);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * configure gpa10 as gpio</span></span><br><span class="line"><span class="comment">		 * configure gpio as output </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">		*GPIOA_MODER &amp;= ~(3&lt;&lt;20);</span></span><br><span class="line"><span class="comment">		*GPIOA_MODER |= (1&lt;&lt;20);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static int board_demo_led_ctl (int <span class="keyword">which</span>, <span class="keyword">char</span> status) <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">which</span> == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* to set gpio register: out 1/0 */</span></span><br><span class="line">		<span class="keyword">if</span> (status)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* set gpa10 to let led on */</span></span><br><span class="line"><span class="comment">			*GPIOA_BSRR = (1&lt;&lt;26);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* set gpa10 to let led off */</span></span><br><span class="line"><span class="comment">			*GPIOA_BSRR = (1&lt;&lt;10);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个名为board_demo_led_opr的led_operations结构体，.init指向board_demo_led_init函数，.ctl指向board_demo_led_ctl函数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> led_operations board_demo_led_opr = &#123;</span><br><span class="line">	.num  = <span class="number">1</span>,</span><br><span class="line">	.<span class="keyword">init</span> = board_demo_led_init,</span><br><span class="line">	.ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>get_board_led_opr函数供上层leddrv.c调用，给上层leddrv.c提供结构体led_operations。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct led_operations *<span class="title function_">get_board_led_opr</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;board_demo_led_opr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>在leddrv.c入口函数里我们发现</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">p_led_opr</span> = get_board_led_opr()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>p_led_opr是指针函数，指向了另一个指针函数get_board_led_opr。而get_board_led_opr在board_stm32157.c中对board_demo_led_opr进行取址，能调用里面的.num、.init和.ctl,而这三个分别对应了1、board_demo_led_init和board_demo_led_ctl,后两者都是board_stm32157.c对配置引脚涉及的硬件进行使能，比如使能PLL、GPIO和设置PA10等等。所以可以推断在leddrv.c里led_drv_open和led_drv_write函数里p_led_opr-&gt;ctl(minor, status)和p_led_opr-&gt;init(minor)调用的ctl和init是board_stm32157.c里的board_demo_led_init和board_demo_led_ctl。</p>
<h2 id="驱动分离思想"><a href="#驱动分离思想" class="headerlink" title="驱动分离思想"></a>驱动分离思想</h2><p>如果换个引脚驱动led，就需要查询对应的手册，修改对应使能的硬件，是件很麻烦的事情。所以采用分离思想，把board_A_led.c拆分成board_A_led.c、led_resource.h和Chip_gpio.c。board_A_led.c和led_resource.h用来指定哪个引脚，Chip_gpio.c实现GPIO等硬件的操作。(官方资料里也没有找到stm32mp157的专用代码，故此处知识点本人也只是作为一个了解)</p>
<h2 id="gcc编译器的使用"><a href="#gcc编译器的使用" class="headerlink" title="gcc编译器的使用"></a>gcc编译器的使用</h2><p>在日常学习过程中，我们的代码再当前平台编译，然后在当前平台运行，这一整套操作叫本地编译。单片机学习过程中，我们常常在Windows或者Linux上编译后再通过NFS挂载的方式把运行文件传输到其他平台比如单片机中进行执行，因此这里需要用到交叉编译。编译工具常常有xxx-gcc、xxx-ld等。</p>
<h3 id="gcc编译过程"><a href="#gcc编译过程" class="headerlink" title="gcc编译过程"></a>gcc编译过程</h3><p>我们在这举一个常用的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &gt;= <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, %s!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过gcc编译过程和结果：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">./hello</span><br><span class="line"><span class="built_in">Hello,</span> world!</span><br></pre></td></tr></table></figure>
<p>一个c&#x2F;c++文件内部要经过预处理、编译、汇编和链接等4步才能变成可执行文件。所以gcc -o hello hello.c代码可以拆分程以下代码：</p>
<img src="/2022/10/30/internship02/gcc01.jpg" class="" title="这是一张图片">
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">预处理：xxx-gcc  -E -o hello<span class="selector-class">.i</span> hello<span class="selector-class">.c</span></span><br><span class="line">编译：xxx-gcc  -S -o hello<span class="selector-class">.s</span> hello<span class="selector-class">.i</span></span><br><span class="line">汇编：xxx-gcc  -c -o hello<span class="selector-class">.o</span> hello<span class="selector-class">.s</span></span><br><span class="line">链接：xxx-gcc  -o hello hello<span class="selector-class">.o</span> </span><br></pre></td></tr></table></figure>
<p>预处理阶段：通过以字符#开头的命令修给原始的C程序，得到另外一个C程序，通常以.i结尾作为文件拓展名。主要是进行文本替换、宏展开、删除注释这类简单工作。<br>编译阶段：编译器讲.i文件翻译成.s文件，包含相应的汇编语言程序。<br>汇编阶段：将.s文件翻译成机器语言指令，并将结果保存在目标文件.o中。<br>链接阶段：把所需要的.o文件全都合并到一起，得到可执行文件。可执行文件一般为elf文件（OBJ文件）。</p>
<h2 id="Makefile的简单使用"><a href="#Makefile的简单使用" class="headerlink" title="Makefile的简单使用"></a>Makefile的简单使用</h2><p>在Linux使用make命令来编译程序，而make命令执行的动作依赖于Makefile文件。make 的实质：遍历所有目录下的makefile，并依照makefile的内容编译相关代码。在stm32单片机下通用的Makefile文件如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment">#  export ARCH=arm</span></span><br><span class="line"><span class="comment">#  export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span></span><br><span class="line"><span class="comment">#  export PATH=$PATH:/home/book/100ask_stm32mp157_pro-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span></span><br><span class="line"><span class="variable constant_">KERN_DIR</span> = <span class="regexp">/home/book</span><span class="regexp">/100ask_roc-rk3399-pc/linux</span>-<span class="number">4.4</span></span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">	make -C <span class="variable">$(</span><span class="variable constant_">KERN_DIR</span>) M=<span class="string">`pwd`</span> modules </span><br><span class="line">	<span class="variable">$(</span><span class="variable constant_">CROSS_COMPILE</span>)gcc -o ledtest ledtest.c </span><br><span class="line"><span class="symbol">clean:</span></span><br><span class="line">	make -C <span class="variable">$(</span><span class="variable constant_">KERN_DIR</span>) M=<span class="string">`pwd`</span> modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f ledtest</span><br><span class="line"></span><br><span class="line">obj-m += leddrv.o chip_demo_gpio.o board_A_led.o</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">KERN_DIR = <span class="regexp">/home/</span>book<span class="regexp">/100ask_roc-rk3399-pc/</span>linux-<span class="number">4.4</span></span><br></pre></td></tr></table></figure>
<p>KERN_DIR表示内核源码目录，这种方式适用于嵌入式开发的交叉编译，KERN_DIR目录中包含了内核驱动模块所需要的各种头文件及依赖。<br>我们通过make能执行以下两条语句：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">make -C $(KERN_DIR) M=<span class="string">`pwd`</span> modules </span><br></pre></td></tr></table></figure>
<p>该命令是make modules编译模块命令的扩展，-C选项的作用是指将当前的工作目录转移到制定的目录，即（KERN_DIR）目录，程序到（shell pwd）当前目录查找模块源码，将其编译，生成.ko文件</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$(CROSS_COMPILE)gcc -o ledtest ledtest.c</span><br></pre></td></tr></table></figure>
<p>通过gcc交叉编译把ledtest.c变成可执行文件ledtest，其中CROSS_COMPILE交叉编译指定工具链的前缀为arm-buildroot-linux-gnueabihf-。<br>我们通过make clean能执行以下三条语句：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">make -C $(KERN_DIR) M=<span class="string">`pwd`</span> modules clean</span><br></pre></td></tr></table></figure>
<p>把编译好的模块卸载清除</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">rm -rf modules.<span class="keyword">order</span></span><br><span class="line"><span class="title">rm</span> -f ledtest</span><br></pre></td></tr></table></figure>
<p>rm -rf是Linux下一条文件删除命令。意味着删除modules.order和可执行文件ledtest。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">obj-m += leddrv<span class="selector-class">.o</span> chip_demo_gpio<span class="selector-class">.o</span> board_A_led.o</span><br></pre></td></tr></table></figure>
<p>obj-m的意思为Makefile文件中确定要编译的文件编译为驱动的形式。在Makefile文件中确定要编译的文件：leddrv.o chip_demo_gpio.o board_A_led.o。</p>
<h1 id="C与C-学习"><a href="#C与C-学习" class="headerlink" title="C与C++学习"></a>C与C++学习</h1><h2 id="C-x2F-C-知识"><a href="#C-x2F-C-知识" class="headerlink" title="C&#x2F;C++知识"></a>C&#x2F;C++知识</h2><h3 id="抽象类-amp-虚函数"><a href="#抽象类-amp-虚函数" class="headerlink" title="抽象类&amp;虚函数"></a>抽象类&amp;虚函数</h3><p>含有纯虚函数的类称之为抽象类，虚函数没有实际的实现，不能实例化，只能通过子类来实现具体功能。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">virtual &lt;类型&gt;&lt;函数名&gt;(参数表) <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>子类必须实现父类的所有纯虚函数，不然会报错。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eatFood</span>()</span>=<span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doExercise</span>()</span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">public</span> <span class="title">Human</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">int</span> a;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">eatFood</span>()</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Boss eats apple&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// void doExercise()&#123;</span></span><br><span class="line">		<span class="comment">// 	cout &lt;&lt; &quot;Boss plays basketball&quot; &lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	Boss MiLu;</span><br><span class="line">	MiLu.eatFood();</span><br><span class="line">	<span class="comment">//MiLu.doExercise();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/cStudy01.jpg" class="" title="这是一张图片">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eatFood</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doExercise</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> : <span class="keyword">public</span> Human&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">eatFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Boss eats apple&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">doExercise</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Boss plays basketball&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Boss MiLu;</span><br><span class="line">	MiLu.<span class="built_in">eatFood</span>();</span><br><span class="line">	MiLu.<span class="built_in">doExercise</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/cStudy02.jpg" class="" title="这是一张图片">
<h3 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h3><p>public：公共权限。类内部和类外部都能访问；。<br>protected:保护权限。类内部可以访问，类外部不能访问；儿子可以访问父亲中的保护内容。<br>private：私有权限。类内部可以访问，类外部不能访问;儿子不可以访问父亲中的私有内容。<br>struct默认权限为公共。<br>class默认权限为私有。</p>
<h3 id="类的析构函数与构造函数"><a href="#类的析构函数与构造函数" class="headerlink" title="类的析构函数与构造函数"></a>类的析构函数与构造函数</h3><p>创造类的时候，如果没有定义构造函数和析构函数，类会自动为我们创造空实现的构造函数和析构函数。<br>构造函数作用为初始化类的成员，保证每个数据成员都有合适的成员。语法: 类名(参数){};特点：<br>1、函数名与类名同名；<br>2、不用写函数类型且没有返回值；<br>3、可以有参数，能发生重载；<br>4、在类的生命周期内只能调用一次对应的构造函数。<br>析构函数作用为在类销毁前执行清理操作。语法: ~类名(){};特点：<br>1、函数名与类名同名；<br>2、不用写函数类型且没有返回值；<br>3、不可以有参数，不能发生重载；<br>4、在类销毁前只能调用一次析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">shape</span>()&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;析构函数shape&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">shape</span>()&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;构造函数shape&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	shape A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/cStudy03.jpg" class="" title="这是一张图片">
<h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>指针函数本质上是指针变量。一般有两种用途：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*sum)(<span class="type">int</span> a,<span class="type">int</span> b);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum01</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">	sum = sum01;</span><br><span class="line">	<span class="type">int</span> c = <span class="built_in">sum</span>(a,b);</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/FcnPoint01.jpg" class="" title="这是一张图片">
<p>从这个例子可以看到，我们首先定义了一个函数指针sum ,这个函数指针的返回值为int型,然后我们给函数指针赋值，赋值为sum01,也就是sum01函数的首地址，此时sum获得了sum01的地址，sum等于sum01的地址，所以最终调用 sum();也就相当于调用了sum01();</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="built_in">void</span> (*sum)(<span class="type">void</span>);</span><br><span class="line">&#125;A1,A2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum01</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum01&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A1 a = &#123;</span><br><span class="line">		.sum = sum01,</span><br><span class="line">	&#125;;</span><br><span class="line">	a.<span class="built_in">sum</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/FcnPoint02.jpg" class="" title="这是一张图片">

<h2 id="leetcode刷题"><a href="#leetcode刷题" class="headerlink" title="leetcode刷题"></a>leetcode刷题</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<img src="/2022/10/30/internship02/leetCode01.jpg" class="" title="这是一张图片">
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> search(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> halfIndex = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[halfIndex] &gt; <span class="keyword">target</span>)&#123;</span><br><span class="line">                right = halfIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(nums[halfIndex] &lt; <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">                left = halfIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> halfIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="研二公司实习"><a href="#研二公司实习" class="headerlink" title="研二公司实习"></a>研二公司实习</h1><h2 id="ros安装2-0"><a href="#ros安装2-0" class="headerlink" title="ros安装2.0"></a>ros安装2.0</h2><p>工控机系统：Ubuntu 18.04<br>安装时间：2022.10.31<br>如果官网与本文代码有区别，请以官网为主。<br>打开两个网站：<br>英文ros官网：<a href="http://wiki.ros.org/melodic/Installation/Ubuntu">http://wiki.ros.org/melodic/Installation/Ubuntu</a><br>中文ros官网：<a href="http://wiki.ros.org/cn/melodic/Installation/Ubuntu">http://wiki.ros.org/cn/melodic/Installation/Ubuntu</a><br>第一步：<br>打开英文ros官网《1.2 Setup your sources.list》的Mirrors，设置我们所需要的镜像源，最好是选择清华源：</p>
<img src="/2022/10/30/internship02/1.2_Setup_sources01.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/1.2_Setup_sources02.jpg" class="" title="这是一张图片">
<p>在ros终端输入：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;. <span class="string">/etc/lsb-release</span> &amp;&amp; <span class="keyword">echo</span> <span class="string">&quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot;</span> &gt; <span class="string">/etc/apt/sources.list.d/ros-latest.list</span>&#x27;</span><br></pre></td></tr></table></figure>
<p>第二步：<br>打开中文ros官网《1.3 设置密钥》</p>
<img src="/2022/10/30/internship02/1.3_02.jpg" class="" title="这是一张图片">
<p>在ros终端输入：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">apt-key</span> <span class="string">adv</span> <span class="built_in">--keyserver</span> <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> <span class="built_in">--recv-key</span> <span class="string">C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span></span><br></pre></td></tr></table></figure>
<p>第三步：<br>打开英文ros官网《1.4 Installation》，依次在ros端执行：</p>
<img src="/2022/10/30/internship02/1.4Installation.jpg" class="" title="这是一张图片">
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo apt update</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> ros-melodic-desktop</span><br></pre></td></tr></table></figure>
<p>因为对于公司产品Desktop Install已经够用，如果安装Desktop-Full Install比较耗时间。<br>第四步：<br>打开英文ros官网《1.6 Dependencies for building packages》，依次在ros端执行：</p>
<img src="/2022/10/30/internship02/1.6Dependencies.jpg" class="" title="这是一张图片">
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">sudo apt install <span class="keyword">python</span>-rosdep <span class="keyword">python</span>-rosinstall <span class="keyword">python</span>-rosinstall-generator <span class="keyword">python</span>-wstool build-essential</span><br></pre></td></tr></table></figure>
<p>第五步：<br>设置环境，执行以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/1.6Dependencies02.jpg" class="" title="这是一张图片">
<p>第六步：<br>初始化 rosdep，这是关键地方，这地方会疯狂报错，主要还是网络延迟问题。首先执行第一条</p>
<img src="/2022/10/30/internship02/1.6Dependencies03.jpg" class="" title="这是一张图片">
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo rosdep <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>如果不成功很正常，首先执行以下指令</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo gedit <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure>
<p>在在文件末尾添加</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">151.101.84.133</span>  raw.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>然后反复使用sudo rosdep init，就能执行成功。下一句</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosdep update</span></span><br></pre></td></tr></table></figure>
<p>如果没执行成功很正常，需要去其他地方修改文件。首先进入&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;rosdep2里的sources_list.py文件，添加</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">&quot;https://ghproxy.com/&quot;</span>+url</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/ros_download01.jpg" class="" title="这是一张图片">
<p>如果文件权限是只读，修改权限方法看本文的嵌入式学习的ubuntu操作学习，然后在第二处（64行）添加</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//g</span>hproxy.com/</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/ros_download02.jpg" class="" title="这是一张图片">
<p>在</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>lib<span class="regexp">/python2.7/</span>dist-packages<span class="regexp">/rosdep2/g</span>bpdistro_support.py <span class="number">35</span>行</span><br><span class="line"><span class="regexp">/usr/</span>lib<span class="regexp">/python2.7/</span>dist-packages<span class="regexp">/rosdep2/</span>rep3.py	<span class="number">36</span>行</span><br><span class="line"><span class="regexp">/usr/</span>lib<span class="regexp">/python2.7/</span>dist-packages<span class="regexp">/rosdistro/m</span>anifest_provider/github.py <span class="number">68</span>行 <span class="number">119</span>行</span><br><span class="line"><span class="regexp">/usr/</span>lib<span class="regexp">/python2.7/</span>dist-packages<span class="regexp">/rosdistro/</span>__init__.py的DEFAULT_INDEX_URL</span><br></pre></td></tr></table></figure>
<p>也进行如上替换</p>
<img src="/2022/10/30/internship02/ros_download03.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/ros_download04.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/ros_download05.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/ros_download06.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/ros_download07.jpg" class="" title="这是一张图片">

<h2 id="ros学习"><a href="#ros学习" class="headerlink" title="ros学习"></a>ros学习</h2><p>workspace是一个存放工程开发相关文件的文件夹<br>src:代码空间<br>build:编译空间<br>devel:开发空间</p>
<h3 id="ros-bringup-launch"><a href="#ros-bringup-launch" class="headerlink" title="ros_bringup.launch"></a>ros_bringup.launch</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include file<span class="operator">=</span><span class="string">&quot;$(find rocr6_driver)/launch/hw_link.launch&quot;</span> /&gt;</span><br><span class="line">    &lt;node pkg<span class="operator">=</span><span class="string">&quot;rocr6_solver&quot;</span> type<span class="operator">=</span><span class="string">&quot;rocr6_solver&quot;</span> name<span class="operator">=</span><span class="string">&quot;rocr6_solver&quot;</span> output<span class="operator">=</span><span class="string">&quot;screen&quot;</span> &gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line"></span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure>
<p>include：加载属于同一个功能包或不同功能包的另一个launch文件。我们进入hw_link.launch。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg<span class="operator">=</span><span class="string">&quot;rocr6_driver&quot;</span> type<span class="operator">=</span><span class="string">&quot;rocr6_driver&quot;</span> name<span class="operator">=</span><span class="string">&quot;rocr6_driver&quot;</span> output<span class="operator">=</span><span class="string">&quot;screen&quot;</span> &gt;</span><br><span class="line">        &lt;rosparam file<span class="operator">=</span><span class="string">&quot;$(find rocr6_description)/config/rocr6.yaml&quot;</span> command<span class="operator">=</span><span class="string">&quot;load&quot;</span> /&gt;</span><br><span class="line">        &lt;param name<span class="operator">=</span><span class="string">&quot;port&quot;</span> value<span class="operator">=</span><span class="string">&quot;/dev/ROCR6&quot;</span>/&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure>
<p>pkg:功能包名称<br>type：实际运行节点名称<br>name:与type对应的节点运行时起的名称。一般与type同名，但也可自行修改。<br>output：screen会让终端传输到当前控制台上。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;rosparam <span class="attribute">file</span>=<span class="string">&quot;<span class="variable">$(find rocr6_description)</span>/config/rocr6.yaml&quot;</span> <span class="attribute">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>rosparam:帮助我们将一个yaml格式文件中的参数全部加载到ROS参数服务器中。<br>param:可以把参数加载到ROS服务器上，value意味着把value的值赋予到param。</p>
<h2 id="实习公司调试室外重载移动车调试2-0："><a href="#实习公司调试室外重载移动车调试2-0：" class="headerlink" title="实习公司调试室外重载移动车调试2.0："></a>实习公司调试室外重载移动车调试2.0：</h2><p>日期：10.31</p>
<h3 id="基础软件文件下载"><a href="#基础软件文件下载" class="headerlink" title="基础软件文件下载"></a>基础软件文件下载</h3><p>Step1：<br>在Windows界面打开gitee网址：<a href="https://gitee.com/dashboard%EF%BC%88%E4%B9%9F%E8%83%BD%E5%9C%A8Ubuntu%E5%86%85%E6%89%93%E5%BC%80%EF%BC%89%EF%BC%8C%E6%90%9C%E7%B4%A2rocr6">https://gitee.com/dashboard（也能在Ubuntu内打开），搜索rocr6</a></p>
<img src="/2022/10/30/internship02/ShenGu_DownLoad01.jpg" class="" title="这是一张图片">
<p>选择第一个</p>
<img src="/2022/10/30/internship02/ShenGu_DownLoad02.jpg" class="" title="这是一张图片">
<p>点进去，再点击zhwl_1981</p>
<img src="/2022/10/30/internship02/ShenGu_DownLoad03.jpg" class="" title="这是一张图片">
<p>点击complex_robot</p>
<img src="/2022/10/30/internship02/ShenGu_DownLoad04.jpg" class="" title="这是一张图片">
<p>Step2：<br>打开ubuntu18.04，在根目录打开终端。</p>
<img src="/2022/10/30/internship02/ShenGu_DownLoad05.jpg" class="" title="这是一张图片">
<p>依次输入Windows界面的gitee里的代码：</p>
<img src="/2022/10/30/internship02/ShenGu_DownLoad06.jpg" class="" title="这是一张图片">
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://gitee.com/zhwl_1981/complex_robot.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> complex_robot</span></span><br></pre></td></tr></table></figure>
<p>Step3：<br>在complex_robot文件下的终端依次输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./installRobot zeus_s2_rocr6_g3p.rosinstall</span><br><span class="line">./installRobot location_navigation.rosinstall</span><br></pre></td></tr></table></figure>
<p>在输入.&#x2F;installRobot zeus_s2_rocr6_g3p.rosinstall后会出现一些报错：</p>
<img src="/2022/10/30/internship02/ShenGu_DownLoad07.jpg" class="" title="这是一张图片">
<p>因为缺少工程编译所需的依赖包，解决办法其说明缺少依赖包ecl-threads，这个时候把提示里面的ecl_threadsConfig.cmake后面的Config.cmake删掉，即为缺少的包，并把其中的下划线_用连字符-替换，替换后就变成ecl-threads,然后在前面加上ros-melodic即可。这里的melodic是我安装ROS的版本。所以执行代码：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install ros-melodic-ecl-threads</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/ShenGu_DownLoad08.jpg" class="" title="这是一张图片">
<p>跟上述同样的道理，缺少tf2_geometry_msgs的包</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install ros-melodic-tf2_geometry_msgs</span><br></pre></td></tr></table></figure>
<p>这样.&#x2F;installRobot zeus_s2_rocr6_g3p.rosinstall就能完美执行了。</p>
<h3 id="开机自启动设置"><a href="#开机自启动设置" class="headerlink" title="开机自启动设置"></a>开机自启动设置</h3><p>启动底盘驱动程序</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo .<span class="regexp">/catkin_ws/</span>src<span class="regexp">/mobile/</span>zeus_s2_bringup<span class="regexp">/scripts/m</span>ttcan</span><br><span class="line">roslaunch zeus_s2_bringup hw_link.launch</span><br></pre></td></tr></table></figure>
<p>但每次运行起来很麻烦，首先是要么外接显示器，要么用电脑远程连接，输入这些指令后才能用手柄启动，不能做到一开机就能用手柄驱动，所以这两个指令最好是直接设置为开机自启动。<br>在我们下载好的路径下catkin_ws&#x2F;src&#x2F;mobile&#x2F;zeus_s2_bringup&#x2F;scripts有一个start.sh脚本文件，如果没有自行创立一个，脚本文件内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /opt/ros/melodic/setup.bash</span><br><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span> 2s</span><br><span class="line"><span class="built_in">echo</span> nvidia | sudo -S ./catkin_ws/src/mobile/zeus_s2_bringup/scripts/mttcan</span><br><span class="line"><span class="built_in">sleep</span> 5s</span><br><span class="line">roslaunch zeus_s2_bringup all_start.launch</span><br></pre></td></tr></table></figure>
<p>保存后在终端中输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gnome-session-properties</span></span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/kaiji01.jpg" class="" title="这是一张图片">
<p>打开Ubuntu开机首选项管理，点击添加,name可以随便写，Command填以下指令</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">gnome-terminal -x <span class="regexp">/home/</span>nvidia<span class="regexp">/catkin_ws/</span>src<span class="regexp">/mobile/</span>zeus_s2<span class="regexp">/zeus_s2_bringup/</span>scripts/start.sh</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/kaiji02.jpg" class="" title="这是一张图片">
<p>开机自启动设置就完成了。</p>
<h3 id="串口配置"><a href="#串口配置" class="headerlink" title="串口配置"></a>串口配置</h3><p>室外重载用到的硬件有机械臂、夹爪、雷达、超声波和视觉。每个硬件都需要配置相对应的串口</p>
<h4 id="机械臂ROCR6"><a href="#机械臂ROCR6" class="headerlink" title="机械臂ROCR6"></a>机械臂ROCR6</h4><p>Step1：判断ROCR6是串口名字。拔出ROCR6，在终端依次输入以下指令</p>
<img src="/2022/10/30/internship02/ROCR601.jpg" class="" title="这是一张图片">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>再插上ROCR6，查看前后串口变化。发现插上后的串口多一个ttyUSB6，所以ttyUSB6是机械臂对应的串口。</p>
<img src="/2022/10/30/internship02/ROCR603.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/ROCR604.jpg" class="" title="这是一张图片">
<p>Step2：建立规则。输入指令</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo gedit <span class="regexp">/etc/u</span>dev<span class="regexp">/rule.d/</span><span class="number">99</span>-usb-to-uart.rules</span><br></pre></td></tr></table></figure>
<p>99-usb-to-uart.rules本来是不存在的，只不过编辑器打开不存在的文件会自动创建。在我们之前下包里，搜索99-usb-to-uart.rules，在catkin_ws&#x2F;src&#x2F;mobile&#x2F;zeus_s2_bringup&#x2F;scripts里有一个99-usb-to-uart.rules文件，把这里的rules文件的内容复制到编辑器创建的文件里。或者进入catkin_ws&#x2F;src&#x2F;mobile&#x2F;zeus_s2_bringup&#x2F;scripts的终端中，输入以下指令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo cp <span class="number">99</span>-usb-to-uart.rules <span class="regexp">/etc/u</span>dev/rules.d</span><br></pre></td></tr></table></figure>
<p>同样也能在&#x2F;etc&#x2F;udev&#x2F;rule.d目录下创建99-usb-to-uart.rules文件，进入此文件后，除了第4行以后全部注释。若是因特尔的处理器，最后一句需要注释；如不是，需要打开，并且不改变其中信息。</p>
<img src="/2022/10/30/internship02/ROCR602.jpg" class="" title="这是一张图片">
<p>Step3：输入指令，查看串口信息（该指令在99-usb-to-uart.rules第一行就有，复制使用即可）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">udevadm <span class="built_in">info</span> --attribute-walk <span class="attribute">--name</span>=/dev/ttyUSB6</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/ROCR605.jpg" class="" title="这是一张图片">
<p>如果串口是其他名字，则指令末尾ttyUSB6改成对应的串口名字。得到的反馈如下图所示。查看串口信息在第三个looking at下的这句话：KERNELS&#x3D;&#x3D;”1-2.2:1.0” 复制到99-usb-to-uart.rules，删掉ATTRS与MODE。然后进入&#x2F;catkin_ws&#x2F;src&#x2F;arm&#x2F;rocr6_robots&#x2F;rocr6_driver&#x2F;launch里的hw_link.launch文件，查看dev号为ROCR6,把SYMLINK+&#x3D;的内容修改成ROCR6，保存退出。</p>
<img src="/2022/10/30/internship02/ROCR606.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/ROCR607.jpg" class="" title="这是一张图片">
<p>Step4：重新插拔机械臂插口，执行指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>查看是否有&#x2F;dev&#x2F;ROCR6,或者输入</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ls -l <span class="regexp">/dev/</span>|<span class="keyword">grep</span> ttyUSB</span><br></pre></td></tr></table></figure>
<h2 id="ros-matlab"><a href="#ros-matlab" class="headerlink" title="ros+matlab"></a>ros+matlab</h2><h3 id="环境配置与测试"><a href="#环境配置与测试" class="headerlink" title="环境配置与测试"></a>环境配置与测试</h3><p>Step1.配置matlab环境，进入matlab里输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pyenv</span></span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/rosMatlab01.jpg" class="" title="这是一张图片">
<p>我的是matlab2020b，如果Version显示的不是2.7，则需要去下载并安装phthon2.7。进入网站<a href="https://ww2.mathworks.cn/help/matlab/matlab_external/install-the-matlab-engine-for-python.html%E3%80%82%E6%A0%B9%E6%8D%AE%E9%87%8C%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E8%AE%BF%E9%97%AEhttps://www.python.org/downloads/.%E7%82%B9%E5%87%BB">https://ww2.mathworks.cn/help/matlab/matlab_external/install-the-matlab-engine-for-python.html。根据里面的步骤访问https://www.python.org/downloads/.点击</a> Download</p>
<img src="/2022/10/30/internship02/rosMatlab02.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/rosMatlab03.jpg" class="" title="这是一张图片">
<p>安装Windows X86-64</p>
<img src="/2022/10/30/internship02/rosMatlab04.jpg" class="" title="这是一张图片">
<p>安装后的文件直接运行即可。<br>回到matlab</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">pyenv</span><span class="params">(<span class="string">&#x27;Version&#x27;</span>,<span class="string">&#x27;2.7&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/rosMatlab05.jpg" class="" title="这是一张图片">
<p>即配置成功。<br>Step2.进入虚拟机Ubuntu系统（系统为18.04.1），终端输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span></span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/rosMatlab06.jpg" class="" title="这是一张图片">
<p>由图可知我们ip为：192.168.150.130，在matlab命令窗口写入</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setenv</span><span class="params">(<span class="string">&#x27;ROS_MASTER_URI&#x27;</span>,<span class="string">&#x27;http://192.168.150.130:11311&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在Ubuntu终端输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">roscore</span></span><br></pre></td></tr></table></figure>
<p>在matlab输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosinit</span></span><br></pre></td></tr></table></figure>
<p>如果之前在matlab连接过ubuntu，先后输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosshutdown</span></span><br><span class="line"><span class="attribute">rosinit</span></span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/rosMatlab07.jpg" class="" title="这是一张图片">
<p>接着在Ubuntu下在各个终端先后输入</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim<span class="emphasis">_node</span></span><br><span class="line"><span class="emphasis">rosrun turtlesim turtle_teleop_</span>key</span><br></pre></td></tr></table></figure>
<p>在ubuntu终端和matlab命令窗口都输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic <span class="built_in">echo</span> /turtle1/pose</span><br></pre></td></tr></table></figure>
<p>移动海龟我们可以看到ubuntu终端和matlab命令窗口显示的数据是相同的</p>
<img src="/2022/10/30/internship02/rosMatlab08.jpg" class="" title="这是一张图片">
<p>Step3.在matlab配置simulink模型与运行<br>搜索Subscirbe模块和Busselector模块，其中Subscirbe模块配置如下</p>
<img src="/2022/10/30/internship02/rosMatlab09.jpg" class="" title="这是一张图片">
<img src="/2022/10/30/internship02/rosMatlab10.jpg" class="" title="这是一张图片">
<p>Busselector模块配置如下</p>
<img src="/2022/10/30/internship02/rosMatlab11.jpg" class="" title="这是一张图片">
<p>运行时间修改为无穷，点击运行，在ubuntu下继续运动海龟</p>
<img src="/2022/10/30/internship02/rosMatlab12.jpg" class="" title="这是一张图片">

<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="ubuntu无法获得锁-x2F-var-x2F-lib-x2F-dpkg-x2F-lock-open"><a href="#ubuntu无法获得锁-x2F-var-x2F-lib-x2F-dpkg-x2F-lock-open" class="headerlink" title="ubuntu无法获得锁 &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open"></a>ubuntu无法获得锁 &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open</h2><p>运行虚拟机的时候执行sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential的时候报错了。</p>
<img src="/2022/10/30/internship02/Questions01.jpg" class="" title="这是一张图片">
<p>解决方法：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo rm <span class="regexp">/var/</span>cache<span class="regexp">/apt/</span>archives/lock</span><br><span class="line">sudo rm <span class="regexp">/var/</span>lib<span class="regexp">/dpkg/</span>lock</span><br></pre></td></tr></table></figure>
<img src="/2022/10/30/internship02/Questions02.jpg" class="" title="这是一张图片">
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>公司实习</tag>
      </tags>
  </entry>
  <entry>
    <title>First Study Record of internship</title>
    <url>/2022/09/22/internship01/</url>
    <content><![CDATA[<p>2022-09-22 ~ 2022-10-30</p>
<span id="more"></span>
<h1 id="嵌入式学习"><a href="#嵌入式学习" class="headerlink" title="嵌入式学习"></a>嵌入式学习</h1><h2 id="GPIO以及led原理图演变"><a href="#GPIO以及led原理图演变" class="headerlink" title="GPIO以及led原理图演变"></a>GPIO以及led原理图演变</h2><p>GPIO&#x3D;General Purpose Input Output，通用的输入输出接口，有时候称为“IO口”。</p>
<img src="/2022/09/22/internship01/led_01.jpg" class="" title="这是一张图片">
<p>最原始的led图，但是电流过大可能会烧坏二极管。</p>
<img src="/2022/09/22/internship01/led_02.jpg" class="" title="这是一张图片">
<p>增加保护电阻，但电子系统是不可能手动控制开关。</p>
<img src="/2022/09/22/internship01/led_03.jpg" class="" title="这是一张图片">
<p>通过编程，用芯片引脚控制发光二极管，有两种控制方法：<br>1、芯片输出3.3V，使二极管发光。<br>2、芯片输出0V，使二极管发光。<br>但有的芯片驱动为了省电，也就是引脚驱动能力不足，又加以改进。</p>
<img src="/2022/09/22/internship01/led_04.jpg" class="" title="这是一张图片">
<img src="/2022/09/22/internship01/led_05.jpg" class="" title="这是一张图片">
<p>通过编程，用芯片引脚控制发光二极管，有两种控制方法：<br>1、芯片输出1.2V，使二极管发光。<br>2、芯片输出0V，使二极管发光。<br>由此，引脚输出高低电平就能控制led。其中高电平为1，低电平为0.</p>
<h2 id="嵌入式环境"><a href="#嵌入式环境" class="headerlink" title="嵌入式环境"></a>嵌入式环境</h2><p>1、在Windows上用Source insight看Linux内核源码<br>2、用filezilla把我们需要运行的文件上传到虚拟机里运行的ubuntu系统里。<br>3、用mobaxterm远程操控ubuntu。<br>4、用mobaxterm操作开发板。</p>
<h2 id="串口编程"><a href="#串口编程" class="headerlink" title="串口编程"></a>串口编程</h2><p>开始位，数据位，校验位，停止位<br>驱动程序编写流程：<br>1、确定主设备号<br>2、定义自己的file_operations结构体<br>3、实现对应的open&#x2F;read&#x2F;write等函数，填入file_operations结构体<br>4、把file_operations结构体告诉结构体；注册驱动程序<br>5、安装驱动时，就回去调用这个出口函数<br>6、有入口函数就有出口函数：卸载程序时，就会去调用这个出口函数<br>7、提供设备信息，自动创建设备节点</p>
<h2 id="简单的led驱动编程"><a href="#简单的led驱动编程" class="headerlink" title="简单的led驱动编程"></a>简单的led驱动编程</h2><p>Step1:写下包含的头文件：</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">kernel.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">module.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">slab.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">init.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">fs.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">delay.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">poll.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">mutex.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">wait.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">linux</span>/<span class="string">uaccess.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include &lt;<span class="string">asm</span>/<span class="string">io.h</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Step2:确定自己的入口函数以及出口函数：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 入口函数 */</span></span><br><span class="line">static <span class="built_in">int</span> __init led<span class="constructor">_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit led<span class="constructor">_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">led_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">led_exit</span>)</span>;</span><br><span class="line"><span class="constructor">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>Step2:编写入口出口函数：<br>在入口函数通过register_chrdev向内核注册字符设备。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">register<span class="constructor">_chrdev(<span class="params">unsigned</span> <span class="params">int</span> <span class="params">major</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">name</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">file_operations</span> <span class="operator">*</span><span class="params">fops</span>)</span></span><br></pre></td></tr></table></figure>
<p>其中unsigned int major为主设备号，当为0时内核会动态分配一个设备号。一个字符设备设备号分为主设备号和次设备号。主设备号是特定的驱动程序，次设备号是该程序的设备。比如我们要点两个led灯。主设备中的1为led驱动程序，次设备号1-2分别两个led设备；<br>const char *name为注册的设备名称；<br>const struct file_operations *fops为文件操作指针。它是设备号和系统操作之间的纽带，集成了系统操作所需要的一系列函数，每个成员就是一个系统调用，我们先读取fops结构体里的指针函数，接着把控制权交给指针函数。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">major</span> = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_fops)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>入口函数有注册主设备号，那么出口函数就有卸载主设备号</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">unregister<span class="constructor">_chrdev(<span class="params">major</span>,<span class="string">&quot;100ask_led&quot;</span>,)</span>;</span><br></pre></td></tr></table></figure>
<p>编写入口出口函数的后面同时写上</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">led_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">led_exit</span>)</span>;</span><br><span class="line"><span class="constructor">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>其中module支撑驱动的加载与卸载。<br>Step3:编写file_operations结构体以及我们所需要的函数</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> led_fops = &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.write		= led_write,</span><br><span class="line">	.open		= led_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>file_operations是关联系统调用和驱动程序的关键结构体，这个结构每个成员都代表着系统调用。<br>Step4:编写结构体里的函数led_write。led_write的作用是设置gpio的寄存器，输出高低电平点亮或者熄灭led。驱动访问应用层数据需要借助辅助函数copy_to_user与copy_from_user。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy_from_user</span>(&amp;val, buf, <span class="number">1</span>);<span class="comment">//用户空间拷贝到内核空间，拷贝1个字节</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function">			 </span>&#123;</span><br><span class="line">			 	<span class="type">char</span> val;</span><br><span class="line">			 	<span class="comment">/* copy_from_user : get data from app */</span></span><br><span class="line">				<span class="built_in">copy_from_user</span>(&amp;val, buf, <span class="number">1</span>);<span class="comment">//用户空间拷贝到内核空间，拷贝1个字节</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* to set gpio register: out 1/0 */</span></span><br><span class="line">				<span class="keyword">if</span>(val)&#123;</span><br><span class="line"></span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br></pre></td></tr></table></figure>
<p>Step5:编写结构体里的函数led_open。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> led<span class="constructor">_open(<span class="params">struct</span> <span class="params">inode</span> <span class="operator">*</span><span class="params">inode</span>, <span class="params">struct</span> <span class="params">file</span> <span class="operator">*</span><span class="params">filp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最后的目标是让引脚输出电平，led发光，但led是硬件。led_open的作用是驱动硬件，驱动硬件的前提需要访问硬件的地址，所以我们可以在入口函数通过ioremap把所有的硬件的物理地址全都映射成虚拟地址，之后就能驱动led的点亮与熄灭。如果让引脚输出电平，涉及到的硬件流程为：<br>1、使能PLL。寄存器RCC_PLL4CR地址： 0x50000000 + 0x894</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *RCC_PLL4CR;</span><br></pre></td></tr></table></figure>
<p>2、使能GPIO。<br>寄存器RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *RCC_MP_AHB4ENSETR;</span><br></pre></td></tr></table></figure>
<p>3、设置PA10，用作输出<br>寄存器GPIO_MODER 地址： 0x50002000 + 0x00</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO_MODER;</span><br></pre></td></tr></table></figure>
<p>4、设置输出电平<br>寄存器GPIO_BSRR 地址： 0x50002000 + 0x18</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO_BSRR;</span><br></pre></td></tr></table></figure>
<p>在入口出口函数处理物理地址。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> __init led<span class="constructor">_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__ , __FUNCTION__,__LINE__);</span><br><span class="line">	major = register<span class="constructor">_chrdev(0, <span class="string">&quot;100ask_led&quot;</span>, &amp;<span class="params">led_fops</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ioremap(base_phy, size); */</span></span><br><span class="line">	<span class="comment">//RCC_PLL4CR地址： 0x50000000 + 0x894</span></span><br><span class="line">	RCC_PLL4CR = ioremap(<span class="number">0x50000000</span> + <span class="number">0x894</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28</span></span><br><span class="line">	RCC_MP_AHB4ENSETR = ioremap(<span class="number">0x50000000</span> + <span class="number">0xA28</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GPIO_MODER 地址： 0x50002000 + 0x00</span></span><br><span class="line">	GPIO_MODER = ioremap(<span class="number">0x50002000</span> + <span class="number">0x00</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GPIO_BSRR 地址： 0x50002000 + 0x18</span></span><br><span class="line">	GPIO_BSRR = ioremap(<span class="number">0x50002000</span> + <span class="number">0x18</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	led_class = <span class="keyword">class</span><span class="constructor">_create(THIS_MODULE, <span class="string">&quot;myled&quot;</span>)</span>;</span><br><span class="line">	device<span class="constructor">_create(<span class="params">led_class</span>, NULL, MKDEV(<span class="params">major</span>, 0)</span>, NULL, <span class="string">&quot;myled&quot;</span>);<span class="comment">//能创建/led/myled的设备节点</span></span><br><span class="line">	</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit led<span class="constructor">_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	iounmap(RCC_PLL4CR);</span><br><span class="line">	iounmap(RCC_MP_AHB4ENSETR);</span><br><span class="line">	iounmap(GPIO_MODER);</span><br><span class="line">	iounmap(GPIO_BSRR);</span><br><span class="line">	</span><br><span class="line">	device<span class="constructor">_destroy(<span class="params">led_class</span>, MKDEV(<span class="params">major</span>, 0)</span>);</span><br><span class="line">	<span class="keyword">class</span><span class="constructor">_destroy(<span class="params">led_class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	unregister<span class="constructor">_chrdev(<span class="params">major</span>, <span class="string">&quot;100ask_led&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step5:完善函数led_open与led_write。输出电平的步骤：<br>1、使能PLL。翻开手册需要把第一位修改成1，当第二位为1时候代表寄存器稳定。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*RCC_PLL4CR |= (1&lt;&lt;<span class="string">0); </span></span><br><span class="line"><span class="string">while((*RCC_PLL4CR &amp; (1&lt;&lt;1)) == 0</span>);</span><br></pre></td></tr></table></figure>
<p>2、使能GPIO。我们通过RCC_MP_AHB4ENSETR使用GPIO。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">*RCC_MP_AHB4ENSETR <span class="string">|= (1&lt;&lt;0);</span></span><br></pre></td></tr></table></figure>
<img src="/2022/09/22/internship01/led_06.jpg" class="" title="这是一张图片">
<img src="/2022/09/22/internship01/led_06.jpg" class="" title="这是一张图片">
<p>3、由上图可知开发板上2个LED灯用到了PA10和PG8 2个引脚，我们驱动PA10，只需要设置b[21:20]为1就可以配置GPIOA_IO10为输出模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*GPIO_MODER &amp;= ~(3&lt;&lt;<span class="string">20);</span></span><br><span class="line"><span class="string">*GPIO_MODER |= ~(1&lt;&lt;20</span>);</span><br></pre></td></tr></table></figure>
<p>led_open函数就完成了：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> led<span class="constructor">_open(<span class="params">struct</span> <span class="params">inode</span> <span class="operator">*</span><span class="params">inode</span>, <span class="params">struct</span> <span class="params">file</span> <span class="operator">*</span><span class="params">filp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* enable PLL4,it is clock source for all gpio */</span></span><br><span class="line">	*RCC_PLL4CR <span class="pattern-match">|= (1&lt;&lt;0);</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">while</span>((<span class="operator">*</span><span class="constructor">RCC_PLL4CR</span> &amp; (1&lt;&lt;1)) <span class="operator">==</span> 0);</span></span><br><span class="line"><span class="pattern-match">	</span></span><br><span class="line"><span class="pattern-match">	<span class="operator">/</span><span class="operator">*</span> enable gpio <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	<span class="operator">*</span><span class="constructor">RCC_MP_AHB4ENSETR</span> |= (1&lt;&lt;0);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	</span></span><br><span class="line"><span class="pattern-match">	<span class="operator">/</span><span class="operator">*</span> configure pin <span class="keyword">as</span> gpio</span></span><br><span class="line"><span class="pattern-match">	 <span class="operator">*</span> configure gpio <span class="keyword">as</span> output </span></span><br><span class="line"><span class="pattern-match">	 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	 </span></span><br><span class="line"><span class="pattern-match">	<span class="operator">*</span><span class="constructor">GPIO_MODER</span> &amp;= ~(3&lt;&lt;20);</span></span><br><span class="line"><span class="pattern-match">	<span class="operator">*</span><span class="constructor">GPIO_MODER</span> |= ~(1&lt;&lt;20);</span></span><br><span class="line"><span class="pattern-match">	</span></span><br><span class="line"><span class="pattern-match">	return 0;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>4、在led_write设置输出电平，由下图可知只需要操作b[10]与b[26]，写入1&#x2F;0来控制输出高低。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function">			 </span>&#123;</span><br><span class="line">			 	<span class="type">char</span> val;</span><br><span class="line">			 	<span class="comment">/* copy_from_user : get data from app */</span></span><br><span class="line">				<span class="built_in">copy_from_user</span>(&amp;val, buf, <span class="number">1</span>);<span class="comment">//用户空间拷贝到内核空间，拷贝1个字节</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* to set gpio register: out 1/0 */</span></span><br><span class="line">				<span class="keyword">if</span>(val)&#123;</span><br><span class="line">					<span class="comment">/* set gpa10 to let led on */</span></span><br><span class="line">					*GPIO_BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">/* set gpa10 to let led off */</span></span><br><span class="line">					*GPIO_BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br></pre></td></tr></table></figure>
<p>至此，简单的led驱动编程框架就搭好了。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">class</span> *led_class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* register */</span></span><br><span class="line"><span class="comment">//RCC_PLL4CR地址： 0x50000000 + 0x894</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *RCC_PLL4CR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *RCC_MP_AHB4ENSETR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO_MODER 地址： 0x50002000 + 0x00</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO_MODER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO_BSRR 地址： 0x50002000 + 0x18</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO_BSRR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function">			 </span>&#123;</span><br><span class="line">			 	<span class="type">char</span> val;</span><br><span class="line">			 	<span class="comment">/* copy_from_user : get data from app */</span></span><br><span class="line">				<span class="built_in">copy_from_user</span>(&amp;val, buf, <span class="number">1</span>);<span class="comment">//用户空间拷贝到内核空间，拷贝1个字节</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* to set gpio register: out 1/0 */</span></span><br><span class="line">				<span class="keyword">if</span>(val)&#123;</span><br><span class="line">					<span class="comment">/* set gpa10 to let led on */</span></span><br><span class="line">					*GPIO_BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">/* set gpa10 to let led off */</span></span><br><span class="line">					*GPIO_BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* enable PLL4,it is clock source for all gpio */</span></span><br><span class="line">	*RCC_PLL4CR |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>((*RCC_PLL4CR &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* enable gpio */</span></span><br><span class="line">	*RCC_MP_AHB4ENSETR |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* configure pin as gpio</span></span><br><span class="line"><span class="comment">	 * configure gpio as output </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 </span><br><span class="line">	*GPIO_MODER &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line">	*GPIO_MODER |= ~(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> led_fops = &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.write		= led_write,</span><br><span class="line">	.open		= led_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口函数 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">led_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__ , __FUNCTION__,__LINE__);</span><br><span class="line">	major = <span class="built_in">register_chrdev</span>(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_fops);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ioremap(base_phy, size); */</span></span><br><span class="line">	<span class="comment">//RCC_PLL4CR地址： 0x50000000 + 0x894</span></span><br><span class="line">	RCC_PLL4CR = <span class="built_in">ioremap</span>(<span class="number">0x50000000</span> + <span class="number">0x894</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28</span></span><br><span class="line">	RCC_MP_AHB4ENSETR = <span class="built_in">ioremap</span>(<span class="number">0x50000000</span> + <span class="number">0xA28</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//GPIO_MODER 地址： 0x50002000 + 0x00</span></span><br><span class="line">	GPIO_MODER = <span class="built_in">ioremap</span>(<span class="number">0x50002000</span> + <span class="number">0x00</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GPIO_BSRR 地址： 0x50002000 + 0x18</span></span><br><span class="line">	GPIO_BSRR = <span class="built_in">ioremap</span>(<span class="number">0x50002000</span> + <span class="number">0x18</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	led_class = <span class="built_in">class_create</span>(THIS_MODULE, <span class="string">&quot;myled&quot;</span>);</span><br><span class="line">	<span class="built_in">device_create</span>(led_class, <span class="literal">NULL</span>, <span class="built_in">MKDEV</span>(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;myled&quot;</span>);<span class="comment">//能创建/led/myled的设备节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">led_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">iounmap</span>(RCC_PLL4CR);</span><br><span class="line">	<span class="built_in">iounmap</span>(RCC_MP_AHB4ENSETR);</span><br><span class="line">	<span class="built_in">iounmap</span>(GPIO_MODER);</span><br><span class="line">	<span class="built_in">iounmap</span>(GPIO_BSRR);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">device_destroy</span>(led_class, <span class="built_in">MKDEV</span>(major, <span class="number">0</span>));</span><br><span class="line">	<span class="built_in">class_destroy</span>(led_class);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">unregister_chrdev</span>(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(led_init);</span><br><span class="line"><span class="built_in">module_exit</span>(led_exit);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="C-学习"><a href="#C-学习" class="headerlink" title="C++学习"></a>C++学习</h1><h2 id="C-x2F-C-知识"><a href="#C-x2F-C-知识" class="headerlink" title="C&#x2F;C++知识"></a>C&#x2F;C++知识</h2><h3 id="起别名的结构体构造"><a href="#起别名的结构体构造" class="headerlink" title="起别名的结构体构造"></a>起别名的结构体构造</h3><p>typedef  给类型起别名<br>结构体   自定义的类型<br>用法：<br>关键字 名字{}</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种构造方式</span></span><br><span class="line"><span class="keyword">struct</span> student&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> hobby;</span><br><span class="line">&#125;;</span><br><span class="line">typedef student Stu1;<span class="comment">//起别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种构造方式</span></span><br><span class="line">typedef <span class="keyword">struct</span> student&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> hobby;</span><br><span class="line">&#125;Stu2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line">    student zhangsan;</span><br><span class="line">    Stu1 zhangsan1;</span><br><span class="line">    Stu2 zhangsan2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以把student、Stu1和Stu2看成是同一个类型。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>16位操作系统的Int为2字节，32位操作系统int为4个字节，一个字节为8位，一个整型变量在计算机当中其实可以用32位的二进制来表示。<br>A &lt;&lt; B:表示A转化为二进制后，往左移动B位，高位丢弃，低位补0.<br>例：5 &lt;&lt; 1：5转为二进制0101，往左移1位，高位丢弃，低位补0，得1010。<br>A &gt;&gt; B:表示A转化为二进制后，对无符号数，往右移动B位，低位丢弃，高位补0.<br>例：6 &gt;&gt; 1：5转为二进制0110，往左移1位，低位补0，得0011。<br>A &amp; B ：A和B转为二进制，相对应的位如果都是1得1，其余都为0。<br>例：A &#x3D; 5，A二进制位0101，B &#x3D; 6，B二进制位：0110，A &amp; B &#x3D; 0100。<br>A | B ：A和B转为二进制，相对应的位如果有一位为1，那结果为1。<br>例：A &#x3D; 5，A二进制位0101，B &#x3D; 6，B二进制位：0110，A &amp; B &#x3D; 0111。<br>A ^ B ：异或运算符。A和B转为二进制，相对应的位相同结果为1，否则为1。<br>例：A &#x3D; 5，A二进制位0101，B &#x3D; 6，B二进制位：0110，A &amp; B &#x3D; 1100。</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">~<span class="keyword">A</span> ：<span class="keyword">A</span>转为二进制，相对应的位取相反的值。</span><br><span class="line">例：<span class="keyword">A</span> = <span class="number">5</span>，<span class="keyword">A</span>二进制位<span class="number">0101</span>，~<span class="keyword">A</span> = <span class="number">1010</span>。 </span><br></pre></td></tr></table></figure>
<h3 id="static静态"><a href="#static静态" class="headerlink" title="static静态"></a>static静态</h3><p>1、static修饰全局变量，称之为静态全局变量。全局变量可以被一个工程下所有文件所调用，但静态全局变量只能被它所在的文件所调用，工程里其他的文件都不能调用。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int a <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">int main&#123;</span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、static修饰局部变量，称之为静态局部变量。局部变量在函数结束后就会立即销毁，但是静态局部变量会依旧保存这个数，如果静态局部变量所在的函数再一次被调用时，这个静态局部变量的指是上次函数结束前保存的值，而不是函数初始化的那个值，也就是说，静态局部变量只能初始化一次。<br>3、static修饰函数，称之为静态函数，跟静态全局变量一样，函数可以被一个工程下所有文件所调用，但静态函数只能被它所在的文件所调用，工程里其他的文件都不能调用。</p>
<h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>c++函数传递叫值传递和地址传递，在主函数的都是实参，实际的参数，如果只是值传递，传到函数里的就是形参，形参里的a，b在fcn函数里完成了++步骤，但主函数里的a，b是没有任何变化，所以实参和形参是互不受影响。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; a&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">fcn</span>(a,b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/09/22/internship01/cStudy01.jpg" class="" title="这是一张图片">
<p>如果是地址传递，那么主函数的实参是会受到影响。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; a&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">fcn</span>(a,b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/09/22/internship01/cStudy02.jpg" class="" title="这是一张图片">

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数的作用：初始化类对象的数据成员<br>一般分为：无参构造函数、一般构造函数和复制构造函数，这里主要介绍无参构造函数和一般构造函数。<br>无参构造函数顾名思义，没有传入参数的构造器。一般来说创造一个类，如果没写任何构造函数，系统会自动生成一个无参构造器，且函数为空，我们也可以自行编写一个无参构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="type">int</span> m_age;</span><br><span class="line">		<span class="type">int</span> m_score;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">Student</span>()&#123;</span><br><span class="line">			m_age = <span class="number">0</span>;</span><br><span class="line">			m_score = <span class="number">100</span>;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;调用无参构造器&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student xiaoMing;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/09/22/internship01/cStudy03.jpg" class="" title="这是一张图片">
<p>一般构造器的写法为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="type">int</span> m_age;</span><br><span class="line">		<span class="type">int</span> m_score;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">Student</span>(<span class="type">int</span> age,<span class="type">int</span> score):<span class="built_in">m_age</span>(age),<span class="built_in">m_score</span>(score)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;调用Student(int age,int score)一般构造器&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Student</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">			m_age = age;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;调用Student(int age)一般构造器&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">xiaoMing</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">pangHu</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/09/22/internship01/cStudy05.jpg" class="" title="这是一张图片">

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p>在链表类中实现这些功能：<br>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<img src="/2022/09/22/internship01/MyLinkedList01.jpg" class="" title="这是一张图片">
<p>题解：<br>链表由一个个结点串联而成，结点本质上是结构体，这个结构体包含一个数值val和一个指针Next，通过指针Next指向下一个结点，也就是下一个结构体，Next如同一个链子把每个结点链接起来，构成了我们需要的链表<br>结点在C++里表现形式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> LinkedList&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    LinkedList *next;</span><br><span class="line">    <span class="constructor">LinkedList(<span class="params">int</span> <span class="params">val</span>)</span>:<span class="keyword">val</span>(<span class="keyword">val</span>),next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结点创建后，再来实现每个函数。实现函数之前，我们要创建一个虚拟的头结点dummyNode,以及记录长度的数值size</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">LinkedList *dummyNode <span class="operator">=</span> new LinkedList(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">int size <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>①addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>这里用图形化的形式演示一下链表添加操作：</p>
<img src="/2022/09/22/internship01/LinkedList01.jpg" class="" title="这是一张图片">
<p>dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们在头结点插入结点F，得到dummyNode-&gt;F-&gt;A-&gt;C-&gt;D-&gt;E。</p>
<img src="/2022/09/22/internship01/LinkedList02.jpg" class="" title="这是一张图片">
<p>那我们只需要更改dummyNode和F的Next就行了，所以具体代码为：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">void addAtHead(int val) &#123;</span><br><span class="line">    LinkedList <span class="keyword">node</span> <span class="title">= new</span> LinkedList(val);</span><br><span class="line">    <span class="keyword">node</span><span class="title">-&gt;next</span> = dummyNode-&gt;next;</span><br><span class="line">    dummyNode-&gt;next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    size</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>这里用图形化的形式演示一下链表添加操作：</p>
<img src="/2022/09/22/internship01/LinkedList01.jpg" class="" title="这是一张图片">
<p>dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们在D节点之前插入结点F，得到dummyNode-&gt;A-&gt;C-&gt;F-&gt;D-&gt;E。</p>
<img src="/2022/09/22/internship01/LinkedList03.jpg" class="" title="这是一张图片">
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> addAtIndex(<span class="built_in">int</span> <span class="keyword">index</span>,<span class="built_in">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode *node = <span class="keyword">new</span> LinkedNode(val);</span><br><span class="line">    LinkedNode *cur = dummyHeadNode;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">index</span>--)&#123;</span><br><span class="line">        cur = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;<span class="keyword">next</span> =cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">    cur-&gt;<span class="keyword">next</span> = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>这里用图形化的形式演示一下链表添加操作：</p>
<img src="/2022/09/22/internship01/LinkedList01.jpg" class="" title="这是一张图片">
<p>dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们在末端插入结点F，得到dummyNode-&gt;A-&gt;C-&gt;D-&gt;E-&gt;F。</p>
<img src="/2022/09/22/internship01/LinkedList04.jpg" class="" title="这是一张图片">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> addAtTail(<span class="keyword">int</span> val) &#123;</span><br><span class="line">    LinkedNode *node = <span class="keyword">new</span> LinkedNode(val);</span><br><span class="line">    LinkedNode *cur = dummyHeadNode;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;<span class="keyword">next</span> != nullptr)&#123;</span><br><span class="line">        cur = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;<span class="keyword">next</span> = node;</span><br><span class="line">    <span class="keyword">size</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>这里用图形化的形式演示一下链表添加操作：</p>
<img src="/2022/09/22/internship01/LinkedList01.jpg" class="" title="这是一张图片">
<p>dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们想得到dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。</p>
<img src="/2022/09/22/internship01/LinkedList04.jpg" class="" title="这是一张图片">
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> get(<span class="built_in">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">index</span> &lt; <span class="number">0</span> || <span class="keyword">index</span> &gt; size - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode *cur = dummyHeadNode-&gt;<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">index</span>--)&#123;</span><br><span class="line">        cur = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。<br>这里用图形化的形式演示一下链表添加操作：</p>
<img src="/2022/09/22/internship01/LinkedList01.jpg" class="" title="这是一张图片">
<p>dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们删除结点D，得到dummyNode-&gt;A-&gt;C-&gt;E。</p>
<img src="/2022/09/22/internship01/LinkedList05.jpg" class="" title="这是一张图片">
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> deleteAtIndex(<span class="built_in">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">index</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">index</span> &lt; size)&#123;</span><br><span class="line">        LinkedNode *cur = dummyHeadNode;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">index</span>--)&#123;</span><br><span class="line">            cur = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode *temp = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">        cur-&gt;<span class="keyword">next</span> = temp-&gt;<span class="keyword">next</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="研二公司实习"><a href="#研二公司实习" class="headerlink" title="研二公司实习"></a>研二公司实习</h1><h2 id="ros安装"><a href="#ros安装" class="headerlink" title="ros安装"></a>ros安装</h2><p>工控机系统：Ubuntu 18.04<br>安装时间：2022.9.26<br>如果官网与本文代码有区别，请以官网为主。<br>打开两个网站：<br>英文ros官网：<a href="http://wiki.ros.org/melodic/Installation/Ubuntu">http://wiki.ros.org/melodic/Installation/Ubuntu</a><br>中文ros官网：<a href="http://wiki.ros.org/cn/melodic/Installation/Ubuntu">http://wiki.ros.org/cn/melodic/Installation/Ubuntu</a><br>第一步：<br>打开英文ros官网《1.2 Setup your sources.list》的Mirrors，设置我们所需要的镜像源，最好是选择清华源：</p>
<img src="/2022/09/22/internship01/1.2_Setup_sources01.jpg" class="" title="这是一张图片">
<img src="/2022/09/22/internship01/1.2_Setup_sources02.jpg" class="" title="这是一张图片">
<p>在ros终端输入：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;. <span class="string">/etc/lsb-release</span> &amp;&amp; <span class="keyword">echo</span> <span class="string">&quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot;</span> &gt; <span class="string">/etc/apt/sources.list.d/ros-latest.list</span>&#x27;</span><br></pre></td></tr></table></figure>
<p>第二步：<br>打开中文ros官网《1.3 设置密钥》</p>
<img src="/2022/09/22/internship01/1.3_02.jpg" class="" title="这是一张图片">
<p>在ros终端输入：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">apt-key</span> <span class="string">adv</span> <span class="built_in">--keyserver</span> <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> <span class="built_in">--recv-key</span> <span class="string">C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span></span><br></pre></td></tr></table></figure>
<p>第三步：<br>打开英文ros官网《1.4 Installation》，依次在ros端执行：</p>
<img src="/2022/09/22/internship01/1.4Installation.jpg" class="" title="这是一张图片">
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo apt update</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> ros-melodic-desktop</span><br></pre></td></tr></table></figure>
<p>因为对于公司产品Desktop Install已经够用，如果安装Desktop-Full Install比较耗时间。<br>第四步：<br>打开英文ros官网《1.6 Dependencies for building packages》，依次在ros端执行：</p>
<img src="/2022/09/22/internship01/1.6Dependencies.jpg" class="" title="这是一张图片">
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">sudo apt install <span class="keyword">python</span>-rosdep <span class="keyword">python</span>-rosinstall <span class="keyword">python</span>-rosinstall-generator <span class="keyword">python</span>-wstool build-essential</span><br></pre></td></tr></table></figure>
<p>之前装过ros系统，因为安装公司需要的文件会报错，所以重装了一遍ros。第一遍装ros时候是根据GSDN来装遇到的坑挺多的，第二遍按照官网给的流程一路装下来挺顺利（可能第一遍的时候把所有的问题都解决了所以第二遍就顺利很多）。最好是根据官网流程走一遍，遇到网络问题或者部分报错的问题还是可以找GSDN。</p>
<h2 id="ros学习"><a href="#ros学习" class="headerlink" title="ros学习"></a>ros学习</h2><p>ros里的节点，也就是node，相当于一个应用。比如一辆移动机器人，一个node操控底盘轮子的转动，一个node驱动摄像头获取图像，一个node驱动机械臂上的夹爪开合。一个软件包里可以有很多个可执行文件，可执行文件执行后就成了一个进程，这个进程就是node。<br>ros里launch，语法为：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">roslaunch <span class="keyword">package</span> <span class="title">filename.launch</span></span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch beginner_tutorials turtlemimic.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<p>turtlemimic.launch是放在beginner_tutorials包下，turtlemimic.launch文件集成了一堆参数和许多节点。如果一项工程，节点少的话，可以一一启动，但是大项目大工程的时候一个一个节点启动是非常麻烦的，所以只需运行.launch文件可以一键启动多个节点。<br>ros里的topic称之为话题。比如ros里有发布者Publisher和订阅者Subsriber,Publisher与Subsriber之间要负责通信如图</p>
<img src="/2022/09/22/internship01/TopicRos01.jpg" class="" title="这是一张图片">
<p>其中命令rostopic list的作用为能够列出所有当前订阅和发布的话题。<br>rostopic pub -1 topic msg_type args      可以把msg_type里的args数据发布到topic上。<br>rostopic echo &#x2F;topic_name      显示发布到主题的消息。  </p>
<h2 id="实习公司调试室外重载移动车步骤："><a href="#实习公司调试室外重载移动车步骤：" class="headerlink" title="实习公司调试室外重载移动车步骤："></a>实习公司调试室外重载移动车步骤：</h2><p>data：10&#x2F;12<br>基础软件文件下载：<br>Step1：<br>在Windows界面打开gitee网址：<a href="https://gitee.com/dashboard%EF%BC%88%E4%B9%9F%E8%83%BD%E5%9C%A8Ubuntu%E5%86%85%E6%89%93%E5%BC%80%EF%BC%89%EF%BC%8C%E6%90%9C%E7%B4%A2rocr6">https://gitee.com/dashboard（也能在Ubuntu内打开），搜索rocr6</a></p>
<img src="/2022/09/22/internship01/ShenGu_DownLoad01.jpg" class="" title="这是一张图片">
<p>选择第一个</p>
<img src="/2022/09/22/internship01/ShenGu_DownLoad02.jpg" class="" title="这是一张图片">
<p>点进去，再点击zhwl_1981</p>
<img src="/2022/09/22/internship01/ShenGu_DownLoad03.jpg" class="" title="这是一张图片">
<p>点击complex_robot</p>
<img src="/2022/09/22/internship01/ShenGu_DownLoad04.jpg" class="" title="这是一张图片">
<p>Step2：<br>打开ubuntu18.04，在根目录打开终端。</p>
<img src="/2022/09/22/internship01/ShenGu_DownLoad05.jpg" class="" title="这是一张图片">
<p>依次输入Windows界面的gitee里的代码：</p>
<img src="/2022/09/22/internship01/ShenGu_DownLoad06.jpg" class="" title="这是一张图片">
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://gitee.com/zhwl_1981/complex_robot.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> complex_robot</span></span><br></pre></td></tr></table></figure>
<p>Step3：<br>在complex_robot文件下的终端依次输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./installRobot zeus_s2_rocr6_g3p.rosinstall</span><br><span class="line">./installRobot location_navigation.rosinstall</span><br></pre></td></tr></table></figure>
<p>基础软件包都安装完后，开始测试各个装置：夹爪、雷达和机械臂。<br>室外重载夹爪测试：<br>step1：<br>在ubuntu终端运行</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch g3p_driver hw_link.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<p>step2：<br>启动另外一个终端输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rostopic list</span></span><br></pre></td></tr></table></figure>
<p>显示</p>
<img src="/2022/09/22/internship01/ShenGu_DownLoad07.jpg" class="" title="这是一张图片">
<p>g3p话题为&#x2F;g3p_msgs&#x2F;gripper<br>继续输入：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">rostopic pub -<span class="number">1</span> <span class="regexp">/g3p_msgs/g</span>ripper</span><br></pre></td></tr></table></figure>
<p>连续按两次TAB键补全信息 ，把后面的state:0.0改成state:1.回车后夹爪就会启动。<br>室外重载激光雷达测试：<br>在此目录下打开终端，运行</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch zeus_s2_bringup rplidar_ros.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<p>运行没有报错，而且激光雷达也正在转，说明测试成功。<br>如果想看的更清楚就在根目录下进入话题</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rostopic list</span></span><br></pre></td></tr></table></figure>
<p>雷达话题为&#x2F;scan，然后输入以下命令并回车执行</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rviz</span></span><br></pre></td></tr></table></figure>
<p>在此界面添加激光雷达LaserScan，话题引入&#x2F;scan，Global Options里的Fixed Frame为Laser。<br>室外重载视觉抓取演示：<br>在linux的根目录下输入指令：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">./deepvision.sh</span><br><span class="line">roslaunch scene_tasks rocr6_pick_place.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<p>输入后在手柄上依次摁下a和y就能直接驱动机械臂抓取果实。<br>如果单独控制机械臂的话输入</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">rostopic pub -<span class="number">1</span> <span class="regexp">/rocr6_msgs/g</span>oal_rocr6_msgs/Goal <span class="string">&quot;&#123;cmd: 0, a1: 0.0, a2: 0.0, a3: 0.0, a4: 0.0, a5: 0.0, a6: 0.0,&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中a1~a6后面均为机械臂的弧度，如果想手动调整机械臂输入弧度即可。<br>室外重载导航演示：<br>Step1:建图<br>1、正常开机后，打开终端，输入roslaunch rplidar_ros rplidar_a3.launch，用于启动激光雷达；<br>2、新开一个终端，cd到google_ws文件夹下，输入roslaunch cartographer_ros backpack_2d.launch，启动建图程序；<br>3、新开一个终端，输入rviz，在打开的界面上添加&#x2F;map话题的接收显示，即可在rviz的界面上查看实时的建图效果。<br>4、使用手柄控制小车在待建图的区域行走，行走过程要平稳，不要突然停止和急转弯，以免影响建图效果。<br>5、行走结束后，在home文件下打开终端，输入命令 .&#x2F;savemap.sh 保存地图。可以在home文件夹下看到三个以.pbstream、.pgm和.yaml结尾的文件。关掉之前运行的rviz和roslaunch cartographer_ros backpack_2d.launch，打开以.yaml结尾的文件把&#x2F;home&#x2F;nvidia&#x2F;给删去保存。然后把.pgm和.yaml结尾的文件放在&#x2F;catkin_ws&#x2F;src&#x2F;slam_navigation&#x2F;control&#x2F;map下，两个文件名字改成hdmap.pgm和hdmap.yaml，进入hdmap.yaml把image的参数修改为hdmap.pgm。至此，建图完成。<br>Step2:发送导航相关指令<br>1、开启终端，输入指令：输入roslaunch rplidar_ros rplidar_a3.launch，启动激光雷达；（建图没关的话可以不用输入这指令）<br>2、新开终端，输入指令：roslaunch relocalization relocalization.launch, 开启定位程序。<br>3、新开终端，输入指令：roslaunch control control.launch,开启坐标变换程序。<br>4、新开终端，输入指令：rviz，点击左上角file,Home目录下的1.rviz文件。<br>5、新开终端，输入指令：roslaunch control move_base.launch，启动导航控制。<br>6、进入&#x2F;catkin_ws&#x2F;src&#x2F;slam_navigation&#x2F;zeus_s2_navigation&#x2F;scene&#x2F;param文件夹。打开points.yaml，修改点的数量以及位置。<br>7、新开终端，输入指令：roslaunch scene start.launch，启动任务。<br>8、此时导航程序已经全部启动，使用遥控手柄，再按B和Y键，小车即可进行自主导航。<br>注意事项：<br>建图过程中车需要慢慢开，尽量把地图周围扫面全面，方便后期导航能精准。</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="电脑卸载旧matlab产生的问题"><a href="#电脑卸载旧matlab产生的问题" class="headerlink" title="电脑卸载旧matlab产生的问题"></a>电脑卸载旧matlab产生的问题</h2><p>我电脑是装了matlab2018b和2020b，今天把2018b卸载后打开m代码是以Notepad++方式打开，在属性更改打开方式matlab2020b后，打开方式绑定的是[matlab starter application]。虽然打开m代码是2020b的界面，但每次打开新的m代码，就会新打开一个matlab程序。问题应该就是 [.m] 文件关联的是 [matlab starter application]，这应该就是导致双击 [.m] 文件新开 matlab 的原因。<br>解决方法：<br>Step1 打开网站：<br><a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/51165-matlab-file-association-shortcut-fix">https://ww2.mathworks.cn/matlabcentral/fileexchange/51165-matlab-file-association-shortcut-fix</a><br>下载此压缩包并解压</p>
<img src="/2022/09/22/internship01/OtherQuestion01.jpg" class="" title="这是一张图片">
<img src="/2022/09/22/internship01/OtherQuestion02.jpg" class="" title="这是一张图片">
<p>Step2 使用MATLAB运行associateFiles.m文件<br>Step3 然后会得到一个MatlabFileAssocFix.reg<br>Step4 运行MatlabFileAssocFix.reg注册文件并按确定<br>Step5 运行matlabshortcuts.bat<br>Step6 运行runmatlab.bat<br>完成后，文件关联问题应该得到了修复。</p>
<h2 id="matlab代码乱码问题"><a href="#matlab代码乱码问题" class="headerlink" title="matlab代码乱码问题"></a>matlab代码乱码问题</h2><p>m文件用Microsoft VS Code，点击右下角“UTF-8”</p>
<img src="/2022/09/22/internship01/OtherQuestion03.jpg" class="" title="这是一张图片">
<p>中间上方会出现两种选择，点击“通过编码重新打开”</p>
<img src="/2022/09/22/internship01/OtherQuestion04.jpg" class="" title="这是一张图片">
<p>搜索GBK，点击保存即可</p>
<img src="/2022/09/22/internship01/OtherQuestion05.jpg" class="" title="这是一张图片">

]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>公司实习</tag>
      </tags>
  </entry>
  <entry>
    <title>fourth Study Record of internship</title>
    <url>/2023/01/02/internship04/</url>
    <content><![CDATA[<p>2023-1-31 ~ 2023-02-28</p>
<span id="more"></span>
<h1 id="嵌入式学习"><a href="#嵌入式学习" class="headerlink" title="嵌入式学习"></a>嵌入式学习</h1><h2 id="ubuntu操作学习"><a href="#ubuntu操作学习" class="headerlink" title="ubuntu操作学习"></a>ubuntu操作学习</h2><p>文件压缩zip格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zip</span> -vr 文件名字.<span class="built_in">zip</span> 需要压缩的文件</span><br></pre></td></tr></table></figure>
<p>linux通过指令断开与某个wifi的连接</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmcli</span> c del <span class="number">72</span>ffd5f4-<span class="number">71</span>f8-<span class="number">0001</span>-b434-<span class="number">6122908</span>cfd4e</span><br></pre></td></tr></table></figure>
<p>del 后边是UUID号码</p>
<h1 id="leetCode刷题"><a href="#leetCode刷题" class="headerlink" title="leetCode刷题"></a>leetCode刷题</h1><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<img src="/2023/01/02/internship04/leetCode206.jpg" class="" title="这是一张图片">
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> *next;</span><br><span class="line"> *     <span class="type">ListNode</span><span class="literal">()</span> : <span class="keyword">val</span>(<span class="number">0</span>), next(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x, <span class="type">ListNode</span> *next) : <span class="keyword">val</span>(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">ListNode</span>* reverseList(<span class="type">ListNode</span>* head) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; tmp(<span class="number">5000</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">int</span> nums = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span>* cur = <span class="keyword">new</span> <span class="type">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        cur -&gt; next = head;</span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; next)&#123;</span><br><span class="line">            nums++;</span><br><span class="line">            tmp[nums] = cur-&gt; next-&gt;<span class="keyword">val</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = nums -<span class="number">1</span>;</span><br><span class="line">        head = cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = nums;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">ListNode</span>* mcur = <span class="keyword">new</span> <span class="type">ListNode</span>(tmp[i]);</span><br><span class="line">            cur-&gt;next = mcur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<img src="/2023/01/02/internship04/leetCode24.jpg" class="" title="这是一张图片">
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* tmp = NULL;</span><br><span class="line">        ListNode* pre = NULL;</span><br><span class="line">        ListNode* tmp2 = NULL;</span><br><span class="line">        ListNode* <span class="keyword">real</span> = new ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* realtmp = <span class="keyword">real</span>;</span><br><span class="line">        int i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != NULL)&#123;</span><br><span class="line">            <span class="function"><span class="title">tmp</span> = cur-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">cur</span>-&gt;</span>next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; cur == NULL)&#123;</span><br><span class="line">                <span class="function"><span class="title">realtmp</span>-&gt;</span>next = pre;</span><br><span class="line">                <span class="function"><span class="title">return</span> <span class="keyword">real</span>-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="function"><span class="title">realtmp</span>-&gt;</span>next = pre;</span><br><span class="line">                <span class="function"><span class="title">realtmp</span> = realtmp-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                pre = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">return</span> <span class="keyword">real</span>-&gt;</span>next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<img src="/2023/01/02/internship04/leetCode19.jpg" class="" title="这是一张图片">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* tmp;</span><br><span class="line">        ListNode* pre = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            tmp = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">            cur-&gt;<span class="keyword">next</span> = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            cur = pre-&gt;<span class="keyword">next</span>;</span><br><span class="line">            pre = <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = pre;</span><br><span class="line">            n = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;<span class="keyword">next</span> = cur-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            tmp = cur-&gt;<span class="keyword">next</span>;</span><br><span class="line">            cur-&gt;<span class="keyword">next</span> = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="02-07-链表相交"><a href="#02-07-链表相交" class="headerlink" title="02.07. 链表相交"></a>02.07. 链表相交</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<img src="/2023/01/02/internship04/leetCode0207.jpg" class="" title="这是一张图片">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        ListNode* cur1 = headA;</span><br><span class="line">        <span class="keyword">int</span> numA = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur2 = headB;</span><br><span class="line">        <span class="keyword">int</span> numB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1)&#123;</span><br><span class="line">            numA++;</span><br><span class="line">            cur1= cur1-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2)&#123;</span><br><span class="line">            numB++;</span><br><span class="line">            cur2= cur2-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(numA &gt; numB)&#123;</span><br><span class="line">            numA = numA-numB;</span><br><span class="line">            <span class="keyword">while</span>(numA--)&#123;</span><br><span class="line">                cur1 = cur1-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            numB = numB-numA;</span><br><span class="line">            <span class="keyword">while</span>(numB--)&#123;</span><br><span class="line">                cur2 = cur2-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp =<span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2 &amp;&amp; tmp == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">                tmp = cur1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur1 != cur2)&#123;</span><br><span class="line">                tmp = <span class="keyword">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1-&gt;<span class="keyword">next</span>;</span><br><span class="line">            cur2 = cur2-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<img src="/2023/01/02/internship04/leetCode142.jpg" class="" title="这是一张图片">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode* virtualNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        virtualNode-&gt;<span class="keyword">next</span> = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slowIndex = virtualNode;</span><br><span class="line">        ListNode* fastIndex = virtualNode;</span><br><span class="line">        <span class="keyword">while</span>((slowIndex != fastIndex &amp;&amp; fastIndex != <span class="keyword">NULL</span>)|| (slowIndex == fastIndex &amp;&amp; fastIndex ==virtualNode))&#123;</span><br><span class="line">            slowIndex = slowIndex-&gt;<span class="keyword">next</span>;</span><br><span class="line">            fastIndex = fastIndex-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(fastIndex != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">                fastIndex = fastIndex-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fastIndex ==<span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fastIndex = virtualNode;</span><br><span class="line">        <span class="keyword">while</span>(slowIndex != fastIndex)&#123;</span><br><span class="line">            slowIndex = slowIndex-&gt;<span class="keyword">next</span>;</span><br><span class="line">            fastIndex = fastIndex-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastIndex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<img src="/2023/01/02/internship04/leetCode242.jpg" class="" title="这是一张图片">
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">isAnagram</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> t</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> hash1[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">int</span> hash2[<span class="number">26</span>];</span><br><span class="line">        memset(hash1,<span class="number">0</span>,<span class="keyword">sizeof</span>(hash1));</span><br><span class="line">        memset(hash2,<span class="number">0</span>,<span class="keyword">sizeof</span>(hash2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            hash1[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            hash2[t[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash1[i] != hash2[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<img src="/2023/01/02/internship04/leetCode349.jpg" class="" title="这是一张图片">
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">1001</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">1001</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hash1[nums1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hash2[nums2[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(min(nums1.size(),nums2.size()),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">sizeof</span>(hash1) / <span class="built_in">sizeof</span>(hash1[<span class="number">0</span>]);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash1[i] != <span class="number">0</span> &amp;&amp; hash2[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                ret[j] = i;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = ret.<span class="built_in">size</span>() - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ret[j] == <span class="number">-1</span>)&#123;</span><br><span class="line">                ret.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」 定义为：<br>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false </p>
<img src="/2023/01/02/internship04/leetCode202.jpg" class="" title="这是一张图片">
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> getSum(<span class="built_in">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">sum</span> += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        unordered_set&lt;<span class="built_in">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">sum</span> = getSum(n);</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="keyword">count</span>(<span class="keyword">sum</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(<span class="keyword">sum</span>);</span><br><span class="line">            n = <span class="keyword">sum</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p>
<img src="/2023/01/02/internship04/leetCode1.jpg" class="" title="这是一张图片">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = s.<span class="built_in">find</span>(target - nums[i]); </span><br><span class="line">            <span class="keyword">if</span>(iter != s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454.四数相加 II"></a>454.四数相加 II</h2><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：<br>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</p>
<img src="/2023/01/02/internship04/leetCode454.jpg" class="" title="这是一张图片">
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i :nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums2)&#123;</span><br><span class="line">                map[i + j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i :nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">find</span>(<span class="number">0</span> - (i + j)) != map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    ret += map[<span class="number">0</span> - (i + j)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。<br>如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<img src="/2023/01/02/internship04/leetCode383.jpg" class="" title="这是一张图片">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hashRansomNote</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hashMagazine</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ransomNote.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hashRansomNote[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; magazine.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hashMagazine[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashRansomNote[i] &gt; hashMagazine[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<img src="/2023/01/02/internship04/leetCode344.jpg" class="" title="这是一张图片">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = s.<span class="built_in">size</span>() - <span class="number">1</span>;j &gt; i;i++,j--)&#123;</span><br><span class="line">            <span class="type">char</span> tmp = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a>541. 反转字符串 II</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<img src="/2023/01/02/internship04/leetCode541.jpg" class="" title="这是一张图片">
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">int</span> k</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> nums1 = s.size() / (<span class="number">2</span> * k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; nums1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i * <span class="number">2</span> * k,m = k - <span class="number">1</span> + j;j &lt; m;j++,m--)&#123;</span><br><span class="line">                <span class="built_in">char</span> tmp = s[j];</span><br><span class="line">                s[j] = s[m];</span><br><span class="line">                s[m] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> nums2 = s.size() - nums1 * <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span>(nums2 &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = nums1 * <span class="number">2</span> * k,j = nums1 * <span class="number">2</span> * k + k - <span class="number">1</span>;j &gt; i;i++,j--)&#123;</span><br><span class="line">                <span class="built_in">char</span> tmp = s[i];</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">                s[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = nums1 * <span class="number">2</span> * k,j = s.size() - <span class="number">1</span>;j &gt; i;i++,j--)&#123;</span><br><span class="line">                <span class="built_in">char</span> tmp = s[i];</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">                s[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<img src="/2023/01/02/internship04/leetCodeJianZhiOffer05.jpg" class="" title="这是一张图片">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sSize = s.<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sSize;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.resize(sSize + <span class="keyword">count</span> * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> leftPoint = sSize - <span class="number">1</span>,rightPoint = s.<span class="keyword">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftPoint &lt; rightPoint)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[leftPoint] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[rightPoint--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[rightPoint--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[rightPoint] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[rightPoint] = s[leftPoint];</span><br><span class="line">            &#125;</span><br><span class="line">            rightPoint--;</span><br><span class="line">            <span class="keyword">if</span>(leftPoint != <span class="number">0</span>)&#123;</span><br><span class="line">                leftPoint--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<img src="/2023/01/02/internship04/leetCode151.jpg" class="" title="这是一张图片">
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void delete<span class="constructor">Space(<span class="params">string</span>&amp; <span class="params">s</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; s.size<span class="literal">()</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s<span class="literal">[<span class="identifier">i</span>]</span> != <span class="character">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(slow != <span class="number">0</span>)&#123;</span><br><span class="line">                    s<span class="literal">[<span class="identifier">slow</span><span class="operator">++</span>]</span> = <span class="character">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size<span class="literal">()</span>&amp;&amp;s<span class="literal">[<span class="identifier">i</span>]</span> != <span class="character">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    s<span class="literal">[<span class="identifier">slow</span><span class="operator">++</span>]</span> = s<span class="literal">[<span class="identifier">i</span><span class="operator">++</span>]</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.resize(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    void all<span class="constructor">Reserve(<span class="params">string</span>&amp; <span class="params">s</span>,<span class="params">int</span> <span class="params">begin</span>,<span class="params">int</span> <span class="params">end</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="keyword">begin</span>,j = <span class="keyword">end</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">            <span class="built_in">char</span> temp = s<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">            s<span class="literal">[<span class="identifier">i</span>]</span> = s<span class="literal">[<span class="identifier">j</span>]</span>;</span><br><span class="line">            s<span class="literal">[<span class="identifier">j</span>]</span> = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> reverse<span class="constructor">Words(<span class="params">string</span> <span class="params">s</span>)</span> &#123;</span><br><span class="line">        delete<span class="constructor">Space(<span class="params">s</span>)</span>;</span><br><span class="line">        all<span class="constructor">Reserve(<span class="params">s</span> , 0, <span class="params">s</span>.<span class="params">size</span>()</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; s.size<span class="literal">()</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s<span class="literal">[<span class="identifier">fast</span>]</span> != <span class="character">&#x27; &#x27;</span>&amp;&amp; fast &lt; s.size<span class="literal">()</span>)&#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            all<span class="constructor">Reserve(<span class="params">s</span>, <span class="params">i</span>, <span class="params">fast</span> - 1)</span>;</span><br><span class="line">            i = fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="研二公司实习"><a href="#研二公司实习" class="headerlink" title="研二公司实习"></a>研二公司实习</h1><h2 id="DH参数与m代码仿真"><a href="#DH参数与m代码仿真" class="headerlink" title="DH参数与m代码仿真"></a>DH参数与m代码仿真</h2><p>双臂运动学是在单臂的基础上建立的，所以前期分析先对单个机械臂进行DH建模。<br>标准DH</p>
<h3 id="确定每个连杆的固连坐标系"><a href="#确定每个连杆的固连坐标系" class="headerlink" title="确定每个连杆的固连坐标系"></a>确定每个连杆的固连坐标系</h3><img src="/2023/01/02/internship04/DH01.jpg" class="" title="这是一张图片">
<p>由图已知每个连杆都是以连杆的后一个关节坐标系为固连坐标系。<br>首先建立z轴。在DH中，只需要建立X与Z轴即可。如果是关节是旋转的，z轴位于按右手定则选装的方向，如果关节是滑动的，z轴为沿实现运动的方向。根据这一原则则每个关节的z轴都能直接确定。</p>
<img src="/2023/01/02/internship04/DH02.jpg" class="" title="这是一张图片">
<p>然后确定X轴。第一个固连坐标系X轴可以任意确定；其他固连坐标系的X轴需要垂直于在同一固连坐标系的z轴与上一个固连坐标系z轴，比如x1，必须垂直于z0和z1。x4垂直于z3和z4。</p>
<img src="/2023/01/02/internship04/DH03.jpg" class="" title="这是一张图片">
<h3 id="自定义一个世界坐标系"><a href="#自定义一个世界坐标系" class="headerlink" title="自定义一个世界坐标系"></a>自定义一个世界坐标系</h3><img src="/2023/01/02/internship04/DH04.jpg" class="" title="这是一张图片">
<h3 id="确定每个参数"><a href="#确定每个参数" class="headerlink" title="确定每个参数"></a>确定每个参数</h3><p>标准DH先变化X轴然后变化Z轴。变化X轴先旋转角度theata，然后平移d距离；变化z轴先平移a距离，然后旋转α。根据这一思路我们从世界坐标开始推导。<br>Base-0世界坐标到0（属于基座，没有关节变量）<br>变化x：变化x轴的意思是我们要使x轴与x0重合。绕z轴右手定则旋转90°，平移距离暂定为0，。Theata&#x3D;pi&#x2F;2，d&#x3D;0.<br>变化z：变化z轴的意思是我们要使z轴与z0重合。平移距离暂定为0，绕x0轴右手定则旋转90°。 a&#x3D;0，α&#x3D;pi&#x2F;2。<br>0-1<br>变化x0：变化x0轴的意思是我们要使x0轴与x1重合。绕z0轴右手定则旋转90°，平移距离暂定为0，。Theata&#x3D;pi&#x2F;2，关节变量d1初始值为0.<br>变化z0：变化z0轴的意思是我们要使z0轴与z1重合。平移距离暂定为0，绕x1轴右手定则旋转90°。 a&#x3D;0，α&#x3D;pi&#x2F;2。<br>1-2<br>变化x1：绕z1轴右手定则旋转90°，平移距离暂定为0。Theata&#x3D;pi&#x2F;2，关节变量d2初始值为0.<br>变化z1：平移距离暂定为0，绕x2轴右手定则旋转90°。 a&#x3D;0，α&#x3D;pi&#x2F;2。<br>2-3<br>变化x2：绕z2轴右手定则旋转90°，平移距离暂定为0。Theata&#x3D;pi&#x2F;2，关节变量d3初始值为0.<br>变化z2：平移距离暂定为5，绕x3轴右手定则旋转0°。 a&#x3D;5，α&#x3D;0。<br>3-4<br>变化x3：绕z3轴右手定则旋转-90°，平移距离暂定为5。d&#x3D;5，关节变量theata4初始值为-90°。也就是m代码中offset为-pi&#x2F;2。<br>变化z3：平移距离暂定为0，绕x4轴右手定则旋转-90°。 a&#x3D;0，α&#x3D;-pi&#x2F;2。</p>
<img src="/2023/01/02/internship04/DH05.jpg" class="" title="这是一张图片">
<p>在matlab俯视图中可以看到建模仿真</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line">%%Link函数:创建机械臂对象</span><br><span class="line">%输入参数顺序分别为：关节角、连杆偏距、连杆长度、连杆转角</span><br><span class="line">Lbase=<span class="constructor">Link(&#x27;<span class="params">theta</span>&#x27;,<span class="params">pi</span><span class="operator">/</span>2,&#x27;<span class="params">a</span>&#x27;,0,&#x27;<span class="params">alpha</span>&#x27;,<span class="params">pi</span><span class="operator">/</span>2,&#x27;<span class="params">qlim</span>&#x27;,[5 5],&#x27;<span class="params">standard</span>&#x27;)</span>;%基座不用管</span><br><span class="line">L1=<span class="constructor">Link(&#x27;<span class="params">theta</span>&#x27;,<span class="params">pi</span><span class="operator">/</span>2,&#x27;<span class="params">a</span>&#x27;,0,&#x27;<span class="params">alpha</span>&#x27;,<span class="params">pi</span><span class="operator">/</span>2,&#x27;<span class="params">qlim</span>&#x27;,[0 100],&#x27;<span class="params">offset</span>&#x27;,10,&#x27;<span class="params">standard</span>&#x27;)</span>; </span><br><span class="line">L2=<span class="constructor">Link(&#x27;<span class="params">theta</span>&#x27;,<span class="params">pi</span><span class="operator">/</span>2,&#x27;<span class="params">a</span>&#x27;,0,&#x27;<span class="params">alpha</span>&#x27;,<span class="params">pi</span><span class="operator">/</span>2,&#x27;<span class="params">qlim</span>&#x27;,[0 100],&#x27;<span class="params">offset</span>&#x27;,10,&#x27;<span class="params">standard</span>&#x27;)</span>;</span><br><span class="line">L3=<span class="constructor">Link(&#x27;<span class="params">theta</span>&#x27;,1<span class="operator">/</span>2<span class="operator">*</span><span class="params">pi</span>,&#x27;<span class="params">a</span>&#x27;,5,&#x27;<span class="params">alpha</span>&#x27;,0,&#x27;<span class="params">qlim</span>&#x27;,[0 100],&#x27;<span class="params">offset</span>&#x27;,10,&#x27;<span class="params">standard</span>&#x27;)</span>;</span><br><span class="line">L4=<span class="constructor">Link(&#x27;<span class="params">d</span>&#x27;,5,&#x27;<span class="params">a</span>&#x27;,0,&#x27;<span class="params">alpha</span>&#x27;,-<span class="params">pi</span><span class="operator">/</span>2,&#x27;<span class="params">qlim</span>&#x27;,[-<span class="params">pi</span> <span class="params">pi</span>],&#x27;<span class="params">offset</span>&#x27;,-1<span class="operator">/</span>2<span class="operator">*</span><span class="params">pi</span>,&#x27;<span class="params">standard</span>&#x27;)</span>;</span><br><span class="line">%Ltool=<span class="constructor">Link(&#x27;<span class="params">theta</span>&#x27;,0,&#x27;<span class="params">a</span>&#x27;,0,&#x27;<span class="params">alpha</span>&#x27;,0,&#x27;<span class="params">qlim</span>&#x27;,[10 10],&#x27;<span class="params">standard</span>&#x27;)</span>;</span><br><span class="line">HuaJRobot = <span class="constructor">SerialLink([Lbase,L1,L2,L3,L4],&#x27;<span class="params">name</span>&#x27;,&#x27;HuaJRobot&#x27;)</span>;</span><br><span class="line">Q=<span class="literal">[<span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span>; %<span class="number">2.</span>gif末端点</span><br><span class="line">%绘图</span><br><span class="line">W=<span class="literal">[-<span class="number">40</span> +<span class="number">40</span>  -<span class="number">40</span> +<span class="number">40</span> -<span class="number">40</span> +<span class="number">40</span>]</span>; %工作空间</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">HuaJRobot</span>.</span></span>teach(Q,&#x27;floorlevel&#x27;,-<span class="number">1</span>,&#x27;perspective<span class="character">&#x27;,&#x27;</span>scale&#x27;, <span class="number">0.05</span>,&#x27;noarrow<span class="character">&#x27;,&#x27;</span>workspace&#x27;,W); </span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/internship04/DH06.jpg" class="" title="这是一张图片">
<h2 id="进阶版装ROS"><a href="#进阶版装ROS" class="headerlink" title="进阶版装ROS"></a>进阶版装ROS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x ros_install.sh</span><br><span class="line">./ros_install.sh  </span><br></pre></td></tr></table></figure>
<p>其中ros_install.sh里的内容为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install ros-melodic-desktop    -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br><span class="line"></span><br><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; . fishros </span><br><span class="line"></span><br><span class="line">rosdepc update</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>输入3</p>
<img src="/2023/01/02/internship04/rosInstall.jpg" class="" title="这是一张图片">

<h2 id="刚在虚拟机安装ubuntu系统后需执行的操作"><a href="#刚在虚拟机安装ubuntu系统后需执行的操作" class="headerlink" title="刚在虚拟机安装ubuntu系统后需执行的操作"></a>刚在虚拟机安装ubuntu系统后需执行的操作</h2><p>1.刚映射ios文件时网络连接为主机模式，ubuntu系统安装后需改成桥接模式。<br>2.安装VMware tools</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install <span class="keyword">open</span>-<span class="keyword">vm</span>-tools-desktop</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="关于Gazebo安装"><a href="#关于Gazebo安装" class="headerlink" title="关于Gazebo安装"></a>关于Gazebo安装</h2><p>环境为Ubuntu18.04，ros版本为melodic<br>先在终端输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gazebo</span></span><br></pre></td></tr></table></figure>
<p>如果无法运行，则下载gazebo即可</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> gazebo9</span><br><span class="line">sudo apt <span class="keyword">install</span> libgazebo9-dev</span><br></pre></td></tr></table></figure>
<p>如果运行gazebo出现这样的错误</p>
<img src="/2023/01/02/internship04/RosGazebo01.jpg" class="" title="这是一张图片">
<p>解决方法：<br>终端输入</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">sudo gedit ~<span class="regexp">/.ignition/</span>fuel/config.yaml</span><br></pre></td></tr></table></figure>
<p>文本编辑</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">将   url : https:<span class="regexp">//</span>api.ignitionfuel.org   用 <span class="comment"># 注释掉</span></span><br><span class="line">添加 url: https:<span class="regexp">//</span>api.ignitionrobotics.org  </span><br></pre></td></tr></table></figure>

<h2 id="ROS中使用gazebo-ros的spawn-model时，显示-spawn-model-4-process-has-died"><a href="#ROS中使用gazebo-ros的spawn-model时，显示-spawn-model-4-process-has-died" class="headerlink" title="ROS中使用gazebo_ros的spawn_model时，显示[spawn_model-4] process has died"></a>ROS中使用gazebo_ros的spawn_model时，显示[spawn_model-4] process has died</h2><p>问题描述：输入rosrun gazebo_ros spawn_model -urdf -model car -param robot_description出现错误</p>
<img src="/2023/01/02/internship04/RosGazebo02.jpg" class="" title="这是一张图片">
<p>解决方案：找到上面出现的&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;xml&#x2F;etree&#x2F;ElementTree.py文件，用我之前博客的方法，加入以下代码</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">reload</span><span class="params">(sys)</span></span> </span><br><span class="line">sys<span class="selector-class">.setdefaultencoding</span>(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/internship04/RosGazebo03.jpg" class="" title="这是一张图片">
<p>即可正常运行</p>
<img src="/2023/01/02/internship04/RosGazebo04.jpg" class="" title="这是一张图片">


]]></content>
      <categories>
        <category>嵌入式</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>公司实习</tag>
      </tags>
  </entry>
</search>
