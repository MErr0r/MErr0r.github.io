{"meta":{"title":"MErr0rのBlog","subtitle":"I turn the page to drown you out","description":"合工大研究僧","author":"MErr0r","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-04-20T05:00:03.000Z","updated":"2022-04-20T05:01:05.337Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"record","date":"2022-04-18T08:38:21.000Z","updated":"2022-04-18T08:38:21.627Z","comments":true,"path":"record/index.html","permalink":"http://example.com/record/index.html","excerpt":"","text":""},{"title":"special","date":"2022-04-18T08:38:31.000Z","updated":"2022-04-18T08:38:31.743Z","comments":true,"path":"special/index.html","permalink":"http://example.com/special/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-19T00:30:08.000Z","updated":"2022-04-20T04:57:59.765Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"First learning record","slug":"record01","date":"2022-04-23T16:00:00.000Z","updated":"2022-04-24T05:19:30.989Z","comments":true,"path":"2022/04/24/record01/","link":"","permalink":"http://example.com/2022/04/24/record01/","excerpt":"分享第一周学习内容","text":"分享第一周学习内容 leetcode 热题HOT 1001.两数相加给定一个整数数组nums和一个整数目标值target请你在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; a; vector&lt;int&gt; b(2,-1); for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; &#125;&#125;; 通常的作法为逐步尝试，首先第一个加第二个，再第一个加第三个……思路虽然简单暴力但运行速度慢且内存空间消耗大此代码采用的 开始逐行分析与知识点回顾 1map&lt;int,int&gt; a; //创建名为a的map容器，key与val的类型均为int 回顾map容器的相关知识： 1.map容器里的数值都是pair—&gt;成对出现 分别为键值key与实值val 2.我们可以通过key的索引查到对应的val 3.map不允许有重复的键值key存在 3.所有元素都会根据你所存的键值key进行自动排序 4.其中&lt;int,int&gt; 左边int代表key的类型为int 右边的int代表val为int 作用为：存储nums里的元素 1vector&lt;int&gt; b(2,-1);//创建名为b的vector容器，2代表初始长度，里面的值均为-1，存储nums里能满足target的两个值 回顾vector容器的相关知识： 1.与数组结构非常相似，与数组不同点在于数组是静态，而vector是动态扩展 12for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); 涉及到的知识： 1.nums.size()表示的是整数数组nums的长度 2.a.insert是调用map容器里的函数insert：在map中插入元素 3.map&lt;int,int&gt;::value_type：令元素的类型为map中含有key与val的pair类型 4.map&lt;int,int&gt;::mapped_type：令元素的类型为map中的val类型 5.map&lt;int,int&gt;::key_type：令元素的类型为map中的key类型 所以 我们把nums里的元素分别以key-val的pair形式传到名为a的map容器里 12345678for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; 涉及到的知识： 1.map容器的函数count(key)：如果key键值存在，则返回1，否则返回0 思路：通过target依次减去nums[i]，得到的结果通过count函数搜索是否存在于名为a的map容器中。且通过&amp;&amp;算法来满足“同一个元素在答案里不能重复出现”这一条件。if条件满足后，则赋予名为b的vector容器，最后返回b容器 2.两数相加给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* H = new ListNode(); ListNode* ptr = H; int carry = 0; while(l1 || l2 || carry)&#123; int val = 0; if(l1) val += l1-&gt;val,l1 = l1-&gt;next; if(l2) val += l2-&gt;val,l2 = l2-&gt;next; val +=carry; ListNode* node = new ListNode(val % 10); ptr-&gt;next = node; ptr = node; carry = val / 10; &#125; return H-&gt;next; &#125;&#125;; 开始逐行分析与知识点回顾 创建链表的详细过程 1.链表的概念 通过一组任意的存储单元来存储线性表中的数据元素，有一个个结点组成。 2.节点(Node)的框架 1234struct ListNode&#123; int data; ListNode* next;&#125;; 节点分为头节点和首元节点 a.头节点 设置链表前会额外增设一个节点，该节点一般不存放数据。好处是可以使问题简单化。对于链表来讲，不一定非得增设头节点。 b.首元节点 头节点后边的第一个节点，也是链表中的第一个节点。 节点包括数据data和指针Next a.指针的概念 指针是一个变量，存储另一个变量的地址 123int a = 10;int* p;//定义指针的格式为 数据类型* 指针变量名字p = &amp;a;//&amp;代表取址符号 b.结构体指针 12345678910111213#include &lt;iostream&gt;struct student&#123; string name; int age;&#125;//创建一个结构体int main()&#123; 1.创建结构体变量 student s =&#123;&quot;haha&quot;,18&#125;; 2.通过指针指向结构体变量 student* p = &amp;s;//p的类型必须跟s一致 3.指针访问结构体变量中的数据 cout &lt;&lt; p-&gt;name;//通过-&gt;访问结构体里的数据&#125; 结点的框架图： 创建链表的流程： 123456789101112131415161718192021222324#include &lt;iostream&gt;/*创建一个链表*/struct ListNode&#123; int data; ListNode* next;&#125;;void createList(ListNode* pHead)&#123; ListNode* p = pHead; for(int i = 0;i &lt; 10;i++)&#123; ListNode* pNewNode = new ListNode; pNewNode-&gt;data = i; pNewNode-&gt;next = NULL; p-&gt;next = pNewNode; p = pNewNode; &#125;&#125;int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 现来逐个分析 1234567int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 首先在main函数创建一个名为head的指针结构体变量，在这我们可以把head看成头节点，分配相应内存和初始化成员后如下图所示 把head指针代入函数createList，开始创建链表 12void createList(ListNode* pHead)&#123; ListNode* p = pHead; 创造p节点，令结构体指针p等于pHead，此时p的地址与pHead的地址一样，对p操作就是对pHead操作，所以p也是头节点。 12345 for(int i = 0;i &lt; 10;i++)&#123; //i = 0 ListNode* pNewNode = new ListNode; &#125;&#125; 进入for循环，处于i&#x3D;0时。在堆区new一个新内存，存放pNewNode。作为中间结构体为存放新节点提供过渡。 a.new的相关知识 new返回的使 该数据类型的指针 1234int* func()&#123; int* p = new int(10); return p;&#125; b.内存四区 程序运行前： 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 程序运行后： 堆区：堆区的数据由程序员开辟，程序员管理使用(delete) 栈区：栈区的数据由系统分配，一般存放函数的参数以及局部变量。函数执行完，栈区的数据都会自动释放。 指针本质是局部变量，放在栈上，但指针保存的数据使放在堆区。 回到链表创建上来 123//i = 0pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;0时，在pNewNode里存放数据 12//i = 0p-&gt;next = pNewNode; 头节点p指向我们的创建的链表的第一个节点 i&#x3D;0下的pNewNode，i&#x3D;0下的pNewNode也称之为首元节点。 12//i = 0p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与pHead没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们进入下一个循环 1234//i = 1ListNode* pNewNode = new ListNode;pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;1时，在pNewNode里存放数据 12//i = 1p-&gt;next = pNewNode; 节点p指向我们的创建的链表的第一个节点 i&#x3D;1下的pNewNode 12//i = 1p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与i&#x3D;0下的pNewNode没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们的创建链表的详细过程就结束了，回到LeetCode题上。 123ListNode* H = new ListNode();ListNode* ptr = H;int carry = 0; H为定义的头节点，ptr是中间节点，H存放的地址与ptr存放的地址一致。carry为进位数 1while(l1 || l2 || carry)&#123; 个人的看法只要当l1 l2的val为0(结构体里的data)及carry为0，才返回false，其他情况一律为true。 123if(l1) val += l1-&gt;val,l1 = l1-&gt;next;if(l2) val += l2-&gt;val,l2 = l2-&gt;next;val +=carry; 当l1不为0是 执行if语句 val为l1链表的第一个数字，l1从第一个链表转换成l1的第二个链表第二行代码同理carry是进位制 1ListNode* node = new ListNode(val % 10); 创建新链表的第一个节点，存储的数据为 val除以10的余数 123ptr-&gt;next = node;ptr = node;carry = val / 10; 因为node存放的数据是我们想要的数据，所以利用ptr的next指针即H的next指针指向node节点，ptr切断与H的联系，令ptr与node指向同一块内存，手法跟创建链表一样。通过相除判断carry是否进1位。 1return H-&gt;next; H为头节点，头节点下一个next才是链表中的节点。 Conclusion第一次写博客，刚开始上手不是很熟悉，所以暂时就写了这周学的LeetCode。下次尝试把参与的项目学到的知识分享在博客中。暂定每周日更新博客，如果有研究僧考试那就咕咕咕~See you next week","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"http://example.com/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]},{"title":"test4.21","slug":"test4-21","date":"2022-04-21T10:33:41.000Z","updated":"2022-04-21T10:37:49.830Z","comments":true,"path":"2022/04/21/test4-21/","link":"","permalink":"http://example.com/2022/04/21/test4-21/","excerpt":"hahya哈哈哈","text":"hahya哈哈哈哈哈哈","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://example.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://example.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-17T10:54:08.712Z","updated":"2022-04-21T10:49:59.004Z","comments":true,"path":"2022/04/17/hello-world/","link":"","permalink":"http://example.com/2022/04/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"http://example.com/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"},{"name":"导航","slug":"导航","permalink":"http://example.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://example.com/tags/%E5%88%86%E4%BA%AB/"}]}