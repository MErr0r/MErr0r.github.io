{"meta":{"title":"MErr0rのBlog","subtitle":"I turn the page to drown you out","description":"合工大研究僧","author":"MErr0r","url":"https://merr0r.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-04-20T05:00:03.000Z","updated":"2022-04-20T05:01:05.337Z","comments":true,"path":"categories/index.html","permalink":"https://merr0r.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-19T00:30:08.000Z","updated":"2022-04-20T04:57:59.765Z","comments":true,"path":"tags/index.html","permalink":"https://merr0r.github.io/tags/index.html","excerpt":"","text":""},{"title":"record","date":"2022-04-18T08:38:21.000Z","updated":"2022-04-18T08:38:21.627Z","comments":true,"path":"record/index.html","permalink":"https://merr0r.github.io/record/index.html","excerpt":"","text":""},{"title":"special","date":"2022-04-18T08:38:31.000Z","updated":"2022-04-18T08:38:31.743Z","comments":true,"path":"special/index.html","permalink":"https://merr0r.github.io/special/index.html","excerpt":"","text":""}],"posts":[{"title":"First learning record in June","slug":"record06","date":"2022-05-31T16:00:00.000Z","updated":"2022-06-05T12:17:15.337Z","comments":true,"path":"2022/06/01/record06/","link":"","permalink":"https://merr0r.github.io/2022/06/01/record06/","excerpt":"分享六月第一周学习内容","text":"分享六月第一周学习内容 二叉树入门学习144. 二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的前序遍历。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root == NULL)&#123; return result; &#125; st.push(root); while(!st.empty())&#123; TreeNode* node = st.top(); st.pop(); result.push_back(node -&gt; val); if(node-&gt;right) st.push(node-&gt;right); if(node-&gt;left) st.push(node-&gt;left); &#125; return result; &#125;&#125;; 145. 二叉树的后序遍历给你二叉树的根节点 root ，返回它节点值的后序遍历。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root == NULL)&#123; return result; &#125; st.push(root); while(!st.empty())&#123; TreeNode* node = st.top(); st.pop(); result.push_back(node -&gt; val); if(node-&gt;left) st.push(node-&gt;left); if(node-&gt;right) st.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 94. 二叉树的中序遍历给你二叉树的根节点 root ，返回它节点值的中序遍历。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while(cur != NULL || !st.empty())&#123; if(cur != NULL)&#123; st.push(cur); cur = cur-&gt;left; &#125;else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return result; &#125;&#125;; 为了方便理解，放c++环境中进行测试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;vector&gt;#include&lt;iostream&gt;#include &lt;stack&gt;using namespace std;struct treeNode &#123; //树的结点 char data; //保存数据 treeNode *left; //左子树 treeNode *right; //右子树&#125;;//创建树struct treeNode* createNode(char data) &#123; struct treeNode* newNode = (struct treeNode*)malloc(sizeof(struct treeNode)); newNode-&gt;data = data; newNode-&gt;left = NULL; newNode-&gt;right = NULL; return newNode;&#125;//连接结点void insertNode(struct treeNode* curNode, struct treeNode* leftNode, struct treeNode* rightNode) &#123; curNode-&gt;left = leftNode; curNode-&gt;right = rightNode;&#125;//中序遍历vector&lt;char&gt; iNorderTraversal(treeNode* root) &#123; vector&lt;char&gt; result; stack&lt;treeNode*&gt; st; treeNode* cur = root; while (cur != NULL || !st.empty()) &#123; if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left; &#125; else &#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; &#125; return result;&#125;int main() &#123; //创建所有的结点 struct treeNode* A = createNode(&#x27;A&#x27;); struct treeNode* B = createNode(&#x27;B&#x27;); struct treeNode* C = createNode(&#x27;C&#x27;); struct treeNode* D = createNode(&#x27;D&#x27;); struct treeNode* E = createNode(&#x27;E&#x27;); struct treeNode* F = createNode(&#x27;F&#x27;); struct treeNode* G = createNode(&#x27;G&#x27;); struct treeNode* K = createNode(&#x27;K&#x27;); //做连接操作 insertNode(A, B, C); insertNode(B, D, E); insertNode(C, F, G); insertNode(F, NULL, K); vector&lt;char&gt; result1 = iNorderTraversal(A); for (int i = 0; i&lt;result1.size(); ++i) &#123; cout &lt;&lt; result1[i] &lt;&lt; &quot; &quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 我们通过insertNode和createNode创建如图所示的树 直接从iNorderTraversal的while循环开始：第一次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第二次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第三次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第四次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; 第五次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; 第六次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第七次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; 第八次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; …………后面跟前面一样就不再赘述了~ 94. 二叉树的中序遍历(统一迭代法)给你二叉树的根节点 root ，返回它节点值的中序遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root != NULL)&#123; st.push(root); &#125; while(!st.empty())&#123; TreeNode* node = st.top(); if(node != NULL)&#123; st.pop(); if(node -&gt; right)&#123; st.push(node -&gt; right); &#125; st.push(node); st.push(NULL); if(node -&gt; left)&#123; st.push(node -&gt; left); &#125; &#125;else&#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;; 94. 二叉树的前序遍历(统一迭代法)给你二叉树的根节点 root ，返回它节点值的前序遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root != NULL)&#123; st.push(root); &#125; while(!st.empty())&#123; TreeNode* node = st.top(); if(node != NULL)&#123; st.pop(); if(node-&gt;right)&#123; st.push(node-&gt;right); &#125; if(node-&gt;left)&#123; st.push(node-&gt;left); &#125; st.push(node); st.push(NULL); &#125;else&#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Third learning record in May","slug":"record05","date":"2022-05-29T16:00:00.000Z","updated":"2022-05-30T01:32:54.853Z","comments":true,"path":"2022/05/30/record05/","link":"","permalink":"https://merr0r.github.io/2022/05/30/record05/","excerpt":"分享五月第三周学习内容","text":"分享五月第三周学习内容 动态规划入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 322. 零钱兑换给你一个整数数组coins，表示不同面额的硬币；以及一个整数amount，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1 。你可以认为每种硬币的数量是无限的。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1,INT_MAX); dp[0] = 0; for(int i = 1;i &lt;= amount;i++)&#123; for(int j = 0;j &lt; coins.size();j++)&#123; if(coins[j] &lt;= i &amp;&amp; dp[i - coins[j]] != INT_MAX) &#123; dp[i] = min(dp[i],dp[i - coins[j]] + 1); &#125; &#125; &#125; if(dp[amount] == INT_MAX)&#123; return -1; &#125; return dp[amount]; &#125;&#125;; 整体分析：把不同面额的硬币视为物品，面额视为物品的重量，总金额amount视为背包重量。本题要求的是最少的银币个数，所以要求的不是“组合”个数，而是“物品个数”，因此并不是“组合”问题。而且每种硬币的数量是无限的，所以是“完全背包”问题。1.确定dp数组(dp table)以及下标的含义因为这里只有一个限制条件，即背包重量，所以dp肯定是一维。所以dp[i]的含义为：重量为i的背包能容纳最少的物品数量&lt;&#x3D;&gt;凑成总金额为i的最少银币个数。2.确认状态转移方程，即递推公式本题求的是最少的“物品个数”，所以dp[i] &#x3D; min(dp[i],dp[i - coins[j]] + 1)3.dp数组如何初始化首先dp[0] &#x3D; 0，因为面额为0个数也为0.但dp其他数字默认为0，那么在min(dp[i],dp[i - coins[j]] + 1)就一直为0，所以我们因把dp其他数字初始化为INT_MAX。4.遍历顺序的确定这题涉及的是完全背包的问题。完全背包的背包遍历顺序是从前往后遍历。物品由前往后遍历即可。5.推导整个dp数组 279. 完全平方数给你一个整数n，返回和为n的完全平方数的最少数量。完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和16都是完全平方数，而3和11不是。 先贴出答案，然后一步步讲解。 123456789101112131415class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1,INT_MAX); dp[0]=0; for(int i = 1;i*i&lt;= n;i++)&#123; for(int j = 0;j &lt;= n;j++)&#123; if(j - i*i &gt;= 0)&#123; dp[j] = min(dp[j],dp[j-i*i] + 1); &#125; &#125; &#125; return dp[n]; &#125;&#125;; 整体分析：整数n视为背包最大重量为n，完全平方数为物品的重量，且不限制数量，因此为“完全背包”问题。1.确定dp数组(dp table)以及下标的含义因为这里只有一个限制条件，即背包重量，所以dp肯定是一维。所以dp[i]的含义为：重量为i的背包能容纳最少的物品数量&lt;&#x3D;&gt;整数i最少能划分完全平方数的个数。2.确认状态转移方程，即递推公式dp[j] &#x3D; min(dp[j],dp[j-ii] + 1);3.dp数组如何初始化首先dp[0] &#x3D; 0，因为整数0最少能划分完全平方数的个数也为0.但dp其他数字默认为0，那么在min(dp[j],dp[j-ii] + 1)就一直为0，所以我们因把dp其他数字初始化为INT_MAX。4.遍历顺序的确定这题涉及的是完全背包的问题。完全背包的背包遍历顺序是从前往后遍历。物品由前往后遍历即可。5.推导整个dp数组 139. 单词拆分给你一个字符串s和一个字符串列表wordDict作为字典。请你判断是否可以利用字典中出现的单词拼接出s。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 先贴出答案，然后一步步讲解。 123456789101112131415161718class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); int m = s.length(); vector&lt;bool&gt; dp(m + 1,false); dp[0] = true; for(int i = 1;i &lt;= m;i++)&#123; for(int j = 0;j &lt; i;j++)&#123; string word = s.substr( j , i - j ); if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]) &#123; dp[i] = true; &#125; &#125; &#125; return dp[m]; &#125;&#125;; 整体分析：字符串s为背包，字典里的字符串为物品。本题跟之前的题不同，以往的题要么求“最大重量”要么是“组合数量”，他们的“限制条件”我们直接无脑堆物品就完事了。但这题的“限制条件”不允许我们无脑堆物品，而是只允许“符合条件的物品”。“限制条件”比以前更严格，但思路依旧能用借鉴以前的题。假设整个字符串s为dp，背包从0开始，先搜索dp第一个字符，相当于dp里有两个指针，左指针j在0，右指针i在1，说明我们要确定从字典里的字符是否匹配得上指针j到i里的字符，指针里的字符数量逐渐递减，即左指针j右移。如果有匹配的字符，则右指针返回一个true。之和我们的左指针j在0，右指针i在2，判断字典里的字符是否匹配得上指针j到i里的字符，如果有匹配的字符，且左指针j是true即左指针j之前的字符串都能从字典里匹配到相应的字符串，则右指针返回一个true。1.确定dp数组(dp table)以及下标的含义dp类型为bool，dp[i]表示字符串前i个字符是否能匹配上。2.确认状态转移方程，即递推公式如果指针里的字符能匹配到字典里的字符且左指针为true，那么右指针为true。dp[i] &#x3D; true;3.dp数组如何初始化当字符串s啥也没有的时候，那一定为true。所以dp[0] &#x3D; true;其他都为false4.遍历顺序的确定因为字典里的字符串能重复使用，所以类似于“完全背包”问题，所以字典里的字符串从前往后遍历。5.推导整个dp数组 leetcode 热题HOT 10010. 正则表达式匹配给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘‘ 的正则表达式匹配。‘.’ 匹配任意单个字符‘‘ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 先贴出答案，然后一步步讲解。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); dp[0][0] = true; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[0][j] = dp[0][j-1]; &#125;else if(j + 1 &gt; n || p[j + 1] != &#x27;*&#x27;)&#123; break; &#125;else&#123; dp[0][j] = true; &#125; &#125; for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1]; continue; &#125; if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1] || (dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])) || (dp[i - 1][j] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])); &#125;else&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 这题运用到了动态规划的知识。首先对整体进行分析：一个字符串 s 与一个字符规律 p 相匹配，我们首先在s和p字符最前面添加一个‘0’字符，为了之后能很好的描述此题。比如s第i个字符不再是s[i - 1]而是s[i]。 123456789class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); &#125;&#125;; 如果s选取前i个字符能与p前j个字符相匹配，而且本题的函数类型为bool。于是我们可以令dp[i][j]为：s前i个字符能与p前j个字符相匹配。我们把框架写下： 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); return dp[m][n]; &#125;&#125;; 接下来讨论状态方程。先理解题意。“ ‘*’ 匹配零个或多个前面的那一个元素 ”说明 *跟前面一个字符是绑定在一起，比如a *,要么是0个a，要么是1个a，要么是好几个a。因为当我们讨论s前i个字符能与否p前j个字符相匹配时，还得看p的第j+1字符是否为’ * ‘。不考虑’.’。当p的第j个字符为英文小写，先判断p的第j+1字符是否为’ * ‘。如果不是或者是超过字符串p的最长长度，说明p的第j个字符是独立的，不与第j+1字符绑定。我们想判断dp[i][j]是否为true，只需判断s的第i个字符与p的第j个字符相等以及之前的字符能匹配得上，这里就发生了“状态转移”。 123if(j + 1 &gt; n || p[j + 1] != &#x27;*&#x27;)&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; ( s[i] == p[j]);&#125; 当p的第j个字符为英文小写，且p的第j+1字符为’ * ‘。说明p的第j个字符与第j+1字符是绑定在一起的，于是我们把第j个字符与第j+1个字符看成一个整体A。所以这里分三种情况，这个整体A视为没有第j字符、一个第j字符和多个第j字符。当s的第i个字符不等于p的第j个字符时，如要满足题意，这个整体A需视为没有第j字符。即 123if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1];&#125; 当s的第i个字符等于p的第j个字符时，且s的第i个字符与相邻的字符不重复，整体A视为一个第j字符，即 123if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i] == p[j])&#125; 当s的第i个字符等于p的第j个字符时，且s的第i个字符与相邻的字符有重复，整体A视为多第j字符，即 123if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i - 1][j] &amp;&amp; (s[i] == p[j]);&#125; 当p的第j个字符为’ * ‘。因为’ * ‘都会跟前一个字符绑定，所以当前状态因与第j-1字符状态一样。即 123if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1];&#125; 考虑’.’的情况。只要出现’.’，就相当于“s[i] &#x3D;&#x3D; p[j]”。所以在之前的状态转移补充一个或条件即可。 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1]; continue; &#125; if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1] || (dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])) || (dp[i - 1][j] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])); &#125;else&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 接下来讨论初始化问题。首先当s的第0个字符与p的第0个字符毫无疑问是相同的。所以dp[0][0]&#x3D;true。另外得考虑一个极端情况，比如s字符串为空串，而p字符和a* b* c，因为a可以视为空串，所以这种情况也是符合的。所以 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); dp[0][0] = true; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[0][j] = dp[0][j-1]; &#125;else if(j + 1 &gt; n || p[j + 1] != &#x27;*&#x27;)&#123; break; &#125;else&#123; dp[0][j] = true; &#125; &#125; for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1]; continue; &#125; if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1] || (dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])) || (dp[i - 1][j] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])); &#125;else&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 二叉树入门学习一棵树是一些节点(node)的集合。可以为空集，如果不是空集，则树由根节点以及0个或多个子树组成，根节点没有前驱结点。 图中根节点就是没有父结点的结点，叶子结点就是没有子节点的结点。 下面介绍一些与树相关的概念（以上面的树为例）：（1）结点的度：一个节点含有的子树的个数称为该节点的度；如上图：A的为6，即B、C、D、E、F、G。（2）叶结点：度为0的节点称为叶结点；如上图：B、C、H、I…等为叶结点。（3）双亲结点或父结点：若一个节点含有子结点，则这个结点称为其子结点的父结点；如上图：A是B的父结点。（4）孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；如上图：B是A的孩子节点。（5）兄弟结点：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点。（6）树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6。（7）结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。（8）树的高度或深度：树中结点的最大层次； 如上图：树的高度为4。（9）节点的祖先：从根到某一结点所经分支上的所有结点；如上图：D、A是H的祖先；A是所有结点的公共祖先。（10）子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙。（11）森林：多棵互不相交的树的集合称为森林。 二叉树的储存方式为链式存储。 因此代码可编写为： 123456struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; 比如我们想创建如下图这样的一棵树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct treeNode &#123; //树的结点 char data; //保存数据 treeNode *left; //左子树 treeNode *right; //右子树&#125;;//1.创建树struct treeNode* createNode(char data) &#123; struct treeNode* newNode = (struct treeNode*)malloc(sizeof(struct treeNode)); newNode-&gt;data = data; newNode-&gt;left = NULL; newNode-&gt;right = NULL; return newNode;&#125;//2.连接结点void insertNode(struct treeNode* curNode, struct treeNode* leftNode, struct treeNode* rightNode) &#123; curNode-&gt;left = leftNode; curNode-&gt;right = rightNode;&#125;//3.递归中序遍历void printData(struct treeNode* curNode) &#123; printf(&quot;%c&quot;, curNode-&gt;data);&#125;void midOrder(struct treeNode* tree) &#123; if (tree != NULL) &#123; midOrder(tree-&gt;left); //左 printData(tree); //根 midOrder(tree-&gt;right); //右 &#125;&#125;//4.递归前序遍历void preOrder(struct treeNode* tree) &#123; if (tree != NULL) &#123; printData(tree); //根 preOrder(tree-&gt;left); //左 preOrder(tree-&gt;right); //右 &#125;&#125;//5.递归后序遍历void lastOrder(struct treeNode* tree) &#123; if (tree != NULL) &#123; lastOrder(tree-&gt;left); //左 lastOrder(tree-&gt;right); //右 printData(tree); //根 &#125;&#125;//6.非遍历的方式void midOrderByStact(struct treeNode* tree) &#123; if (tree == NULL) &#123; return; &#125; struct treeNode* stack[10]; int stackTop = -1; struct treeNode* pMove = tree; while (stackTop != -1 || pMove != NULL) &#123; while (pMove != NULL) &#123; stack[++stackTop] = pMove; pMove = pMove-&gt;left; &#125; if (stackTop != -1) &#123; pMove = stack[stackTop--]; printf(&quot;%c\\t&quot;, pMove-&gt;data); pMove = pMove-&gt;right; &#125; &#125;&#125;int main() &#123; //1.创建所有的结点 struct treeNode* A = createNode(&#x27;A&#x27;); struct treeNode* B = createNode(&#x27;B&#x27;); struct treeNode* C = createNode(&#x27;C&#x27;); struct treeNode* D = createNode(&#x27;D&#x27;); struct treeNode* E = createNode(&#x27;E&#x27;); struct treeNode* F = createNode(&#x27;F&#x27;); struct treeNode* G = createNode(&#x27;G&#x27;); struct treeNode* K = createNode(&#x27;K&#x27;); //做连接操作 insertNode(A, B, C); insertNode(B, D, E); insertNode(C, F, G); insertNode(F, NULL, K); midOrder(A); printf(&quot;\\n&quot;); lastOrder(A); printf(&quot;\\n&quot;); preOrder(A); printf(&quot;\\n&quot;); midOrderByStact(A); printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 接下来对此树进行遍历。遍历顺序分为前序遍历、中序遍历和后序遍历。前序遍历： 中 左 右中序遍历： 左 中 右后序遍历： 左 右 中对于上题来说前序遍历： ABDECFKG中序遍历： DBEAFKCG后序遍历： DEBKFGCA3、4、5用了递归的思想。6非遍历的方式用了栈的思路，即先进后出。 1234567891011121314151617181920void midOrderByStact(struct treeNode* tree) &#123; if (tree == NULL) &#123; return; &#125; //先判断是否是空树 struct treeNode* stack[10]; //初始化一个栈 int stackTop = -1; //入栈一个元素 struct treeNode* pMove = tree; //定义一个指针，初始指向树的根节点 while (stackTop != -1 || pMove != NULL) &#123; while (pMove != NULL) &#123; stack[++stackTop] = pMove; pMove = pMove-&gt;left; &#125; //遍历到树的最左边 if (stackTop != -1) &#123; pMove = stack[stackTop--]; printf(&quot;%c\\t&quot;, pMove-&gt;data); //输出pMove指向的结点数据 pMove = pMove-&gt;right; //遍历右边 &#125; &#125;&#125; 144. 二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的前序遍历。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; traversal(root,result); return result; &#125; void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec)&#123; if(node == NULL)&#123; return; &#125; vec.push_back(node-&gt;val); traversal(node-&gt;left,vec); traversal(node-&gt;right,vec); &#125;&#125;; 145. 二叉树的后序遍历给你二叉树的根节点 root ，返回它节点值的后序遍历。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; vec; traversal(root,vec); return vec; &#125; void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec)&#123; if(node == NULL)&#123; return; &#125; traversal(node-&gt;left,vec); traversal(node-&gt;right,vec); vec.push_back(node-&gt;val); &#125;&#125;; 94. 二叉树的中序遍历给你二叉树的根节点 root ，返回它节点值的中序遍历。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; vec; traversal(root,vec); return vec; &#125; void traversal(TreeNode* root,vector&lt;int&gt;&amp; vec)&#123; if( root == NULL)&#123; return; &#125; traversal(root-&gt;left,vec); vec.push_back(root-&gt;val); traversal(root-&gt;right,vec); &#125;&#125;;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Second learning record in May","slug":"record04","date":"2022-05-14T16:00:00.000Z","updated":"2022-05-16T01:33:16.484Z","comments":true,"path":"2022/05/15/record04/","link":"","permalink":"https://merr0r.github.io/2022/05/15/record04/","excerpt":"分享五月第二周学习内容","text":"分享五月第二周学习内容 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 1049. 最后一块石头的重量 II有一堆石头，用整数数组stones表示。其中 stones[i] 表示第i块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x &lt;&#x3D; y。那么粉碎的可能结果如下：如果x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；如果x !&#x3D; y，那么重量为x的石头将会完全粉碎，而重量为y的石头新重量为y-x。最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回0。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; vector&lt;int&gt; dp(15001,0); int sum = 0; for(int i = 0;i &lt; stones.size();i++)&#123; sum += stones[i]; &#125; int target = sum / 2; for(int i = 0;i &lt; stones.size();i++)&#123; for(int j = target;j &gt;= stones[i];j--)&#123; dp[j] = max(dp[j],dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[target] - dp[target]; &#125;&#125;; dp的含义？这题跟上周写的“分割等和子集”类似，只不过换了种表达方式。“石头碰撞后最小重量”可以翻译为：石头分为两个背包，两个背包的和尽可能相近，最好相等。所以dp跟“分割等和子集”类似。在“分割等和子集”理，dp[j]的含义为背包重量为j时能容量最大的数字和。所以在这题可以理解为背包重量之和为j时能能容量最大的数字和dp来源？“分割等和子集”的dp[j]来源为dp[j]自身的重量与dp[j-nums[i]]+nums[i]的最大值。因此本题的dp来源为 dp[j]与dp[j - stones[i]] + stones[i]的最大值。dp的初始化？默认为0。遍历顺序？石头的选择从头开始遍历到最后，背包的重量从最大开始遍历。 494. 目标和给你一个整数数组nums和一个整数target。向数组中的每个整数前添加’+’或’-‘，然后串联起所有整数，可以构造一个表达式：例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式”+2-1” 。返回可以通过上述方法构造的、运算结果等于target的不同表达式的数目。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int m = nums.size(); int sums = 0; for(int i = 0;i &lt; m;i++)&#123; sums += nums[i]; &#125; if(target &gt; sums)&#123; return 0; &#125; if((target + sums) % 2 == 1 || (target + sums) &lt; 0)&#123; return 0; &#125; int targetBag = (sums + target) / 2; vector&lt;int&gt; dp(targetBag + 1,0); dp[0] = 1; for(int i = 0;i &lt; m;i++)&#123; for(int j = targetBag;j &gt;= nums[i];j--)&#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[targetBag]; &#125;&#125;; 1.确定dp数组(dp table)以及下标的含义本题比较特殊，之前求的要么是背包的最大重量要么是背包里的物品的最大价值。但本题求的是不同表达式的组合数目，但思路还是能借鉴。比如之前的dp都是求最大物品重量，那么我们把这题分成两个背包，一个背包数字和为A，另一个背包数字和为B。A+B&#x3D;整数数组nums所有元素之和，A-B为target。所以我们只要讨论A和B其中一个背包，另一个背包也就直接出来。我们这里讨论A背包。dp[j]理解为当A背包里的数字和j时的不同组合方式最多为dp[j]种。2.确认状态转移方程，即递推公式模仿之前的题，我们的dp[j]的来源就为dp[j]本身与dp[j - nums[i]]的最大值，但这种方法是求最大“重量数”，而我们要求的是最大的“组合数”。打个比方：5的的组合方法有很多：1+4，2+3,3+2,4+1。当1为已知时，我们就得确认4的组合方法数量。当2为已知时，我们就得确认3的组合方法数量。当3为已知时，我们就得确认2的组合方法数量……所以5的最大组合方法数量为1+4，2+3,3+2,4+1的最大组合数之和，所以我们dp来源应该是某种数量的叠加。继续打比方：5的的组合方法有很多，但物品栏只有1和3，因此我们只需探求1和3时候的最大组合数量。即当1为已知时，我们就得确认4的组合方法数量。当3为已知时，我们就得确认2的组合方法数量，5的最大组合数量应为1+4,3+2的最大组合数之和。所以dp[j]的来源应为dp[j]+dp[j - nums[i]]。3.dp数组如何初始化因为dp[j]的来源应为dp[j]与dp[j - nums[i]]叠加，所以如果令dp[0]初始值为0，那后面的叠加全是0。然后根据我们对题目的分析，如果target为0的话也就是j&#x3D;0，那我们dp[0]初始值为1？说实话，在[代码随想录].pdf的解释为“装满容量为0的背包，有1种⽅法，就是装0件物品。”我觉得还是有点牵强，但我也不晓得如何解释(恼火)。4.遍历顺序的确定首先确定dp的末端数字，我们已经整数数组nums和一个整数target，我们可以根据一个背包数字和为A，另一个背包数字和为B。A+B&#x3D;整数数组nums所有元素之和，A-B为target得到(A的大小为nums所有元素之和+target)&#x2F;2，物品(nums元素)从头遍历，背包从end开始往前遍历。5.推导整个dp数组 474. 一和零给你一个二进制字符串数组strs和两个整数m和n。请你找出并返回strs的最大子集的长度，该子集中最多有m个0和n个1。如果x的所有元素也是y的元素，集合x是集合y的子集。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; getZeroOnes(string&amp; str)&#123; vector&lt;int&gt; zeroOnes(2,0); for(int i = 0;i&lt;str.length();i++)&#123; zeroOnes[str[i]-&#x27;0&#x27;]++; &#125; return zeroOnes; &#125; int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int l = 0;l &lt; strs.size();l++)&#123; vector&lt;int&gt; zero0nes = getZeroOnes(strs[l]); for(int i = m;i&gt;=zero0nes[0];i--)&#123; for(int j = n;j&gt;=zero0nes[1];j--)&#123; dp[i][j] = max(dp[i][j],dp[i - zero0nes[0]][j - zero0nes[1]] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 这题首先算出字符串数组strs里各个元素所含的0和1的个数，通过getZeroOnes函数，构建一个1x2向量，向量第0个位置代表0的数量，向量第1个位置代表1的数量。利用str[i]-‘0’的特性实现对元素含有1和0个数的计算。1.确定dp数组(dp table)以及下标的含义本题要求所选的元素的0和1个数和分别小于m和n，其实可以看做背包装一个物品，0的个数代表物品重量，1的个数代表物品价值。这个物品既要满足重量小于m，又要满足价值小于n。相比以往的题目即重量小于背包重量，价值取最大。多了一个限制条件。因此我们要在以往的题型基础上进行一个改进。以往对于只有一个条件即重量小于背包重量我们可以列dp[i][j]，又能dp[j]，我们一般采用后者，即dp[j]。现在多了一个条件即价值小于n，所以我们在这采用dp[i][j]。含义为0的个数最多为i，1的个数最多为j时，能在字符串数组sts中最多能挑选的元素个数为l。2.确认状态转移方程，即递推公式dp[i][j]的最大值要么来源于上次循环保留下来的dp[i][j]或者i&gt;&#x3D;zero0nes[0],j&gt;&#x3D;zero0nes[1]时，计算dp[i-zero0nes[0]][j - zero0nes[1]]的元素个数，再+1。即dp[i][j] &#x3D; max(dp[i][j],dp[i - zero0nes[0]][j - zero0nes[1]] + 1)。3.dp数组如何初始化再以往的题即“重量小于背包重量，价值取最大”中，一维数组dp默认为0.这题虽然有两个限制条件，但内核跟以往的题一模一样。所以同理，此题的初始化应全为0。4.遍历顺序的确定再以往的题即“重量小于背包重量，价值取最大”中，一维数组dp都是从后往前遍历，本题也如此，两个条件从后往前遍历。5.推导整个dp数组 完全背包有N件物品和⼀个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品都有⽆限个（也就是可以放⼊背包多次），求解将哪些物品装⼊背包⾥物品价值总和最⼤。先贴出答案，然后一步步讲解。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble2() &#123; vector&lt;int&gt; weight = &#123; 1 , 3 , 4 &#125;; vector&lt;int&gt; value = &#123; 15 , 20, 30 &#125;; int bagweight = 4; vector&lt;int&gt; dp1(bagweight + 1, 0); for (int i = 0; i &lt; weight.size(); i++) &#123; for (int j = bagweight; j &gt;= weight[i]; j--) &#123; int we = j / weight[i]; dp1[j] = max(dp1[j], dp1[j - weight[i]*we] + value[i] * we); &#125; &#125; cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble2(); system(&quot;pause&quot;); return 0;&#125;\\\\本人写的 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble2() &#123; vector&lt;int&gt; weight = &#123; 1 , 3 , 4 &#125;; vector&lt;int&gt; value = &#123; 15 , 20, 30 &#125;; int bagweight = 4; vector&lt;int&gt; dp1(bagweight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) &#123; for(int j = weight[i]; j &lt;= bagweight; j++) &#123; dp1[j] = max(dp1[j], dp1[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble2(); system(&quot;pause&quot;); return 0;&#125;\\\\代码随想录上的 此题为[代码随想录].pdf上的一道完全背包题目，所以运行环境不在LeetCode上而是在VS studio上。1.确定dp数组(dp table)以及下标的含义完全背包跟之前的背包不同，之前的背包有物品数量限制，但是完全背包是没有物品数量限制，也就是说可以同样的物品可以重复叠加。虽然有所区别，但原理还是一样。dp[j]意为背包重量为j时的最大价值。2.确认状态转移方程，即递推公式dp[j]来源于上一个循环的dp[j]与j&gt;&#x3D;weight[i]时 dp[j - weight[i]] + value[i]。3.dp数组如何初始化背包初始价值全部为0即可。4.遍历顺序的确定之前我们限制物品数量时都是从后往前遍历的。现在没有了物品数量限制，直接从前往后遍历，从前往后遍历能使同样的物品放在重量为j的背包中重复叠加。5.推导整个dp数组 518.零钱兑换 II给你一个整数数组coins表示不同面额的硬币，另给一个整数amount表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回0。假设每一种面额的硬币有无限个。 题目数据保证结果符合32位带符号整数。 先贴出答案，然后一步步讲解。 12345678910111213class Solution &#123;public: int change(int amount, vector&lt;int&gt;&amp; coins) &#123; vector&lt;int&gt; dp(amount + 1,0); dp[0] = 1; for(int i = 0;i &lt; coins.size();i++)&#123; for(int j = coins[i];j &lt;= amount;j++)&#123; dp[j] += dp[j - coins[i]]; &#125; &#125; return dp[amount]; &#125;&#125;; 1.确定dp数组(dp table)以及下标的含义本题为完全背包+组合(组合不分排序)。amount看成背包重量，“硬币组合数”可以看成物品的组合数，所以拿之前的[完全背包]与[目标和]两题进行一个缝合。dp[j]为重量为j时，最大的排列数为dp[j]，2.确认状态转移方程，即递推公式dp[j] +&#x3D; dp[j - coins[i]];3.dp数组如何初始化dp[0]&#x3D;14.遍历顺序的确定物品重量也就是组合数，从5.推导整个dp数组 377. 组合总和 Ⅳ给你一个由不同整数组成的数组nums，和一个目标整数target。请你从nums中找出并返回总和为target的元素组合的个数。题目数据保证答案符合 32 位整数范围。 先贴出答案，然后一步步讲解。 123456789101112131415class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; dp(target+1,0); dp[0] = 1; for(int i = 0;i &lt;= target;i++)&#123; for(int j = 0;j &lt; nums.size();j++)&#123; if(nums[j] &lt;= i &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]])&#123; dp[i] += dp[i - nums[j]]; &#125; &#125; &#125; return dp[target]; &#125;&#125;; 1.确定dp数组(dp table)以及下标的含义本题为完全背包+组合(组合分排序)。amount看成背包重量，“硬币组合数”可以看成物品的组合数，所以拿之前的[完全背包]与[目标和]两题进行一个缝合。dp[j]为重量为j时，最大的排列数为dp[j]，2.确认状态转移方程，即递推公式dp[j] +&#x3D; dp[j - coins[i]];3.dp数组如何初始化dp[0]&#x3D;14.遍历顺序的确定如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。5.推导整个dp数组 70. 爬楼梯(重制版)假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 先贴出答案，然后一步步讲解。 123456789101112131415class Solution &#123;public: int climbStairs(int n) &#123; if(n == 1) return n; vector&lt;int&gt; dp(n+1,0); dp[1]= 1; dp[2] = 2; for(int i = 3;i&lt;=n;i++)&#123; for(int j = 1;j &lt;= 2;j++)&#123; dp[i] += dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125;; OK~动态规划就学这么多，预计学到单词拆分就继续回到刷LeetCode题目。如果遇到新的算法就跟着[代码随想录].pdf刷算法专题(周末去的新区图书馆，但新区uu的特别招待，下午KTV晚上出去干饭- -，所以周一连忙补上学习内容T_T)。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"First learning record in May","slug":"record03","date":"2022-05-05T16:00:00.000Z","updated":"2022-05-08T13:38:25.777Z","comments":true,"path":"2022/05/06/record03/","link":"","permalink":"https://merr0r.github.io/2022/05/06/record03/","excerpt":"分享五月第一周学习内容","text":"分享五月第一周学习内容 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 343. 整数拆分给定一个正整数n，将其拆分为k个正整数的和（k &gt;&#x3D; 2），并使这些整数的乘积最大化。返回你可以获得的最大乘积。 先贴出答案，然后一步步讲解。 12345678910111213class Solution &#123;public: int integerBreak(int n) &#123; vector&lt;int&gt; dp(n+1); dp[2] = 1; for(int i = 2;i &lt;= n;i++)&#123; for(int j = 1;j &lt; i/2+1;j++)&#123; dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j)); &#125; &#125; return dp[n]; &#125;&#125;; 首先举个栗子当n&#x3D;2时，拆分的数字为1和1。乘积为1。当n&#x3D;3时，拆分的数字为2和1。乘积为2。当n&#x3D;4时，拆分的数字为2和2。乘积为4。当n&#x3D;5时，拆分的数字为2和3。乘积为6。当n&#x3D;6时，拆分的数字为3和3。乘积为9。当n&#x3D;7时，拆分的数字为2、3和2或者4和3。乘积为12。当n&#x3D;8时，拆分的数字为2、3和3。乘积为18。当n&#x3D;9时，拆分的数字为3、3和3。乘积为27。当n&#x3D;10时，拆分的数字为2、3、2和3。乘积为36。首先第一步要从这些栗子中找到动态规划的规律，我们才能列出dp的含义以及动态方程。乍一看没啥思路，其实我们可以把栗子作进一步拆解。当n&#x3D;2时，拆分的数字为1和1。最大乘积为1。当n&#x3D;3时，拆分的数字为2和1。2的最大乘积乘以1等于1，2的本身乘以1等于2。于是3的最大乘积等于2。当n&#x3D;4时，第一种拆分的数字为3和1。3的最大乘积乘以1等于2，3的本体乘以1等于3；第二种拆分的数字为2和2，2的最大乘积乘以2等于2，2的本身乘以2等于4。于是4的最大乘积等于4。当n&#x3D;5时，第一种拆分方式为4和1。4的最大乘积乘以1等于4，4的本身乘以1等于4。第二种拆分方式为3和2，3的最大乘积乘以2等于4，3的本身乘以2等于6。于是5的最大乘积等于6。当n&#x3D;6时，第一种拆分方式为4和2(1直接略过)。4的最大乘积乘以2等于8，4的本身乘以2等于8。第二种拆分方式为3和3。3的最大乘积乘以3等于6，3的本身乘以3等于9。于是6的最大乘积等于9。当n&#x3D;7时，第一种拆分方式为5和2(1直接略过)。5的最大乘积乘以2等于12，5的本身乘以2等于10。第二种拆分方式为4和3。4的最大乘积乘以3等于12，4的本身乘以3等于12。于是7的最大乘积等于12。当n&#x3D;8时，第一种拆分方式为6和2(1直接略过)。6的最大乘积乘以2等于18，6的本身乘以2等于12。第二种拆分方式为5和3。5的最大乘积乘以3等于18，5的本身乘以3等于15。第三种拆分方式为4和4。4的最大乘积乘以4等于16，4的本身乘以4等于16。于是8的最大乘积等于18。当n&#x3D;9时，第一种拆分方式为7和2(1直接略过)。7的最大乘积乘以2等于24，7的本身乘以2等于14。第二种拆分方式为6和3。6的最大乘积乘以3等于27，6的本身乘以3等于18。第三种拆分方式为5和4。5的最大乘积乘以4等于24，5的本身乘以4等于20。于是9的最大乘积等于27。当n&#x3D;10时，第一种拆分方式为8和2(1直接略过)。8的最大乘积乘以2等于36，8的本身乘以2等于16。第二种拆分方式为7和3。7的最大乘积乘以3等于36，7的本身乘以3等于21。第三种拆分方式为6和4。6的最大乘积乘以4等于36，6的本身乘以4等于24。第四种拆分方式为5和5。5的最大乘积乘以5等于30，5的本身乘以5等于25。于是10的最大乘积等于36。现在思路清晰了，我们先把数字A拆成1和A-1，直接讨论A-1的最大乘积大还是A-1本身大，最大的那个数乘以1得到的结果就是在1状态下数字A的最大乘积。继续把A拆成2和A-2，直接讨论A-2的最大乘积大还是A-2本身大，最大的那个数乘以2得到的结果就是在2状态下数字A的最大乘积……最后比较这些状态下的最大乘积，我们就能得到A的最大乘积。 1.确定dp数组(dp table)以及下标的含义 dp[i]的含义是在第i个数下的最大乘积。2.确认状态转移方程，即递推公式 dp[i] &#x3D; max(dp[i],max(dp[i-j]*j,(i-j)*j)) max(dp[i-j]*j,(i-j)*j)代表j状态下的i最大乘积，max里的dp[i]代表之前也就是j-1状态下的i最大乘积，两者需要相互比较。3.dp数组如何初始化 dp[2] &#x3D; 1;4.遍历顺序的确定 i表示从第2个数字，按照正序遍历到n。j就代表拆分下的j状态数字。5.推导整个dp数组 背包二维有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble() &#123; vector&lt;int&gt; weight = &#123;1 , 3 , 4&#125;; vector&lt;int&gt; value = &#123;15 , 20, 30 &#125;; int bagweight = 4; vector&lt;vector&lt;int&gt;&gt; dp(weight.size() + 1, vector&lt;int&gt;(bagweight + 1, 0)); for (int i = bagweight; i &gt;= weight[0]; i--) &#123; dp[0][i] = value[0]; &#125; for (int i = 1; i &lt; weight.size(); i++) &#123; for (int j = 0; j &lt;= bagweight; j++) &#123; if (j &lt; weight[i]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); &#125; &#125; &#125; cout &lt;&lt; dp[weight.size() - 1][bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble(); system(&quot;pause&quot;); return 0;&#125; 此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。首先我们联想一下上一道拆分数组。拆分数组的思路是把数字A拆分成1状态和A-1，然后搜寻A-1的最大值。然后拆分成2状态和A-2，然后搜寻1-2的最大值。我们照葫芦画瓢，运用到这题上：假设第一个物品重量为weight[0]，价值为value[0]。背包重量为j，我们就理解成当j&gt;weight[0]时，j此时的最大价值&#x3D;背包重量为j-weight[0]时的最大价值+value[0]。j&lt;weight[0]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。假设第二个物品重量为weight[1]，价值为value[1]。背包重量为j，我们就理解成当j&gt;weight[1]时，j此时的最大价值&#x3D;背包重量为j-weight[1]时的最大价值+value[1]。j&lt;weight[1]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。但怎么求“背包重量为W-weight[0]时的最大价值”呢？于是我们要遍历从0到W的背包重量，那么很容易看出dp应该是二维数组，dp[i][j]为背包重量为j时装第i个物品的最大价值。那么dp[i][j]是怎么来的？当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那怎么初始化？背包重量为0时，装不下任何物品，故dp[i][0]都为0。讨论第一个物品时，应该背包里没有其他物品，所以当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。 1.确定dp数组(dp table)以及下标的含义 dp[i][j]为背包重量为j时装第i个物品的最大价值。2.确认状态转移方程，即递推公式 当j&lt;weight[i]时，dp[i][j]&#x3D; dp[i - 1][j]。 当j&gt;weight[i]时，dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);3.dp数组如何初始化 dp[0][i] &#x3D; value[0] 当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。4.遍历顺序的确定 i代表物品，因为C++数组的原因，本应从0开始遍历，但之前初始化了，所以从1开始（也就是从第二个物品）开始遍历。j代表背包重量，从0开始5.推导整个dp数组 背包一维有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble() &#123; vector&lt;int&gt; weight = &#123; 1 , 3 , 4 &#125;; vector&lt;int&gt; value = &#123; 15 , 20, 30 &#125;; int bagweight = 4; vector&lt;int&gt; dp1(bagweight + 1, 0); for (int i = 0; i &lt; weight.size(); i++) &#123; for (int j = bagweight; j &gt;= weight[i]; j--) &#123; dp1[j] = max(dp1[j], dp1[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble(); system(&quot;pause&quot;); return 0;&#125; 此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。之前的dp为二维数组。那怎么运用到一维数组？二维dp数组的含义是 dp[i][j]为背包重量为j时装第i个物品的最大价值，dp[i]如果表示第i个物品的最大价值显然不行，那么表示成dp[j]为背包重量为j时的最大价值呢。那么dp[j]怎么来呢？回顾一下二维数组的dp来源当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那么更换成一维数组dp当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那么可以确认 dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i]) max里的dp[j]就是重量为j的背包装第i-1件时的物品时的最大值。那怎么初始化？众所周知重量为0时啥也装不下，所以价值必为0，所以dp[0] &#x3D; 0；从max和value不可能为负数可以得知，我们也可以把dp整个数组的数都初始为0，定义为0对之后在max里取最大值也没啥影响。遍历顺序怎么确定？如果是正序，那么会遇到一个问题。假如物品重量为1，价值为value[1]当j&#x3D;1时，dp[1]&#x3D;value[1]。当j&#x3D;2时候，因为dp[2] &#x3D; max(dp[2],dp[2 - weight[1]] + value[1])，max里的dp[2]&#x3D;0，dp[2 - weight[1]] + value[1]&#x3D;dp[1]+value[1]&#x3D;2xvalue[1]。也就是说在j&#x3D;2的时候value取了两次值。所以不能正序遍历，那逆序呢？当j&#x3D;4时，因为dp[4] &#x3D; max(dp[4],dp[4 - weight[1]] + value[1])，max里的dp[4]&#x3D;0，dp[4 - weight[1]] + value[1]&#x3D;dp[3]+value[1]&#x3D;value[1]。当j&#x3D;3时候，因为dp[3] &#x3D; max(dp[3],dp[3 - weight[1]] + value[1])，max里的dp[3]&#x3D;0，dp[3 - weight[1]] + value[1]&#x3D;dp[2]+value[1]&#x3D;value[1]。这样就不会产生取两次值的情况。 1.确定dp数组(dp table)以及下标的含义 dp[j]为背包重量为j时的最大价值。2.确认状态转移方程，即递推公式 dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i])3.dp数组如何初始化 dp[j]&#x3D; 04.遍历顺序的确定 逆序。5.推导整个dp数组 分割等和子集给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 先贴出答案，然后一步步讲解。 12345678910111213141516171819class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(int i = 0;i &lt; nums.size();i++)&#123; sum += nums[i]; &#125; if(sum % 2 == 1) return false; int sumHalf = sum/2; vector&lt;int&gt; dp(sumHalf + 1,0); for(int i = 0;i &lt; nums.size();i++)&#123; for(int j = sumHalf;j &gt;= nums[i];j--)&#123; dp[j] = max(dp[j],dp[j-nums[i]]+nums[i]); &#125; &#125; if(dp[sumHalf] == sumHalf) return true; return false; &#125;&#125;; 两个子集的元素和相等，可以推断出两个子集的元素和相加等于原数组nums各个数字之和，换句话说两个子集元素的和是nums各个元素和的一半，所以不难判断如果nums各个元素和为奇数，那么false。那么怎么确认dp[i]还是dp[i][j]？刚才我们分析出两个子集的元素和等于nums各个元素和的一半，我们令nums的和为sum，子集元素和为sumHalf。我们可以能把这题转换为刚才的背包问题，两个子集就是两个背包，sumHalf为背包重量，nums里的元素即为物品重量，这里的价值可以看成放入背包物品的最大重量，最大容量不能超过背包重量。根据之前的背包一维dp[j]为背包重量为j时的最大价值可以推断出dp[i]为背包重量为i时候的放入物品的最大重量。那么我要做的就是在背包重量为sumHalf时(dp[sumHalf])放入物品的最大重量等于sumHalf，那样的话另一个背包放入物品的最大重量必定sum-dp[sumHalf],如果sumHalf &#x3D;&#x3D; sum-dp[sumHalf]，或者dp[sumHalf] &#x3D; sumHalf，那直接返回true。那怎么初始化？跟之前一维背包一样，全部定义为0即可。遍历顺序跟一维背包一样，采用逆序。1.确定dp数组(dp table)以及下标的含义 dp[j]为背包重量为j时的放入物品的最大重量。2.确认状态转移方程，即递推公式 dp[j] &#x3D; max(dp[j],dp[j - nums[i]] + nums[i])3.dp数组如何初始化 dp[j]&#x3D; 04.遍历顺序的确定 逆序。5.推导整个dp数组 OK~动态规划就学这么多(其实还有一题- -)，因为最近学校解封，跟同学各种聚餐…所以就更了这么点- -下周好好干会来！！多学点知识！！","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Second learning record in April","slug":"record02","date":"2022-04-30T16:00:00.000Z","updated":"2022-05-01T12:56:02.234Z","comments":true,"path":"2022/05/01/record02/","link":"","permalink":"https://merr0r.github.io/2022/05/01/record02/","excerpt":"分享四月第二周学习内容","text":"分享四月第二周学习内容 leetcode 热题HOT 1003. 无重复字符的最长子串给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.length(); int ret = 0; int l = 0; unordered_map&lt;char,int&gt; Mirror; for(int i = 0;i &lt; n;i++)&#123; Mirror[s[i]]++; while(Mirror[s[i]] &gt;= 2)&#123; Mirror[s[l++]]--; &#125; ret = max(ret,i - l +1); &#125; return ret; &#125;&#125;; 本题的思路为：定义两个索引箭头指向字符串的两端，左端点的箭头先固定不动，右端点箭头右移进行索引，如果碰到重复字符，记录此时的长度，同时左端点往右移，直到没有重复字符为止。右端指针继续右移操作。重复上述过程 开始逐行分析与知识点回顾 123int n = s.length();int ret = 0;int l = 0; n为字符串长度，ret代表我们想返回的值，也就是最长子串的长度。l代表左端点指针 1unordered_map&lt;char,int&gt; Mirror; 定义一个名为Mirror的map容器，键值类型为char，用来存放单个字符。实值类型为int，用来存放字符在字符串的个数 特点是： 1.键只能有一个，但实值能有许多个 2.无序排列 3.通过 容器名[] 能直接添加键值 12345678for(int i = 0;i &lt; n;i++)&#123; Mirror[s[i]]++; while(Mirror[s[i]] &gt;= 2)&#123; Mirror[s[l++]]--; &#125; ret = max(ret,i - l +1); &#125; return ret; i代表右端点索引箭头，i++代表右端点箭头右移 Mirror[s[i]]++; 表示的是右端点指向字符存进map容器中，相应的实值从默认的0增加1个单位。 while(Mirror[s[i]] &gt;&#x3D; 2){ 当存放的数量大于1时候 我们就需要将左端点右移 Mirror[s[l++]]–; l++代表左端点右移。要注意l先执行之前的数字，执行完后才进行自身的加1操作。与++l要区分开。 左端点指针右移的同时(也就是l++)，map容器里存放的相应的字符数量-1。因为右端点索引箭头指向重复字符时，左端点右移要移动到“重复字符的右边一个单位”，这样才能使两端点内的字符不会有重复的字符，移动的同时会“损失一部分字符” ，所以要-1。 ret记录最长长度，循环结束后返回。 4. 寻找两个正序数组的中位数给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int findKth(const vector&lt;int&gt;&amp; a,int sta,const vector&lt;int&gt;&amp; b,int stb,int kth)&#123; if(sta &gt;= a.size()) return b[kth - 1 + stb]; if(stb &gt;= b.size()) return a[kth - 1 + sta]; if(kth == 1) return min(a[sta] , b[stb]); int h = kth / 2; int vala = a.size() - sta &gt;= h ? a[sta + h - 1] : a.back(); int h_a = a.size() - sta &gt;= h ? h : a.size() - sta; int valb = b.size() - stb &gt;= h ? b[stb + h - 1] : b.back(); int h_b = b.size() - stb &gt;= h ? h : b.size() - stb; if(vala &gt;= valb)&#123; return findKth(a,sta,b,stb + h_b,kth - h_b); &#125;else&#123; return findKth(a,sta + h_a,b,stb,kth - h_a); &#125; &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n = a.size(); int m = b.size(); int k = n + m; int k1 = (k + 1) / 2; int k2 = (k + 2) / 2; int ava_1 = findKth(a,0,b,0,k1); int ava_2 = findKth(a,0,b,0,k2); return 1.*(ava_1 + ava_2) / 2; &#125;&#125;; 本题用到数据结构中的二分查找法。二分查找法的基本思路：目标数组必须有序，我们找数组里的数通常会一个一个查找，这样的话效率非常低。二分查找是直接在有序数组中找到中间元素，我们想查找的数与中间元素进行对比，如果小就代表想找的数在中间元素的左方向(假设)，大的话就是右方向。于是我们在左边这一段找到左边这段的中间元素，通过比大小找到目标数字的区间，再从区间里继续寻找中间元素，反复比较，最后找到目标数字。以上介绍的思路为一个数组，而这题涉及到两个数组，换种查找思路。 首先计算两个数组的整体长度，中位数即为最中间的数或者是中间两数的平均数，所以我们只需要找到整体长度前半段，就能找到我们需要的中位数。因为这里有两个数组，因此，我们把整体长度前半段“一分为二”，一半放第一个数组的数字，另一半放第二个数组里的数字。(均为从小到大，不是随意抽取数组数字)。 我们把第一个数组放入“一半”里的最大数字(即最右边的数字)和第二个数组放入“另一半”里的最大数字(即最右边的数字)进行比较，假设第一组的最大数字比第二组大，那么可以判断中位数不在第二组放入“一半”的数字里，即中位数应当存在于第一组和第二组剩余的数字里。 开始逐行分析与知识点回顾 为了方便介绍思路:我们假定a&#x3D;{3，6，11，13}，b&#x3D;{4，9，12，14，16，20}， 123int n = a.size();//n = 4int m = b.size();//m = 6int k = n + m;//k = 10 先看主函数，m和n分别是向量a与向量b的长度，k为总长度。 12int k1 = (k + 1) / 2; //k1 = 5int k2 = (k + 2) / 2; //k2 = 6 常规来讲，长度可分为奇数与偶数，所以中位数位置都会有所不同。但通过c++环境的特性，我们可以把奇数偶数找中位数的算法统一为一个方式。如果是奇数，他们的+1 +2再除以2的结果是相同的，我们把这两个结果相加再除以2就能得到奇数的中位数的下标位置。同理，偶数+1 +2再除以2得到的是中间两个数的下标位置。 123int ava_1 = findKth(a,0,b,0,k1);int ava_2 = findKth(a,0,b,0,k2);return 1.*(ava_1 + ava_2) / 2; 通过算法找到下标所对应的数字，最后返回中位数 12//int ava_1 = findKth(a,0,b,0,k1);int findKth(const vector&lt;int&gt;&amp; a,int sta,const vector&lt;int&gt;&amp; b,int stb,int kth) 接下来看ava_1函数部分：a和b代表我们输入进来的向量，sta和stb是a向量与b向量输入进来的起始下标。kth为我们索引的长度。kth &#x3D; k1; 12345//int ava_1 = findKth(a,0,b,0,k1);if(sta &gt;= a.size()) return b[kth - 1 + stb];if(stb &gt;= b.size()) return a[kth - 1 + sta];if(kth == 1) return min(a[sta] , b[stb]); 此为结束递归函数的三种条件，即我们需要的初始下标大于a的长度时，就代表还没找到需要的数字，我们的a数组就已经索引完了，所以肯定我们需要找的数在b数组。第三种条件为我们找到最后索引长度为1，意味着我们找的数字要么在a数组或者b数组剩余的数字的第一位，所以只要比较a和b最小的数字就能找到我们需要找的数字 1234567int h = kth / 2;int vala = a.size() - sta &gt;= h ? a[sta + h - 1] : a.back();int h_a = a.size() - sta &gt;= h ? h : a.size() - sta;int valb = b.size() - stb &gt;= h ? b[stb + h - 1] : b.back();int h_b = b.size() - stb &gt;= h ? h : b.size() - stb; h为索引长度的一半，也可理解每个向量需要索引数字的个数 vala后面跟着三目运算，当a的长度减去起始长度大于需要索引的数字，就证明a数组是有空间提供“需要索引数字的个数”，于是vala&#x3D;“需要索引数字的个数”的最大值，也就是最右边的数，h_a意味着实际索引数字的个数，因为a是有空间提供，所以h_a&#x3D;h。如果a数组没有空间提供“需要索引数字的个数”，就直接vala&#x3D;a数组最右边的数组，h_a&#x3D;a的长度-a的索引的起始位置。 12345if(vala &gt;= valb)&#123; return findKth(a,sta,b,stb + h_b,kth - h_b);&#125;else&#123; return findKth(a,sta + h_a,b,stb,kth - h_a);&#125; 当a索引的最大数字大于b索引的最大数字时，说明中位数绝对不在b索引的数字里。于是a的起始下标不动，b的起始下标移动到索引数字的右边一个单位，索引长度由之前的h更新为h-h_b，进行递归迭代。后面的过程看图即可。 5. 最长回文子串给你一个字符串s，找到s中最长的回文子串。 先贴出答案，然后一步步讲解。 12345678910111213141516171819202122232425class Solution &#123;public: string longestPalindrome(string s) &#123; int m = s.length(); vector&lt;vector&lt;bool&gt;&gt; f(m , vector&lt;bool&gt;(m , false)); int p_left = 0; int maxlen = 1; for(int i = 0;i &lt; m;i++)&#123; f[i][i] = true; &#125; for(int len = 2;len &lt;= m;len++)&#123; for(int i = 0;i + len &lt;= m;i++)&#123; int j = i + len - 1; if(s[i] != s[j]) continue; if(len &gt; 2 &amp;&amp; f[i+1][j-1] == false) continue; f[i][j] = true; p_left = i; maxlen =len; &#125; &#125; return s.substr(p_left,maxlen); &#125;&#125;; 本题用到数据结构中的动态规划算法。思路：跟第三题类似，需要定义一个左指针和右指针，长度由小到大进行递增。一个满足条件的回文子串的&#x3D;他的两端字符相等+剩下的子串是回文子串。 开始逐行分析与知识点回顾 1234int m = s.length();//字符串长度vector&lt;vector&lt;bool&gt;&gt; f(m , vector&lt;bool&gt;(m , false)); //定义了bool类型的二维数组，默认为falseint p_left = 0;int maxlen = 1; bool类型二维数组[i][j]含义：如果字符串从i到j是回文子串，则返回true，否则就是false p_left为最长回文子串的左端点索引箭头，maxlen记录最长的回文子串长度 123for(int i = 0;i &lt; m;i++)&#123; f[i][i] = true;&#125; 因为单个字符某种意义上也是回文子串，所以单个字符的字符串为true。 12for(int len = 2;len &lt;= m;len++)&#123; for(int i = 0;i + len &lt;= m;i++) 长度从2开始递增，i为左端点索引箭头。 123int j = i + len - 1;if(s[i] != s[j]) continue;if(len &gt; 2 &amp;&amp; f[i+1][j-1] == false) continue; j为右端点索引箭头 如果目标字符串左端点与右端点不相同，则不是回文子串，continue跳过此次循环 如果长度大于2，即使认证了两个端点相同也要鉴定里面一层是否为字符串，如果为false，依然continue跳过此次循环 123f[i][j] = true;p_left = i;maxlen =len; 如果前面的满足都满足 证明此为回文子串，则p_left记录该指索引左端点，maxlen记录此时的长度 1return s.substr(p_left,maxlen); 最后通过string里的函数substr获得最长回文子串 substr(pos,len)：从pos位置开始拷贝len长度的字符 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 509. 斐波那契数斐波那契数（通常用 F(n)表示）形成的序列称为斐波那契数列。该数列由0和1开始，后面的每一项数字都是前面两项数字的和。 先贴出答案，然后一步步讲解。 123456789101112class Solution &#123;public: int fib(int N) &#123; int dp[31];//定义dp数组 dp[0] = 0;//初始化数组 dp[1] = 1;//初始化数组 for (int i = 2; i &lt;= N; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2];//状态方程 &#125; return dp[N]; &#125;&#125;; 斐波那契数是动态规划中最简单直观的题。它直接把步骤2的状态转移方程、步骤3初始化的数字和步骤4的遍历顺序直接告诉你，而且步骤1的dp数组有现成且下标含义也简单易懂，所以推导起来很容易 70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 先贴出答案，然后一步步讲解。 123456789101112class Solution &#123;public: int climbStairs(int n) &#123; int dp[46]; dp[1] = 1; dp[2] = 2; for(int i = 3;i &lt;= n;i++)&#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 爬楼梯这题稍微抽象点，但也简单。我们先从最底层开始理解起 假设我们的起始台阶为第0阶，爬到第一个台阶的方法只有1个，爬到第二个台阶的方法有两个，分别是2，1+1。如果我们想要爬到第三个台阶，有两种方式，从第一阶跨2个台阶或者从第二阶跨1个台阶。有两种方式但有几种方法呢？所以我们要得到跨第一个台阶的方法数量以及跨第二台阶的方法数量分别是1，2，所以爬到第三个台阶的方法数量为1+2&#x3D;3。如果我们想要爬到第四个台阶，依然有两种方式，从第二阶跨2个台阶或者从第三阶跨1个台阶。有两种方式但有几种方法呢？我们得到跨第二个台阶的方法数量为2以及跨第三台阶的方法数量为3，所以爬到第四个台阶的方法数量为2+3&#x3D;5。 跟之前的斐波那契数很相似所以1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[46]; 下标代表从0到下标位置需要的方法数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; dp[i - 1] + dp[i - 2]; 想要爬到第i个台阶，有两种方式，两种方式对应的方法数量为dp[i - 1]和dp[i - 2]。3.dp数组如何初始化 &#x3D;&gt;爬第一个阶梯和第二阶梯方法是很容易推导，所以我们定义dp[1] &#x3D; 1;dp[2] &#x3D; 2;4.遍历顺序的确定 &#x3D;&gt;从第三阶梯开始，故从3开始5.推导整个dp数组 746. 使用最小花费爬楼梯给你一个整数数组cost，其中cost[i]是从楼梯第i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为0或下标为1的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。 先贴出答案，然后一步步讲解。 1234567891011121314class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int m = cost.size(); vector&lt;int&gt; dp( m + 1, 0 ); dp[0] = 0; dp[1] = 0; for(int i = 2;i &lt;= m;i++)&#123; dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); &#125; return dp[m]; &#125;&#125;; 先理解一下题意 如果你从i台阶想向上爬，就需支付i对应的cost，你可以选择爬1台阶或者选择爬2台阶。这题跟之前的爬楼梯类似，但是增加了费用这一选项。如果跟之前一样dp数组的下标代表从0到下标位置需要的方法数量，我们的cost无法考虑进去，所以变换一种思路，dp数组表示从0到i台阶的费用，这样我们就把cost考虑进去，这里不需要考虑方法数量，题目只要求最小的费用。但是这种定义很难求得最小的费用，于是继续变换思路，dp数组表示从0到i台阶的最小费用。从“从下标为0或下标为1的台阶开始爬楼梯”得知，我们从0台阶到0台阶，或者0台阶到1台阶的最小费用都为0，所以初始化确定。假如我们到下标为2的台阶，他有两种方式，一种是0台阶选择跨2台阶，费用为0 + 0阶对应的cost；另一种是1台阶选择跨1台阶，费用为0 + 1阶对应的cost，我们需要求最小的费用所以就有了min(dp[0]+cost[0],dp[1]+cost[1])，这就是我们的状态转移方程了，遍历顺序从2起步1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector dp( m + 1, 0 ); 下标代表从0到下标位置需要的最小费用2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); 爬到第i个台阶，有两种付费方式，两种付费方式对应为dp[i-1]+cost[i-1]和dp[i-2]+cost[i-2]。3.dp数组如何初始化 &#x3D;&gt;dp[0] &#x3D; 0;dp[1] &#x3D; 0;4.遍历顺序的确定 &#x3D;&gt;从第二阶梯开始，故从2开始5.推导整个dp数组 62. 不同路径一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？ 先贴出答案，然后一步步讲解。 12345678910111213141516171819class Solution &#123;public: int uniquePaths(int m, int n) &#123; int dp[m][n] ; for(int i = 0;i &lt; m;i++) dp[i][0] = 1; for(int i = 0;i &lt; n;i++) dp[0][i] = 1; for(int i = 1;i &lt; m;i++)&#123; for(int j = 1;j &lt; n;j++)&#123; dp[i][j] = dp[i][j - 1] + dp [i-1][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 我们先从简单的2x2网格入手。我们从起始点1x1出发，移动到1x2或者是2x1因为机器人只能右移或者左移，所以只有一条路径选择。移动到2x2有两种方式，一个从1x2或者2x1，两种方式都是1种选择，所以不难判断移动到2x2的路径选择有1+1&#x3D;2种。所以dp数组得建立一个二维数组。[i][j]下标代表到达ixj的路径个数。我们的初始化很容易确定，即第一行和第一列的路径选择都是1。状态转移方程为dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j];从下标1还是遍历1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[m][n] ; 下标代表到达对应位置的路径数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和3.dp数组如何初始化 &#x3D;&gt;dp[i][0] &#x3D; 1; dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种4.遍历顺序的确定 &#x3D;&gt;从1x1开始5.推导整个dp数组 63. 不同路径 II一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用1和0来表示。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223242526class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int raws = obstacleGrid.size(); int cols = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(raws, vector&lt;int&gt;(cols, 0)); for(int i = 0;i &lt; raws &amp;&amp; obstacleGrid[i][0] == 0;i++)&#123; dp[i][0] = 1; &#125; for(int i = 0;i &lt; cols &amp;&amp; obstacleGrid[0][i] == 0;i++)&#123; dp[0][i] = 1; &#125; for(int i = 1;i &lt; raws;i++)&#123; for(int j = 1;j &lt; cols;j++)&#123; if(obstacleGrid[i][j] == 1)&#123; continue; &#125; dp[i][j] = dp[i][j - 1] + dp [i-1][j]; &#125; &#125; return dp[raws - 1][cols - 1]; &#125;&#125;; 这题思路跟之前的一样，只不过需要判断所到的点是否有障碍物。dp数组的含义依然是到达对应位置的路径数量，但是初始化的时候第一行或者第一列如果遇到障碍物则令其对应位置的路径数量为0，且这位置往右或者往下的所有位置都为0，因为有了阻碍所以让后面的位置不能初始化，先暂定为0。然后就判断当我们到达的位置判断0或1，如果是0则表示无障碍，可以进行动态规划，如果不可以则跳过此次循环。1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector&lt;vector&gt; dp(raws, vector(cols, 0)); 下标代表到达对应位置的路径数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和3.dp数组如何初始化 &#x3D;&gt;dp[i][0] &#x3D; 1; dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种4.遍历顺序的确定 &#x3D;&gt;从1x1开始5.推导整个dp数组 OK~动态规划就学这么多，因为之前在leetcode遇到的题以及接下来的题都遇到动态规划，所以特地先去网上找了些资料当专题刷了一下。leetcode先暂停更新，等动态规划所有题型刷完就回来继续刷热题100道！ 分享最近读的书《掌握习惯》很喜欢里面的几句话–你可能会出于某种动机而培养一种习惯，但让你长期保持这种习惯的唯一原因是它已经与你的身份融为一体。–你此时此刻是成就辉煌还是一事无成并不重要，重要的是你当前的习惯是否让你走上了通向成功的道路。希望我能坚持把Blog更新下去，然后培养读书的习惯，就像那本书所说，习惯培养起来了，目标不会太远。希望每一步一步脚印能让我变得更好~下周见","categories":[],"tags":[]},{"title":"First learning record","slug":"record01","date":"2022-04-23T16:00:00.000Z","updated":"2022-04-24T05:19:30.989Z","comments":true,"path":"2022/04/24/record01/","link":"","permalink":"https://merr0r.github.io/2022/04/24/record01/","excerpt":"分享第一周学习内容","text":"分享第一周学习内容 leetcode 热题HOT 1001.两数相加给定一个整数数组nums和一个整数目标值target请你在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; a; vector&lt;int&gt; b(2,-1); for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; &#125;&#125;; 通常的作法为逐步尝试，首先第一个加第二个，再第一个加第三个……思路虽然简单暴力但运行速度慢且内存空间消耗大此代码采用的 开始逐行分析与知识点回顾 1map&lt;int,int&gt; a; //创建名为a的map容器，key与val的类型均为int 回顾map容器的相关知识： 1.map容器里的数值都是pair—&gt;成对出现 分别为键值key与实值val 2.我们可以通过key的索引查到对应的val 3.map不允许有重复的键值key存在 3.所有元素都会根据你所存的键值key进行自动排序 4.其中&lt;int,int&gt; 左边int代表key的类型为int 右边的int代表val为int 作用为：存储nums里的元素 1vector&lt;int&gt; b(2,-1);//创建名为b的vector容器，2代表初始长度，里面的值均为-1，存储nums里能满足target的两个值 回顾vector容器的相关知识： 1.与数组结构非常相似，与数组不同点在于数组是静态，而vector是动态扩展 12for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); 涉及到的知识： 1.nums.size()表示的是整数数组nums的长度 2.a.insert是调用map容器里的函数insert：在map中插入元素 3.map&lt;int,int&gt;::value_type：令元素的类型为map中含有key与val的pair类型 4.map&lt;int,int&gt;::mapped_type：令元素的类型为map中的val类型 5.map&lt;int,int&gt;::key_type：令元素的类型为map中的key类型 所以 我们把nums里的元素分别以key-val的pair形式传到名为a的map容器里 12345678for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; 涉及到的知识： 1.map容器的函数count(key)：如果key键值存在，则返回1，否则返回0 思路：通过target依次减去nums[i]，得到的结果通过count函数搜索是否存在于名为a的map容器中。且通过&amp;&amp;算法来满足“同一个元素在答案里不能重复出现”这一条件。if条件满足后，则赋予名为b的vector容器，最后返回b容器 2.两数相加给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* H = new ListNode(); ListNode* ptr = H; int carry = 0; while(l1 || l2 || carry)&#123; int val = 0; if(l1) val += l1-&gt;val,l1 = l1-&gt;next; if(l2) val += l2-&gt;val,l2 = l2-&gt;next; val +=carry; ListNode* node = new ListNode(val % 10); ptr-&gt;next = node; ptr = node; carry = val / 10; &#125; return H-&gt;next; &#125;&#125;; 开始逐行分析与知识点回顾 创建链表的详细过程 1.链表的概念 通过一组任意的存储单元来存储线性表中的数据元素，有一个个结点组成。 2.节点(Node)的框架 1234struct ListNode&#123; int data; ListNode* next;&#125;; 节点分为头节点和首元节点 a.头节点 设置链表前会额外增设一个节点，该节点一般不存放数据。好处是可以使问题简单化。对于链表来讲，不一定非得增设头节点。 b.首元节点 头节点后边的第一个节点，也是链表中的第一个节点。 节点包括数据data和指针Next a.指针的概念 指针是一个变量，存储另一个变量的地址 123int a = 10;int* p;//定义指针的格式为 数据类型* 指针变量名字p = &amp;a;//&amp;代表取址符号 b.结构体指针 12345678910111213#include &lt;iostream&gt;struct student&#123; string name; int age;&#125;//创建一个结构体int main()&#123; 1.创建结构体变量 student s =&#123;&quot;haha&quot;,18&#125;; 2.通过指针指向结构体变量 student* p = &amp;s;//p的类型必须跟s一致 3.指针访问结构体变量中的数据 cout &lt;&lt; p-&gt;name;//通过-&gt;访问结构体里的数据&#125; 结点的框架图： 创建链表的流程： 123456789101112131415161718192021222324#include &lt;iostream&gt;/*创建一个链表*/struct ListNode&#123; int data; ListNode* next;&#125;;void createList(ListNode* pHead)&#123; ListNode* p = pHead; for(int i = 0;i &lt; 10;i++)&#123; ListNode* pNewNode = new ListNode; pNewNode-&gt;data = i; pNewNode-&gt;next = NULL; p-&gt;next = pNewNode; p = pNewNode; &#125;&#125;int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 现来逐个分析 1234567int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 首先在main函数创建一个名为head的指针结构体变量，在这我们可以把head看成头节点，分配相应内存和初始化成员后如下图所示 把head指针代入函数createList，开始创建链表 12void createList(ListNode* pHead)&#123; ListNode* p = pHead; 创造p节点，令结构体指针p等于pHead，此时p的地址与pHead的地址一样，对p操作就是对pHead操作，所以p也是头节点。 12345 for(int i = 0;i &lt; 10;i++)&#123; //i = 0 ListNode* pNewNode = new ListNode; &#125;&#125; 进入for循环，处于i&#x3D;0时。在堆区new一个新内存，存放pNewNode。作为中间结构体为存放新节点提供过渡。 a.new的相关知识 new返回的使 该数据类型的指针 1234int* func()&#123; int* p = new int(10); return p;&#125; b.内存四区 程序运行前： 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 程序运行后： 堆区：堆区的数据由程序员开辟，程序员管理使用(delete) 栈区：栈区的数据由系统分配，一般存放函数的参数以及局部变量。函数执行完，栈区的数据都会自动释放。 指针本质是局部变量，放在栈上，但指针保存的数据使放在堆区。 回到链表创建上来 123//i = 0pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;0时，在pNewNode里存放数据 12//i = 0p-&gt;next = pNewNode; 头节点p指向我们的创建的链表的第一个节点 i&#x3D;0下的pNewNode，i&#x3D;0下的pNewNode也称之为首元节点。 12//i = 0p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与pHead没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们进入下一个循环 1234//i = 1ListNode* pNewNode = new ListNode;pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;1时，在pNewNode里存放数据 12//i = 1p-&gt;next = pNewNode; 节点p指向我们的创建的链表的第一个节点 i&#x3D;1下的pNewNode 12//i = 1p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与i&#x3D;0下的pNewNode没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们的创建链表的详细过程就结束了，回到LeetCode题上。 123ListNode* H = new ListNode();ListNode* ptr = H;int carry = 0; H为定义的头节点，ptr是中间节点，H存放的地址与ptr存放的地址一致。carry为进位数 1while(l1 || l2 || carry)&#123; 个人的看法只要当l1 l2的val为0(结构体里的data)及carry为0，才返回false，其他情况一律为true。 123if(l1) val += l1-&gt;val,l1 = l1-&gt;next;if(l2) val += l2-&gt;val,l2 = l2-&gt;next;val +=carry; 当l1不为0是 执行if语句 val为l1链表的第一个数字，l1从第一个链表转换成l1的第二个链表第二行代码同理carry是进位制 1ListNode* node = new ListNode(val % 10); 创建新链表的第一个节点，存储的数据为 val除以10的余数 123ptr-&gt;next = node;ptr = node;carry = val / 10; 因为node存放的数据是我们想要的数据，所以利用ptr的next指针即H的next指针指向node节点，ptr切断与H的联系，令ptr与node指向同一块内存，手法跟创建链表一样。通过相除判断carry是否进1位。 1return H-&gt;next; H为头节点，头节点下一个next才是链表中的节点。 Conclusion第一次写博客，刚开始上手不是很熟悉，所以暂时就写了这周学的LeetCode。下次尝试把参与的项目学到的知识分享在博客中。暂定每周日更新博客，如果有研究僧考试那就咕咕咕~See you next week","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-17T10:54:08.712Z","updated":"2022-04-21T10:49:59.004Z","comments":true,"path":"2022/04/17/hello-world/","link":"","permalink":"https://merr0r.github.io/2022/04/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}