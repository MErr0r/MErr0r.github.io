{"meta":{"title":"MErr0rのBlog","subtitle":"I turn the page to drown you out","description":"合工大研究僧","author":"MErr0r","url":"https://merr0r.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-04-20T05:00:03.000Z","updated":"2022-04-20T05:01:05.337Z","comments":true,"path":"categories/index.html","permalink":"https://merr0r.github.io/categories/index.html","excerpt":"","text":""},{"title":"record","date":"2022-04-18T08:38:21.000Z","updated":"2022-04-18T08:38:21.627Z","comments":true,"path":"record/index.html","permalink":"https://merr0r.github.io/record/index.html","excerpt":"","text":""},{"title":"special","date":"2022-04-18T08:38:31.000Z","updated":"2022-04-18T08:38:31.743Z","comments":true,"path":"special/index.html","permalink":"https://merr0r.github.io/special/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-19T00:30:08.000Z","updated":"2022-04-20T04:57:59.765Z","comments":true,"path":"tags/index.html","permalink":"https://merr0r.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Fist Study Record of internship","slug":"Fist Study Record of internship","date":"2022-09-22T12:39:55.629Z","updated":"2022-10-30T04:51:59.292Z","comments":true,"path":"2022/09/22/Fist Study Record of internship/","link":"","permalink":"https://merr0r.github.io/2022/09/22/Fist%20Study%20Record%20of%20internship/","excerpt":"分享九月学习内容","text":"分享九月学习内容 嵌入式学习GPIO以及led原理图演变GPIO&#x3D;General Purpose Input Output，通用的输入输出接口，有时候称为“IO口”。 最原始的led图，但是电流过大可能会烧坏二极管。 增加保护电阻，但电子系统是不可能手动控制开关。 通过编程，用芯片引脚控制发光二极管，有两种控制方法：1、芯片输出3.3V，使二极管发光。2、芯片输出0V，使二极管发光。但有的芯片驱动为了省电，也就是引脚驱动能力不足，又加以改进。 通过编程，用芯片引脚控制发光二极管，有两种控制方法：1、芯片输出1.2V，使二极管发光。2、芯片输出0V，使二极管发光。由此，引脚输出高低电平就能控制led。其中高电平为1，低电平为0. 嵌入式环境1、在Windows上用Source insight看Linux内核源码2、用filezilla把我们需要运行的文件上传到虚拟机里运行的ubuntu系统里。3、用mobaxterm远程操控ubuntu。4、用mobaxterm操作开发板。 串口编程开始位，数据位，校验位，停止位驱动程序编写流程：1、确定主设备号2、定义自己的file_operations结构体3、实现对应的open&#x2F;read&#x2F;write等函数，填入file_operations结构体4、把file_operations结构体告诉结构体；注册驱动程序5、安装驱动时，就回去调用这个出口函数6、有入口函数就有出口函数：卸载程序时，就会去调用这个出口函数7、提供设备信息，自动创建设备节点 简单的led驱动编程Step1:写下包含的头文件： 1234567891011#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/io.h&gt; Step2:确定自己的入口函数以及出口函数： 1234567891011/* 入口函数 */static int __init led_init(void)&#123; return 0;&#125;static void __exit led_exit(void)&#123;&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;); Step2:编写入口出口函数：在入口函数通过register_chrdev向内核注册字符设备。 1register_chrdev(unsigned int major, const char *name, const struct file_operations *fops) 其中unsigned int major为主设备号，当为0时内核会动态分配一个设备号。一个字符设备设备号分为主设备号和次设备号。主设备号是特定的驱动程序，次设备号是该程序的设备。比如我们要点两个led灯。主设备中的1为led驱动程序，次设备号1-2分别两个led设备；const char *name为注册的设备名称；const struct file_operations *fops为文件操作指针。它是设备号和系统操作之间的纽带，集成了系统操作所需要的一系列函数，每个成员就是一个系统调用，我们先读取fops结构体里的指针函数，接着把控制权交给指针函数。 1major = register_chrdev(0, &quot;100ask_led&quot;, &amp;led_fops); 入口函数有注册主设备号，那么出口函数就有卸载主设备号 1unregister_chrdev(major,&quot;100ask_led&quot;,); 编写入口出口函数的后面同时写上 123module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;); 其中module支撑驱动的加载与卸载。Step3:编写file_operations结构体以及我们所需要的函数 12345static struct file_operations led_fops = &#123; .owner = THIS_MODULE, .write = led_write, .open = led_open,&#125;; file_operations是关联系统调用和驱动程序的关键结构体，这个结构每个成员都代表着系统调用。Step4:编写结构体里的函数led_write。led_write的作用是设置gpio的寄存器，输出高低电平点亮或者熄灭led。驱动访问应用层数据需要借助辅助函数copy_to_user与copy_from_user。 12345678910111213141516copy_from_user(&amp;val, buf, 1);//用户空间拷贝到内核空间，拷贝1个字节static ssize_t led_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos) &#123; char val; /* copy_from_user : get data from app */ copy_from_user(&amp;val, buf, 1);//用户空间拷贝到内核空间，拷贝1个字节 /* to set gpio register: out 1/0 */ if(val)&#123; &#125;else&#123; &#125; return 1; &#125; Step5:编写结构体里的函数led_open。 1234static int led_open(struct inode *inode, struct file *filp)&#123; return 0;&#125; 我们最后的目标是让引脚输出电平，led发光，但led是硬件。led_open的作用是驱动硬件，驱动硬件的前提需要访问硬件的地址，所以我们可以在入口函数通过ioremap把所有的硬件的物理地址全都映射成虚拟地址，之后就能驱动led的点亮与熄灭。如果让引脚输出电平，涉及到的硬件流程为：1、使能PLL。寄存器RCC_PLL4CR地址： 0x50000000 + 0x894 1static volatile unsigned int RCC_PLL4CR; 2、使能GPIO。寄存器RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28 1static volatile unsigned int RCC_MP_AHB4ENSETR; 3、设置PA10，用作输出寄存器GPIO_MODER 地址： 0x50002000 + 0x00 1static volatile unsigned int GPIO_MODER; 4、设置输出电平寄存器GPIO_BSRR 地址： 0x50002000 + 0x18 1static volatile unsigned int GPIO_BSRR; 在入口出口函数处理物理地址。 1234567891011121314151617181920212223242526272829303132333435static int __init led_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__ , __FUNCTION__,__LINE__); major = register_chrdev(0, &quot;100ask_led&quot;, &amp;led_fops); /* ioremap(base_phy, size); */ //RCC_PLL4CR地址： 0x50000000 + 0x894 RCC_PLL4CR = ioremap(0x50000000 + 0x894, 4); //RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28 RCC_MP_AHB4ENSETR = ioremap(0x50000000 + 0xA28, 4); //GPIO_MODER 地址： 0x50002000 + 0x00 GPIO_MODER = ioremap(0x50002000 + 0x00, 4); //GPIO_BSRR 地址： 0x50002000 + 0x18 GPIO_BSRR = ioremap(0x50002000 + 0x18, 4); led_class = class_create(THIS_MODULE, &quot;myled&quot;); device_create(led_class, NULL, MKDEV(major, 0), NULL, &quot;myled&quot;);//能创建/led/myled的设备节点 return 0;&#125;static void __exit led_exit(void)&#123; iounmap(RCC_PLL4CR); iounmap(RCC_MP_AHB4ENSETR); iounmap(GPIO_MODER); iounmap(GPIO_BSRR); device_destroy(led_class, MKDEV(major, 0)); class_destroy(led_class); unregister_chrdev(major, &quot;100ask_led&quot;);&#125; Step5:完善函数led_open与led_write。输出电平的步骤：1、使能PLL。翻开手册需要把第一位修改成1，当第二位为1时候代表寄存器稳定。 12*RCC_PLL4CR |= (1&lt;&lt;0); while((*RCC_PLL4CR &amp; (1&lt;&lt;1)) == 0); 2、使能GPIO。我们通过RCC_MP_AHB4ENSETR使用GPIO。 1*RCC_MP_AHB4ENSETR |= (1&lt;&lt;0); 3、由上图可知开发板上2个LED灯用到了PA10和PG8 2个引脚，我们驱动PA10，只需要设置b[21:20]为1就可以配置GPIOA_IO10为输出模式。 12*GPIO_MODER &amp;= ~(3&lt;&lt;20);*GPIO_MODER |= ~(1&lt;&lt;20); led_open函数就完成了： 12345678910111213141516171819static int led_open(struct inode *inode, struct file *filp)&#123; /* enable PLL4,it is clock source for all gpio */ *RCC_PLL4CR |= (1&lt;&lt;0); while((*BCC_PLL4CR &amp; (1&lt;&lt;1)) == 0); /* enable gpio */ *RCC_MP_AHB4ENSETR |= (1&lt;&lt;0); /* configure pin as gpio * configure gpio as output */ *GPIO_MODER &amp;= ~(3&lt;&lt;20); *GPIO_MODER |= ~(1&lt;&lt;20); return 0;&#125; 4、在led_write设置输出电平，由下图可知只需要操作b[10]与b[26]，写入1&#x2F;0来控制输出高低。 1234567891011121314151617static ssize_t led_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos) &#123; char val; /* copy_from_user : get data from app */ copy_from_user(&amp;val, buf, 1);//用户空间拷贝到内核空间，拷贝1个字节 /* to set gpio register: out 1/0 */ if(val)&#123; /* set gpa10 to let led on */ *GPIO_BSRR = (1&lt;&lt;26); &#125;else&#123; /* set gpa10 to let led off */ *GPIO_BSRR = (1&lt;&lt;10); &#125; return 1; &#125; 至此，简单的led驱动编程框架就搭好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/io.h&gt;static int major;static struct class *led_class;/* register *///RCC_PLL4CR地址： 0x50000000 + 0x894static volatile unsigned int RCC_PLL4CR;//RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28static volatile unsigned int RCC_MP_AHB4ENSETR;//GPIO_MODER 地址： 0x50002000 + 0x00static volatile unsigned int GPIO_MODER;//GPIO_BSRR 地址： 0x50002000 + 0x18static volatile unsigned int GPIO_BSRR;static ssize_t led_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos) &#123; char val; /* copy_from_user : get data from app */ copy_from_user(&amp;val, buf, 1);//用户空间拷贝到内核空间，拷贝1个字节 /* to set gpio register: out 1/0 */ if(val)&#123; /* set gpa10 to let led on */ *GPIO_BSRR = (1&lt;&lt;26); &#125;else&#123; /* set gpa10 to let led off */ *GPIO_BSRR = (1&lt;&lt;10); &#125; return 1; &#125;static int led_open(struct inode *inode, struct file *filp)&#123; /* enable PLL4,it is clock source for all gpio */ *RCC_PLL4CR |= (1&lt;&lt;0); while((*BCC_PLL4CR &amp; (1&lt;&lt;1)) == 0); /* enable gpio */ *RCC_MP_AHB4ENSETR |= (1&lt;&lt;0); /* configure pin as gpio * configure gpio as output */ *GPIO_MODER &amp;= ~(3&lt;&lt;20); *GPIO_MODER |= ~(1&lt;&lt;20); return 0;&#125;static struct file_operations led_fops = &#123; .owner = THIS_MODULE, .write = led_write, .open = led_open,&#125;;/* 入口函数 */static int __init led_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__ , __FUNCTION__,__LINE__); major = register_chrdev(0, &quot;100ask_led&quot;, &amp;led_fops); /* ioremap(base_phy, size); */ //RCC_PLL4CR地址： 0x50000000 + 0x894 RCC_PLL4CR = ioremap(0x50000000 + 0x894, 4); //RCC_MP_AHB4ENSETR 地址： 0x50000000 + 0xA28 RCC_MP_AHB4ENSETR = ioremap(0x50000000 + 0xA28, 4); //GPIO_MODER 地址： 0x50002000 + 0x00 GPIO_MODER = ioremap(0x50002000 + 0x00, 4); //GPIO_BSRR 地址： 0x50002000 + 0x18 GPIO_BSRR = ioremap(0x50002000 + 0x18, 4); led_class = class_create(THIS_MODULE, &quot;myled&quot;); device_create(led_class, NULL, MKDEV(major, 0), NULL, &quot;myled&quot;);//能创建/led/myled的设备节点 return 0;&#125;/* 出口函数 */static void __exit led_exit(void)&#123; iounmap(RCC_PLL4CR); iounmap(RCC_MP_AHB4ENSETR); iounmap(GPIO_MODER); iounmap(GPIO_BSRR); device_destroy(led_class, MKDEV(major, 0)); class_destroy(led_class); unregister_chrdev(major, &quot;100ask_led&quot;);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;); C++学习C&#x2F;C++知识起别名的结构体构造typedef 给类型起别名结构体 自定义的类型用法：关键字 名字{} 1234567891011121314151617181920//第一种构造方式struct student&#123; string name; int age; string hobby;&#125;;typedef student Stu1;//起别名//第二种构造方式typedef struct student&#123; string name; int age; string hobby;&#125;Stu2;int main()&#123; student zhangsan; Stu1 zhangsan1; Stu2 zhangsan2;&#125; 我们可以把student、Stu1和Stu2看成是同一个类型。 位运算16位操作系统的Int为2字节，32位操作系统int为4个字节，一个字节为8位，一个整型变量在计算机当中其实可以用32位的二进制来表示。A &lt;&lt; B:表示A转化为二进制后，往左移动B位，高位丢弃，低位补0.例：5 &lt;&lt; 1：5转为二进制0101，往左移1位，高位丢弃，低位补0，得1010。A &gt;&gt; B:表示A转化为二进制后，对无符号数，往右移动B位，低位丢弃，高位补0.例：6 &gt;&gt; 1：5转为二进制0110，往左移1位，低位补0，得0011。A &amp; B ：A和B转为二进制，相对应的位如果都是1得1，其余都为0。例：A &#x3D; 5，A二进制位0101，B &#x3D; 6，B二进制位：0110，A &amp; B &#x3D; 0100。A | B ：A和B转为二进制，相对应的位如果有一位为1，那结果为1。例：A &#x3D; 5，A二进制位0101，B &#x3D; 6，B二进制位：0110，A &amp; B &#x3D; 0111。A ^ B ：异或运算符。A和B转为二进制，相对应的位相同结果为1，否则为1。例：A &#x3D; 5，A二进制位0101，B &#x3D; 6，B二进制位：0110，A &amp; B &#x3D; 1100。 12~A ：A转为二进制，相对应的位取相反的值。例：A = 5，A二进制位0101，~A = 1010。 static静态1、static修饰全局变量，称之为静态全局变量。全局变量可以被一个工程下所有文件所调用，但静态全局变量只能被它所在的文件所调用，工程里其他的文件都不能调用。 1234int a = 0;int main&#123; return 0;&#125; 1234static int a = 0;int main&#123; return 0;&#125; 2、static修饰局部变量，称之为静态局部变量。局部变量在函数结束后就会立即销毁，但是静态局部变量会依旧保存这个数，如果静态局部变量所在的函数再一次被调用时，这个静态局部变量的指是上次函数结束前保存的值，而不是函数初始化的那个值，也就是说，静态局部变量只能初始化一次。3、static修饰函数，称之为静态函数，跟静态全局变量一样，函数可以被一个工程下所有文件所调用，但静态函数只能被它所在的文件所调用，工程里其他的文件都不能调用。 形参与实参c++函数传递叫值传递和地址传递，在主函数的都是实参，实际的参数，如果只是值传递，传到函数里的就是形参，形参里的a，b在fcn函数里完成了++步骤，但主函数里的a，b是没有任何变化，所以实参和形参是互不受影响。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;void fcn(int a,int b)&#123; a++; b++;&#125;int main()&#123; int a = 1; int b = 1; cout &lt;&lt; a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; fcn(a,b); cout &lt;&lt; a &lt;&lt;&quot; &quot;&lt;&lt;b; return 0;&#125; 如果是地址传递，那么主函数的实参是会受到影响。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;void fcn(int &amp;a,int &amp;b)&#123; a++; b++;&#125;int main()&#123; int a = 1; int b = 1; cout &lt;&lt; a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; fcn(a,b); cout &lt;&lt; a &lt;&lt;&quot; &quot;&lt;&lt;b; return 0;&#125; 构造函数构造函数的作用：初始化类对象的数据成员一般分为：无参构造函数、一般构造函数和复制构造函数，这里主要介绍无参构造函数和一般构造函数。无参构造函数顾名思义，没有传入参数的构造器。一般来说创造一个类，如果没写任何构造函数，系统会自动生成一个无参构造器，且函数为空，我们也可以自行编写一个无参构造函数。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class Student&#123; public: int m_age; int m_score; Student()&#123; m_age = 0; m_score = 100; cout&lt;&lt;&quot;调用无参构造器&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; Student xiaoMing; return 0;&#125; 一般构造器的写法为 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class Student&#123; public: int m_age; int m_score; Student(int age,int score):m_age(age),m_score(score)&#123; cout&lt;&lt;&quot;调用Student(int age,int score)一般构造器&quot;&lt;&lt;endl; &#125; Student(int age)&#123; m_age = age; cout&lt;&lt;&quot;调用Student(int age)一般构造器&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; Student xiaoMing(5,100); Student pangHu(10); return 0;&#125; 链表707. 设计链表在链表类中实现这些功能：get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 题解：链表由一个个结点串联而成，结点本质上是结构体，这个结构体包含一个数值val和一个指针Next，通过指针Next指向下一个结点，也就是下一个结构体，Next如同一个链子把每个结点链接起来，构成了我们需要的链表结点在C++里表现形式： 12345struct LinkedList&#123; int val; LinkedList *next; LinkedList(int val):val(val),next(nullptr)&#123;&#125;&#125;; 结点创建后，再来实现每个函数。实现函数之前，我们要创建一个虚拟的头结点dummyNode,以及记录长度的数值size 12LinkedList *dummyNode = new LinkedList(0);int size = 0; ①addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。这里用图形化的形式演示一下链表添加操作： dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们在头结点插入结点F，得到dummyNode-&gt;F-&gt;A-&gt;C-&gt;D-&gt;E。 那我们只需要更改dummyNode和F的Next就行了，所以具体代码为： 123456void addAtHead(int val) &#123; LinkedList node = new LinkedList(val); node-&gt;next = dummyNode-&gt;next; dummyNode-&gt;next = node; size++;&#125; ②addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。这里用图形化的形式演示一下链表添加操作： dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们在D节点之前插入结点F，得到dummyNode-&gt;A-&gt;C-&gt;F-&gt;D-&gt;E。 12345678910111213void addAtIndex(int index,int val) &#123; if (index &gt; size) &#123; return; &#125; LinkedNode *node = new LinkedNode(val); LinkedNode *cur = dummyHeadNode; while(index--)&#123; cur = cur-&gt;next; &#125; node-&gt;next =cur-&gt;next; cur-&gt;next = node; size++;&#125; ③addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。这里用图形化的形式演示一下链表添加操作： dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们在末端插入结点F，得到dummyNode-&gt;A-&gt;C-&gt;D-&gt;E-&gt;F。 123456789void addAtTail(int val) &#123; LinkedNode *node = new LinkedNode(val); LinkedNode *cur = dummyHeadNode; while(cur-&gt;next != nullptr)&#123; cur = cur-&gt;next; &#125; cur-&gt;next = node; size++;&#125; ④get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。这里用图形化的形式演示一下链表添加操作： dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们想得到dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。 12345678910int get(int index) &#123; if(index &lt; 0 || index &gt; size - 1)&#123; return -1; &#125; LinkedNode *cur = dummyHeadNode-&gt;next; while(index--)&#123; cur = cur-&gt;next; &#125; return cur-&gt;val;&#125; ⑤deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。这里用图形化的形式演示一下链表添加操作： dummyNode-&gt;A-&gt;C-&gt;D-&gt;E。如果我们删除结点D，得到dummyNode-&gt;A-&gt;C-&gt;E。 1234567891011void deleteAtIndex(int index) &#123; if(index &gt;= 0 &amp;&amp; index &lt; size)&#123; LinkedNode *cur = dummyHeadNode; while(index--)&#123; cur = cur-&gt;next; &#125; LinkedNode *temp = cur-&gt;next; cur-&gt;next = temp-&gt;next; size--; &#125;&#125; 研二公司实习ros安装工控机系统：Ubuntu 18.04安装时间：2022.9.26如果官网与本文代码有区别，请以官网为主。打开两个网站：英文ros官网：http://wiki.ros.org/melodic/Installation/Ubuntu中文ros官网：http://wiki.ros.org/cn/melodic/Installation/Ubuntu第一步：打开英文ros官网《1.2 Setup your sources.list》的Mirrors，设置我们所需要的镜像源，最好是选择清华源： 在ros终端输入： 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 第二步：打开中文ros官网《1.3 设置密钥》 在ros终端输入： 1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 第三步：打开英文ros官网《1.4 Installation》，依次在ros端执行： 1sudo apt update 1sudo apt install ros-melodic-desktop 因为对于公司产品Desktop Install已经够用，如果安装Desktop-Full Install比较耗时间。第四步：打开英文ros官网《1.6 Dependencies for building packages》，依次在ros端执行： 1sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential 之前装过ros系统，因为安装公司需要的文件会报错，所以重装了一遍ros。第一遍装ros时候是根据GSDN来装遇到的坑挺多的，第二遍按照官网给的流程一路装下来挺顺利（可能第一遍的时候把所有的问题都解决了所以第二遍就顺利很多）。最好是根据官网流程走一遍，遇到网络问题或者部分报错的问题还是可以找GSDN。 ros学习ros里的节点，也就是node，相当于一个应用。比如一辆移动机器人，一个node操控底盘轮子的转动，一个node驱动摄像头获取图像，一个node驱动机械臂上的夹爪开合。一个软件包里可以有很多个可执行文件，可执行文件执行后就成了一个进程，这个进程就是node。ros里launch，语法为： 1roslaunch package filename.launch 比如： 1roslaunch beginner_tutorials turtlemimic.launch turtlemimic.launch是放在beginner_tutorials包下，turtlemimic.launch文件集成了一堆参数和许多节点。如果一项工程，节点少的话，可以一一启动，但是大项目大工程的时候一个一个节点启动是非常麻烦的，所以只需运行.launch文件可以一键启动多个节点。ros里的topic称之为话题。比如ros里有发布者Publisher和订阅者Subsriber,Publisher与Subsriber之间要负责通信如图 其中命令rostopic list的作用为能够列出所有当前订阅和发布的话题。rostopic pub -1 topic msg_type args 可以把msg_type里的args数据发布到topic上。rostopic echo &#x2F;topic_name 显示发布到主题的消息。 实习公司调试室外重载移动车步骤：data：10&#x2F;12基础软件文件下载：Step1：在Windows界面打开gitee网址：https://gitee.com/dashboard（也能在Ubuntu内打开），搜索rocr6 选择第一个 点进去，再点击zhwl_1981 点击complex_robot Step2：打开ubuntu18.04，在根目录打开终端。 依次输入Windows界面的gitee里的代码： 12$ git clone https://gitee.com/zhwl_1981/complex_robot.git$ cd complex_robot Step3：在complex_robot文件下的终端依次输入： 12./installRobot zeus_s2_rocr6_g3p.rosinstall./installRobot location_navigation.rosinstall 基础软件包都安装完后，开始测试各个装置：夹爪、雷达和机械臂。室外重载夹爪测试：step1：在ubuntu终端运行 1roslaunch g3p_driver hw_link.launch step2：启动另外一个终端输入 1rostopic list 显示 g3p话题为&#x2F;g3p_msgs&#x2F;gripper继续输入： 1rostopic pub -1 /g3p_msgs/gripper 连续按两次TAB键补全信息 ，把后面的state:0.0改成state:1.回车后夹爪就会启动。室外重载激光雷达测试：在此目录下打开终端，运行 1roslaunch zeus_s2_bringup rplidar_ros.launch 运行没有报错，而且激光雷达也正在转，说明测试成功。如果想看的更清楚就在根目录下进入话题 1rostopic list 雷达话题为&#x2F;scan，然后输入以下命令并回车执行 1rviz 在此界面添加激光雷达LaserScan，话题引入&#x2F;scan，Global Options里的Fixed Frame为Laser。室外重载视觉抓取演示：在linux的根目录下输入指令： 12./deepvision.shroslaunch scene_tasks rocr6_pick_place.launch 输入后在手柄上依次摁下a和y就能直接驱动机械臂抓取果实。如果单独控制机械臂的话输入 1rostopic pub -1 /rocr6_msgs/goal_rocr6_msgs/Goal &quot;&#123;cmd: 0, a1: 0.0, a2: 0.0, a3: 0.0, a4: 0.0, a5: 0.0, a6: 0.0,&#125;&quot; 其中a1~a6后面均为机械臂的弧度，如果想手动调整机械臂输入弧度即可。室外重载导航演示：Step1:建图1、正常开机后，打开终端，输入roslaunch rplidar_ros rplidar_a3.launch，用于启动激光雷达；2、新开一个终端，cd到google_ws文件夹下，输入roslaunch cartographer_ros backpack_2d.launch，启动建图程序；3、新开一个终端，输入rviz，在打开的界面上添加&#x2F;map话题的接收显示，即可在rviz的界面上查看实时的建图效果。4、使用手柄控制小车在待建图的区域行走，行走过程要平稳，不要突然停止和急转弯，以免影响建图效果。5、行走结束后，在home文件下打开终端，输入命令 .&#x2F;savemap.sh 保存地图。可以在home文件夹下看到三个以.pbstream、.pgm和.yaml结尾的文件。关掉之前运行的rviz和roslaunch cartographer_ros backpack_2d.launch，打开以.yaml结尾的文件把&#x2F;home&#x2F;nvidia&#x2F;给删去保存。然后把.pgm和.yaml结尾的文件放在&#x2F;catkin_ws&#x2F;src&#x2F;slam_navigation&#x2F;control&#x2F;map下，两个文件名字改成hdmap.pgm和hdmap.yaml，进入hdmap.yaml把image的参数修改为hdmap.pgm。至此，建图完成。Step2:发送导航相关指令1、开启终端，输入指令：输入roslaunch rplidar_ros rplidar_a3.launch，启动激光雷达；（建图没关的话可以不用输入这指令）2、新开终端，输入指令：roslaunch relocalization relocalization.launch, 开启定位程序。3、新开终端，输入指令：roslaunch control control.launch,开启坐标变换程序。4、新开终端，输入指令：rviz，点击左上角file,Home目录下的1.rviz文件。5、新开终端，输入指令：roslaunch control move_base.launch，启动导航控制。6、进入&#x2F;catkin_ws&#x2F;src&#x2F;slam_navigation&#x2F;zeus_s2_navigation&#x2F;scene&#x2F;param文件夹。打开points.yaml，修改点的数量以及位置。7、新开终端，输入指令：roslaunch scene start.launch，启动任务。8、此时导航程序已经全部启动，使用遥控手柄，再按B和Y键，小车即可进行自主导航。注意事项：建图过程中车需要慢慢开，尽量把地图周围扫面全面，方便后期导航能精准。 其他问题电脑卸载旧matlab产生的问题我电脑是装了matlab2018b和2020b，今天把2018b卸载后打开m代码是以Notepad++方式打开，在属性更改打开方式matlab2020b后，打开方式绑定的是[matlab starter application]。虽然打开m代码是2020b的界面，但每次打开新的m代码，就会新打开一个matlab程序。问题应该就是 [.m] 文件关联的是 [matlab starter application]，这应该就是导致双击 [.m] 文件新开 matlab 的原因。解决方法：Step1 打开网站：https://ww2.mathworks.cn/matlabcentral/fileexchange/51165-matlab-file-association-shortcut-fix下载此压缩包并解压 Step2 使用MATLAB运行associateFiles.m文件Step3 然后会得到一个MatlabFileAssocFix.regStep4 运行MatlabFileAssocFix.reg注册文件并按确定Step5 运行matlabshortcuts.batStep6 运行runmatlab.bat完成后，文件关联问题应该得到了修复。 matlab代码乱码问题m文件用Microsoft VS Code，点击右下角“UTF-8” 中间上方会出现两种选择，点击“通过编码重新打开” 搜索GBK，点击保存即可","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每月学习","slug":"每月学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E6%9C%88%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"公司实习","slug":"公司实习","permalink":"https://merr0r.github.io/tags/%E5%85%AC%E5%8F%B8%E5%AE%9E%E4%B9%A0/"}]},{"title":"Third learning record in June","slug":"record08","date":"2022-06-26T16:00:00.000Z","updated":"2022-07-02T07:53:40.046Z","comments":true,"path":"2022/06/27/record08/","link":"","permalink":"https://merr0r.github.io/2022/06/27/record08/","excerpt":"分享六月第三周学习内容","text":"分享六月第三周学习内容 二叉树入门学习104. 二叉树的最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if(root == NULL)&#123; return 0; &#125; que.push(root); int num = 0; while(!que.empty())&#123; int size = que.size(); for(int i = 0;i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; num++; &#125; return num; &#125;&#125;; 559. N 叉树的最大深度给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: int maxDepth(Node* root) &#123; queue&lt;Node*&gt; que; if(root == NULL)&#123; return 0; &#125; que.push(root); int num = 0; while(!que.empty())&#123; int size = que.size(); for(int i = 0;i &lt; size;i++)&#123; Node* node = que.front(); que.pop(); for(int i = 0;i &lt; node-&gt;children.size();i++)&#123; if(node-&gt;children[i])&#123; que.push(node-&gt;children[i]); &#125; &#125; &#125; num++; &#125; return num; &#125;&#125;; 111. 二叉树的最小深度给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int minDepth(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if(root == NULL)&#123; return 0; &#125; que.push(root); int num = 0; while(!que.empty())&#123; int size = que.size(); num++; for(int i = 0;i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); if(!cur-&gt;left &amp;&amp; !cur-&gt;right)&#123; return num; &#125; if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; &#125; return num; &#125;&#125;; 222. 完全二叉树的节点个数给你一棵完全二叉树的根节点 root ，求出该树的节点个数 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if(root == NULL)&#123; return 0; &#125; que.push(root); int num = 0; while(!que.empty())&#123; int size = que.size(); for(int i = 0;i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; num++; &#125; &#125; return num; &#125;&#125;; 110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int getDepth(TreeNode* curNode)&#123; queue&lt;TreeNode*&gt; que; if(curNode == NULL)&#123; return 0; &#125; que.push(curNode); int num = 0; while(!que.empty())&#123; int size = que.size(); num++; for(int i = 0;i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; &#125; return num; &#125; bool isBalanced(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; if(root == NULL)&#123; return true; &#125; st.push(root); while(!st.empty())&#123; TreeNode* node = st.top(); st.pop(); if(abs(getDepth(node-&gt;left) - getDepth(node-&gt;right)) &gt; 1)&#123; return false; &#125; if(node-&gt;right)&#123; st.push(node-&gt;right); &#125; if(node-&gt;left)&#123; st.push(node-&gt;left); &#125; &#125; return true; &#125;&#125;; 注：二叉树的高度：从下往上数二叉树的深度：从上往下数 回溯入门学习110. 平衡二叉树给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按任何顺序返回答案。 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(int n, int k,int startIndex)&#123; if(path.size() == k)&#123; result.push_back(path); return; &#125; for(int i = startIndex;i &lt;= n;i++)&#123; path.push_back(i); backtracking(n,k,i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; backtracking(n,k,1); return result; &#125;&#125;; 216. 组合总和 III找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：只使用数字1到9每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(int newSum,int startIndex,int n,int k)&#123; if(path.size() == k)&#123; if(newSum == n)&#123; result.push_back(path); &#125; return; &#125; for(int i = startIndex;i &lt;= 9;i++)&#123; path.push_back(i); newSum += i; backtracking(newSum,i + 1,n,k); newSum -= i; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(0,1,n,k); return result; &#125;&#125;;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"回溯","slug":"回溯","permalink":"https://merr0r.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"Second learning record in June","slug":"record07","date":"2022-06-18T16:00:00.000Z","updated":"2022-06-19T01:03:08.350Z","comments":true,"path":"2022/06/19/record07/","link":"","permalink":"https://merr0r.github.io/2022/06/19/record07/","excerpt":"分享六月第二周学习内容","text":"分享六月第二周学习内容 动态规划往期回顾进行一个温故而知新！常规题目如果只有一个条件限制，一般设dp为一维数组。如果有多个条件，那就设dp为多维数组。限制条件分两种：①最多数量②最多组合最多组合分两种：①不分顺序②分顺序背包分为①01背包，即限制物品的数量②完全背包，即不限制物品的数量 最多数量 + 01背包解决模板：先遍历物品，从小到大；再遍历背包重量，从大到小遍历。常用的状态方程：dp[j] &#x3D; max(dp[j] , dp[j - value[i]] + weight[i]) 最多数量 + 完全背包解决模板：先遍历物品，从小到大；再遍历背包重量，从小到大遍历。常用的状态方程：dp[j] &#x3D; max(dp[j] , dp[j - value[i]] + weight[i]) 最多组合 + 不分顺序 + 01背包解决模板：先遍历物品，从小到大；再遍历背包重量，从大到小遍历。常用的状态方程：dp[j] +&#x3D; dp[j - coins[i]] 最多组合 + 不分顺序 + 完全背包解决模板：先遍历物品，从小到大；再遍历背包重量，从小到大遍历。常用的状态方程：dp[j] +&#x3D; dp[j - coins[i]] 最多组合 + 分顺序 + 完全背包解决模板：先遍历背包重量，从小到大；再遍历物体，从小到大遍历。常用的状态方程：dp[j] +&#x3D; dp[j - coins[i]] 二叉树入门学习102. 二叉树的层序遍历给你二叉树的根节点 root ，返回其节点值的层序遍历 。（即逐层地，从左到右访问所有节点）。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; vector&lt;vector&lt;int&gt;&gt; result; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; int size = que.size(); vector&lt;int&gt; vec; for(int i = 0; i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); vec.push_back(cur-&gt;val); if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; result.push_back(vec); &#125; return result; &#125;&#125;; 102. 二叉树的层序遍历给你二叉树的根节点root，返回其节点值自底向上的层序遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历) 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; vector&lt;vector&lt;int&gt;&gt; result; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; int size = que.size(); vector&lt;int&gt; vec; for(int i = 0; i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); vec.push_back(cur-&gt;val); if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; result.push_back(vec); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 199. 二叉树的右视图给定一个二叉树的根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; vector&lt;int&gt; result; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; int size = que.size(); for(int i = 0; i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); if(i == (size - 1))&#123; result.push_back(cur-&gt;val); &#125; if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; &#125; return result; &#125;&#125;; 637. 二叉树的层平均值给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; vector&lt;double&gt; result; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; double size = que.size(); double sum = 0; for(int i = 0; i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); sum += cur-&gt;val; if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; result.push_back(sum/size); &#125; return result; &#125;&#125;; 但我写成这样： 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; vector&lt;double&gt; result; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; double size = que.size(); double sum = 0; for(int i = 0; i &lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); sum = sum + (cur-&gt;val)/size; if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; result.push_back(sum); &#125; return result; &#125;&#125;; 就会报错！！ 429. N 叉树的层序遍历给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; queue&lt;Node*&gt; que; vector&lt;vector&lt;int&gt;&gt; result; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; vector&lt;int&gt; vec; int size = que.size(); for(int i = 0;i &lt; size;i++)&#123; Node* node = que.front(); que.pop(); vec.push_back(node-&gt;val); for(int i = 0;i &lt; node-&gt;children.size();i++)&#123; if(node-&gt;children[i])&#123; que.push(node-&gt;children[i]); &#125; &#125; &#125; result.push_back(vec); &#125; return result; &#125;&#125;; 515. 在每个树行中找最大值给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; queue&lt;TreeNode*&gt; que; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; int size = que.size(); int m = INT_MIN; for(int i = 0;i&lt; size;i++)&#123; TreeNode* cur = que.front(); que.pop(); if(m &lt; cur-&gt;val)&#123; m = cur-&gt;val; &#125; if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; result.push_back(m); &#125; return result; &#125;&#125;; 116. 填充每个节点的下一个右侧节点指针给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;*/class Solution &#123;public: Node* connect(Node* root) &#123; queue&lt;Node*&gt; que; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; Node* cur; Node* preCur; int size = que.size(); for(int i = 0; i &lt; size;i++)&#123; if(i == 0)&#123; preCur = que.front(); que.pop(); cur = preCur; &#125;else&#123; cur = que.front(); que.pop(); preCur-&gt;next = cur; preCur = preCur-&gt;next; &#125; if(cur-&gt;left)&#123; que.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; que.push(cur-&gt;right); &#125; &#125; cur-&gt;next = NULL; &#125; return root; &#125;&#125;; 117. 填充每个节点的下一个右侧节点指针 II给定一个 二叉树 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;*/class Solution &#123;public: Node* connect(Node* root) &#123; queue&lt;Node*&gt; que; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; Node* node; Node* nodePre; int size = que.size(); for(int i = 0;i &lt; size;i++)&#123; if( i == 0 )&#123; nodePre = que.front(); que.pop(); node = nodePre; &#125;else&#123; node = que.front(); que.pop(); nodePre-&gt;next = node; nodePre = nodePre-&gt;next; &#125; if(node-&gt;left)&#123; que.push(node-&gt;left); &#125; if(node-&gt;right)&#123; que.push(node-&gt;right); &#125; &#125; nodePre-&gt;next = NULL; &#125; return root; &#125;&#125;; 226. 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if(root != NULL)&#123; que.push(root); &#125; while(!que.empty())&#123; int size = que.size(); TreeNode* node = que.front(); TreeNode* cur = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = cur; que.pop(); if(node-&gt;left)&#123; que.push(node-&gt;left); &#125; if(node-&gt;right)&#123; que.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; 101. 对称二叉树给你一个二叉树的根节点 root ，检查它是否轴对称。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: bool compare(TreeNode* left,TreeNode* right) &#123; if(left == NULL &amp;&amp; right != NULL)&#123; return false; &#125;else if(left != NULL &amp;&amp; right == NULL)&#123; return false; &#125;else if(left == NULL &amp;&amp; right == NULL)&#123; return true; &#125;else if((left-&gt;val != right-&gt;val))&#123; return false; &#125; bool compareOutside = compare(left-&gt;left,right-&gt;right); bool compareInside = compare(left-&gt;right,right-&gt;left); bool compareLast = compareOutside &amp;&amp; compareInside; return compareLast; &#125; bool isSymmetric(TreeNode* root) &#123; if(root == NULL)&#123; return true; &#125; return compare(root-&gt;left,root-&gt;right); &#125;&#125;; 或者 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if(root == NULL)&#123; return true; &#125; que.push(root-&gt;left); que.push(root-&gt;right); while(!que.empty())&#123; TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if( !leftNode &amp;&amp; !rightNode )&#123; continue; &#125; if( !leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))&#123; return false; &#125; que.push(leftNode-&gt;left); que.push(rightNode-&gt;right); que.push(leftNode-&gt;right); que.push(rightNode-&gt;left); &#125; return true; &#125;&#125;;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"往期回顾","slug":"往期回顾","permalink":"https://merr0r.github.io/tags/%E5%BE%80%E6%9C%9F%E5%9B%9E%E9%A1%BE/"}]},{"title":"First learning record in June","slug":"record06","date":"2022-06-04T16:00:00.000Z","updated":"2022-06-05T12:21:58.526Z","comments":true,"path":"2022/06/05/record06/","link":"","permalink":"https://merr0r.github.io/2022/06/05/record06/","excerpt":"分享六月第一周学习内容","text":"分享六月第一周学习内容 二叉树入门学习144. 二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的前序遍历。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root == NULL)&#123; return result; &#125; st.push(root); while(!st.empty())&#123; TreeNode* node = st.top(); st.pop(); result.push_back(node -&gt; val); if(node-&gt;right) st.push(node-&gt;right); if(node-&gt;left) st.push(node-&gt;left); &#125; return result; &#125;&#125;; 145. 二叉树的后序遍历给你二叉树的根节点 root ，返回它节点值的后序遍历。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root == NULL)&#123; return result; &#125; st.push(root); while(!st.empty())&#123; TreeNode* node = st.top(); st.pop(); result.push_back(node -&gt; val); if(node-&gt;left) st.push(node-&gt;left); if(node-&gt;right) st.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 94. 二叉树的中序遍历给你二叉树的根节点 root ，返回它节点值的中序遍历。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while(cur != NULL || !st.empty())&#123; if(cur != NULL)&#123; st.push(cur); cur = cur-&gt;left; &#125;else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return result; &#125;&#125;; 为了方便理解，放c++环境中进行测试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;vector&gt;#include&lt;iostream&gt;#include &lt;stack&gt;using namespace std;struct treeNode &#123; //树的结点 char data; //保存数据 treeNode *left; //左子树 treeNode *right; //右子树&#125;;//创建树struct treeNode* createNode(char data) &#123; struct treeNode* newNode = (struct treeNode*)malloc(sizeof(struct treeNode)); newNode-&gt;data = data; newNode-&gt;left = NULL; newNode-&gt;right = NULL; return newNode;&#125;//连接结点void insertNode(struct treeNode* curNode, struct treeNode* leftNode, struct treeNode* rightNode) &#123; curNode-&gt;left = leftNode; curNode-&gt;right = rightNode;&#125;//中序遍历vector&lt;char&gt; iNorderTraversal(treeNode* root) &#123; vector&lt;char&gt; result; stack&lt;treeNode*&gt; st; treeNode* cur = root; while (cur != NULL || !st.empty()) &#123; if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left; &#125; else &#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; &#125; return result;&#125;int main() &#123; //创建所有的结点 struct treeNode* A = createNode(&#x27;A&#x27;); struct treeNode* B = createNode(&#x27;B&#x27;); struct treeNode* C = createNode(&#x27;C&#x27;); struct treeNode* D = createNode(&#x27;D&#x27;); struct treeNode* E = createNode(&#x27;E&#x27;); struct treeNode* F = createNode(&#x27;F&#x27;); struct treeNode* G = createNode(&#x27;G&#x27;); struct treeNode* K = createNode(&#x27;K&#x27;); //做连接操作 insertNode(A, B, C); insertNode(B, D, E); insertNode(C, F, G); insertNode(F, NULL, K); vector&lt;char&gt; result1 = iNorderTraversal(A); for (int i = 0; i&lt;result1.size(); ++i) &#123; cout &lt;&lt; result1[i] &lt;&lt; &quot; &quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 我们通过insertNode和createNode创建如图所示的树 直接从iNorderTraversal的while循环开始：第一次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第二次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第三次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第四次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; 第五次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; 第六次循环 cur !&#x3D; NULL 所以允许循环并且执行if条件语句 1234if (cur != NULL) &#123; st.push(cur); cur = cur-&gt;left;&#125; 第七次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; 第八次循环 cur &#x3D;&#x3D; NULL 但 !st.empty() 为 true 所以允许循环并且执行else条件语句 123456else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;data); cur = cur-&gt;right; &#125; …………后面跟前面一样就不再赘述了~ 94. 二叉树的中序遍历(统一迭代法)给你二叉树的根节点 root ，返回它节点值的中序遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root != NULL)&#123; st.push(root); &#125; while(!st.empty())&#123; TreeNode* node = st.top(); if(node != NULL)&#123; st.pop(); if(node -&gt; right)&#123; st.push(node -&gt; right); &#125; st.push(node); st.push(NULL); if(node -&gt; left)&#123; st.push(node -&gt; left); &#125; &#125;else&#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;; 94. 二叉树的前序遍历(统一迭代法)给你二叉树的根节点 root ，返回它节点值的前序遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root != NULL)&#123; st.push(root); &#125; while(!st.empty())&#123; TreeNode* node = st.top(); if(node != NULL)&#123; st.pop(); if(node-&gt;right)&#123; st.push(node-&gt;right); &#125; if(node-&gt;left)&#123; st.push(node-&gt;left); &#125; st.push(node); st.push(NULL); &#125;else&#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Third learning record in May","slug":"record05","date":"2022-05-29T16:00:00.000Z","updated":"2022-05-30T01:32:54.853Z","comments":true,"path":"2022/05/30/record05/","link":"","permalink":"https://merr0r.github.io/2022/05/30/record05/","excerpt":"分享五月第三周学习内容","text":"分享五月第三周学习内容 动态规划入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 322. 零钱兑换给你一个整数数组coins，表示不同面额的硬币；以及一个整数amount，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1 。你可以认为每种硬币的数量是无限的。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1,INT_MAX); dp[0] = 0; for(int i = 1;i &lt;= amount;i++)&#123; for(int j = 0;j &lt; coins.size();j++)&#123; if(coins[j] &lt;= i &amp;&amp; dp[i - coins[j]] != INT_MAX) &#123; dp[i] = min(dp[i],dp[i - coins[j]] + 1); &#125; &#125; &#125; if(dp[amount] == INT_MAX)&#123; return -1; &#125; return dp[amount]; &#125;&#125;; 整体分析：把不同面额的硬币视为物品，面额视为物品的重量，总金额amount视为背包重量。本题要求的是最少的银币个数，所以要求的不是“组合”个数，而是“物品个数”，因此并不是“组合”问题。而且每种硬币的数量是无限的，所以是“完全背包”问题。1.确定dp数组(dp table)以及下标的含义因为这里只有一个限制条件，即背包重量，所以dp肯定是一维。所以dp[i]的含义为：重量为i的背包能容纳最少的物品数量&lt;&#x3D;&gt;凑成总金额为i的最少银币个数。2.确认状态转移方程，即递推公式本题求的是最少的“物品个数”，所以dp[i] &#x3D; min(dp[i],dp[i - coins[j]] + 1)3.dp数组如何初始化首先dp[0] &#x3D; 0，因为面额为0个数也为0.但dp其他数字默认为0，那么在min(dp[i],dp[i - coins[j]] + 1)就一直为0，所以我们因把dp其他数字初始化为INT_MAX。4.遍历顺序的确定这题涉及的是完全背包的问题。完全背包的背包遍历顺序是从前往后遍历。物品由前往后遍历即可。5.推导整个dp数组 279. 完全平方数给你一个整数n，返回和为n的完全平方数的最少数量。完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和16都是完全平方数，而3和11不是。 先贴出答案，然后一步步讲解。 123456789101112131415class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1,INT_MAX); dp[0]=0; for(int i = 1;i*i&lt;= n;i++)&#123; for(int j = 0;j &lt;= n;j++)&#123; if(j - i*i &gt;= 0)&#123; dp[j] = min(dp[j],dp[j-i*i] + 1); &#125; &#125; &#125; return dp[n]; &#125;&#125;; 整体分析：整数n视为背包最大重量为n，完全平方数为物品的重量，且不限制数量，因此为“完全背包”问题。1.确定dp数组(dp table)以及下标的含义因为这里只有一个限制条件，即背包重量，所以dp肯定是一维。所以dp[i]的含义为：重量为i的背包能容纳最少的物品数量&lt;&#x3D;&gt;整数i最少能划分完全平方数的个数。2.确认状态转移方程，即递推公式dp[j] &#x3D; min(dp[j],dp[j-ii] + 1);3.dp数组如何初始化首先dp[0] &#x3D; 0，因为整数0最少能划分完全平方数的个数也为0.但dp其他数字默认为0，那么在min(dp[j],dp[j-ii] + 1)就一直为0，所以我们因把dp其他数字初始化为INT_MAX。4.遍历顺序的确定这题涉及的是完全背包的问题。完全背包的背包遍历顺序是从前往后遍历。物品由前往后遍历即可。5.推导整个dp数组 139. 单词拆分给你一个字符串s和一个字符串列表wordDict作为字典。请你判断是否可以利用字典中出现的单词拼接出s。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 先贴出答案，然后一步步讲解。 123456789101112131415161718class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); int m = s.length(); vector&lt;bool&gt; dp(m + 1,false); dp[0] = true; for(int i = 1;i &lt;= m;i++)&#123; for(int j = 0;j &lt; i;j++)&#123; string word = s.substr( j , i - j ); if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]) &#123; dp[i] = true; &#125; &#125; &#125; return dp[m]; &#125;&#125;; 整体分析：字符串s为背包，字典里的字符串为物品。本题跟之前的题不同，以往的题要么求“最大重量”要么是“组合数量”，他们的“限制条件”我们直接无脑堆物品就完事了。但这题的“限制条件”不允许我们无脑堆物品，而是只允许“符合条件的物品”。“限制条件”比以前更严格，但思路依旧能用借鉴以前的题。假设整个字符串s为dp，背包从0开始，先搜索dp第一个字符，相当于dp里有两个指针，左指针j在0，右指针i在1，说明我们要确定从字典里的字符是否匹配得上指针j到i里的字符，指针里的字符数量逐渐递减，即左指针j右移。如果有匹配的字符，则右指针返回一个true。之和我们的左指针j在0，右指针i在2，判断字典里的字符是否匹配得上指针j到i里的字符，如果有匹配的字符，且左指针j是true即左指针j之前的字符串都能从字典里匹配到相应的字符串，则右指针返回一个true。1.确定dp数组(dp table)以及下标的含义dp类型为bool，dp[i]表示字符串前i个字符是否能匹配上。2.确认状态转移方程，即递推公式如果指针里的字符能匹配到字典里的字符且左指针为true，那么右指针为true。dp[i] &#x3D; true;3.dp数组如何初始化当字符串s啥也没有的时候，那一定为true。所以dp[0] &#x3D; true;其他都为false4.遍历顺序的确定因为字典里的字符串能重复使用，所以类似于“完全背包”问题，所以字典里的字符串从前往后遍历。5.推导整个dp数组 leetcode 热题HOT 10010. 正则表达式匹配给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘‘ 的正则表达式匹配。‘.’ 匹配任意单个字符‘‘ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 先贴出答案，然后一步步讲解。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); dp[0][0] = true; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[0][j] = dp[0][j-1]; &#125;else if(j + 1 &gt; n || p[j + 1] != &#x27;*&#x27;)&#123; break; &#125;else&#123; dp[0][j] = true; &#125; &#125; for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1]; continue; &#125; if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1] || (dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])) || (dp[i - 1][j] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])); &#125;else&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 这题运用到了动态规划的知识。首先对整体进行分析：一个字符串 s 与一个字符规律 p 相匹配，我们首先在s和p字符最前面添加一个‘0’字符，为了之后能很好的描述此题。比如s第i个字符不再是s[i - 1]而是s[i]。 123456789class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); &#125;&#125;; 如果s选取前i个字符能与p前j个字符相匹配，而且本题的函数类型为bool。于是我们可以令dp[i][j]为：s前i个字符能与p前j个字符相匹配。我们把框架写下： 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); return dp[m][n]; &#125;&#125;; 接下来讨论状态方程。先理解题意。“ ‘*’ 匹配零个或多个前面的那一个元素 ”说明 *跟前面一个字符是绑定在一起，比如a *,要么是0个a，要么是1个a，要么是好几个a。因为当我们讨论s前i个字符能与否p前j个字符相匹配时，还得看p的第j+1字符是否为’ * ‘。不考虑’.’。当p的第j个字符为英文小写，先判断p的第j+1字符是否为’ * ‘。如果不是或者是超过字符串p的最长长度，说明p的第j个字符是独立的，不与第j+1字符绑定。我们想判断dp[i][j]是否为true，只需判断s的第i个字符与p的第j个字符相等以及之前的字符能匹配得上，这里就发生了“状态转移”。 123if(j + 1 &gt; n || p[j + 1] != &#x27;*&#x27;)&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; ( s[i] == p[j]);&#125; 当p的第j个字符为英文小写，且p的第j+1字符为’ * ‘。说明p的第j个字符与第j+1字符是绑定在一起的，于是我们把第j个字符与第j+1个字符看成一个整体A。所以这里分三种情况，这个整体A视为没有第j字符、一个第j字符和多个第j字符。当s的第i个字符不等于p的第j个字符时，如要满足题意，这个整体A需视为没有第j字符。即 123if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1];&#125; 当s的第i个字符等于p的第j个字符时，且s的第i个字符与相邻的字符不重复，整体A视为一个第j字符，即 123if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i] == p[j])&#125; 当s的第i个字符等于p的第j个字符时，且s的第i个字符与相邻的字符有重复，整体A视为多第j字符，即 123if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i - 1][j] &amp;&amp; (s[i] == p[j]);&#125; 当p的第j个字符为’ * ‘。因为’ * ‘都会跟前一个字符绑定，所以当前状态因与第j-1字符状态一样。即 123if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1];&#125; 考虑’.’的情况。只要出现’.’，就相当于“s[i] &#x3D;&#x3D; p[j]”。所以在之前的状态转移补充一个或条件即可。 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1]; continue; &#125; if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1] || (dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])) || (dp[i - 1][j] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])); &#125;else&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 接下来讨论初始化问题。首先当s的第0个字符与p的第0个字符毫无疑问是相同的。所以dp[0][0]&#x3D;true。另外得考虑一个极端情况，比如s字符串为空串，而p字符和a* b* c，因为a可以视为空串，所以这种情况也是符合的。所以 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); s.insert(s.begin(),&#x27;0&#x27;); p.insert(p.begin(),&#x27;0&#x27;); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1,vector&lt;bool&gt;(n + 1,false)); dp[0][0] = true; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[0][j] = dp[0][j-1]; &#125;else if(j + 1 &gt; n || p[j + 1] != &#x27;*&#x27;)&#123; break; &#125;else&#123; dp[0][j] = true; &#125; &#125; for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(p[j] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1]; continue; &#125; if(j + 1 &lt;= n &amp;&amp; p[j + 1] == &#x27;*&#x27;)&#123; dp[i][j] = dp[i][j - 1] || (dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])) || (dp[i - 1][j] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j])); &#125;else&#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (p[j] == &#x27;.&#x27; || s[i] == p[j]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 二叉树入门学习一棵树是一些节点(node)的集合。可以为空集，如果不是空集，则树由根节点以及0个或多个子树组成，根节点没有前驱结点。 图中根节点就是没有父结点的结点，叶子结点就是没有子节点的结点。 下面介绍一些与树相关的概念（以上面的树为例）：（1）结点的度：一个节点含有的子树的个数称为该节点的度；如上图：A的为6，即B、C、D、E、F、G。（2）叶结点：度为0的节点称为叶结点；如上图：B、C、H、I…等为叶结点。（3）双亲结点或父结点：若一个节点含有子结点，则这个结点称为其子结点的父结点；如上图：A是B的父结点。（4）孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；如上图：B是A的孩子节点。（5）兄弟结点：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点。（6）树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6。（7）结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。（8）树的高度或深度：树中结点的最大层次； 如上图：树的高度为4。（9）节点的祖先：从根到某一结点所经分支上的所有结点；如上图：D、A是H的祖先；A是所有结点的公共祖先。（10）子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙。（11）森林：多棵互不相交的树的集合称为森林。 二叉树的储存方式为链式存储。 因此代码可编写为： 123456struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; 比如我们想创建如下图这样的一棵树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct treeNode &#123; //树的结点 char data; //保存数据 treeNode *left; //左子树 treeNode *right; //右子树&#125;;//1.创建树struct treeNode* createNode(char data) &#123; struct treeNode* newNode = (struct treeNode*)malloc(sizeof(struct treeNode)); newNode-&gt;data = data; newNode-&gt;left = NULL; newNode-&gt;right = NULL; return newNode;&#125;//2.连接结点void insertNode(struct treeNode* curNode, struct treeNode* leftNode, struct treeNode* rightNode) &#123; curNode-&gt;left = leftNode; curNode-&gt;right = rightNode;&#125;//3.递归中序遍历void printData(struct treeNode* curNode) &#123; printf(&quot;%c&quot;, curNode-&gt;data);&#125;void midOrder(struct treeNode* tree) &#123; if (tree != NULL) &#123; midOrder(tree-&gt;left); //左 printData(tree); //根 midOrder(tree-&gt;right); //右 &#125;&#125;//4.递归前序遍历void preOrder(struct treeNode* tree) &#123; if (tree != NULL) &#123; printData(tree); //根 preOrder(tree-&gt;left); //左 preOrder(tree-&gt;right); //右 &#125;&#125;//5.递归后序遍历void lastOrder(struct treeNode* tree) &#123; if (tree != NULL) &#123; lastOrder(tree-&gt;left); //左 lastOrder(tree-&gt;right); //右 printData(tree); //根 &#125;&#125;//6.非遍历的方式void midOrderByStact(struct treeNode* tree) &#123; if (tree == NULL) &#123; return; &#125; struct treeNode* stack[10]; int stackTop = -1; struct treeNode* pMove = tree; while (stackTop != -1 || pMove != NULL) &#123; while (pMove != NULL) &#123; stack[++stackTop] = pMove; pMove = pMove-&gt;left; &#125; if (stackTop != -1) &#123; pMove = stack[stackTop--]; printf(&quot;%c\\t&quot;, pMove-&gt;data); pMove = pMove-&gt;right; &#125; &#125;&#125;int main() &#123; //1.创建所有的结点 struct treeNode* A = createNode(&#x27;A&#x27;); struct treeNode* B = createNode(&#x27;B&#x27;); struct treeNode* C = createNode(&#x27;C&#x27;); struct treeNode* D = createNode(&#x27;D&#x27;); struct treeNode* E = createNode(&#x27;E&#x27;); struct treeNode* F = createNode(&#x27;F&#x27;); struct treeNode* G = createNode(&#x27;G&#x27;); struct treeNode* K = createNode(&#x27;K&#x27;); //做连接操作 insertNode(A, B, C); insertNode(B, D, E); insertNode(C, F, G); insertNode(F, NULL, K); midOrder(A); printf(&quot;\\n&quot;); lastOrder(A); printf(&quot;\\n&quot;); preOrder(A); printf(&quot;\\n&quot;); midOrderByStact(A); printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 接下来对此树进行遍历。遍历顺序分为前序遍历、中序遍历和后序遍历。前序遍历： 中 左 右中序遍历： 左 中 右后序遍历： 左 右 中对于上题来说前序遍历： ABDECFKG中序遍历： DBEAFKCG后序遍历： DEBKFGCA3、4、5用了递归的思想。6非遍历的方式用了栈的思路，即先进后出。 1234567891011121314151617181920void midOrderByStact(struct treeNode* tree) &#123; if (tree == NULL) &#123; return; &#125; //先判断是否是空树 struct treeNode* stack[10]; //初始化一个栈 int stackTop = -1; //入栈一个元素 struct treeNode* pMove = tree; //定义一个指针，初始指向树的根节点 while (stackTop != -1 || pMove != NULL) &#123; while (pMove != NULL) &#123; stack[++stackTop] = pMove; pMove = pMove-&gt;left; &#125; //遍历到树的最左边 if (stackTop != -1) &#123; pMove = stack[stackTop--]; printf(&quot;%c\\t&quot;, pMove-&gt;data); //输出pMove指向的结点数据 pMove = pMove-&gt;right; //遍历右边 &#125; &#125;&#125; 144. 二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的前序遍历。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; traversal(root,result); return result; &#125; void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec)&#123; if(node == NULL)&#123; return; &#125; vec.push_back(node-&gt;val); traversal(node-&gt;left,vec); traversal(node-&gt;right,vec); &#125;&#125;; 145. 二叉树的后序遍历给你二叉树的根节点 root ，返回它节点值的后序遍历。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; vec; traversal(root,vec); return vec; &#125; void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec)&#123; if(node == NULL)&#123; return; &#125; traversal(node-&gt;left,vec); traversal(node-&gt;right,vec); vec.push_back(node-&gt;val); &#125;&#125;; 94. 二叉树的中序遍历给你二叉树的根节点 root ，返回它节点值的中序遍历。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; vec; traversal(root,vec); return vec; &#125; void traversal(TreeNode* root,vector&lt;int&gt;&amp; vec)&#123; if( root == NULL)&#123; return; &#125; traversal(root-&gt;left,vec); vec.push_back(root-&gt;val); traversal(root-&gt;right,vec); &#125;&#125;;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Second learning record in May","slug":"record04","date":"2022-05-14T16:00:00.000Z","updated":"2022-05-16T01:33:16.484Z","comments":true,"path":"2022/05/15/record04/","link":"","permalink":"https://merr0r.github.io/2022/05/15/record04/","excerpt":"分享五月第二周学习内容","text":"分享五月第二周学习内容 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 1049. 最后一块石头的重量 II有一堆石头，用整数数组stones表示。其中 stones[i] 表示第i块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x &lt;&#x3D; y。那么粉碎的可能结果如下：如果x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；如果x !&#x3D; y，那么重量为x的石头将会完全粉碎，而重量为y的石头新重量为y-x。最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回0。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; vector&lt;int&gt; dp(15001,0); int sum = 0; for(int i = 0;i &lt; stones.size();i++)&#123; sum += stones[i]; &#125; int target = sum / 2; for(int i = 0;i &lt; stones.size();i++)&#123; for(int j = target;j &gt;= stones[i];j--)&#123; dp[j] = max(dp[j],dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[target] - dp[target]; &#125;&#125;; dp的含义？这题跟上周写的“分割等和子集”类似，只不过换了种表达方式。“石头碰撞后最小重量”可以翻译为：石头分为两个背包，两个背包的和尽可能相近，最好相等。所以dp跟“分割等和子集”类似。在“分割等和子集”理，dp[j]的含义为背包重量为j时能容量最大的数字和。所以在这题可以理解为背包重量之和为j时能能容量最大的数字和dp来源？“分割等和子集”的dp[j]来源为dp[j]自身的重量与dp[j-nums[i]]+nums[i]的最大值。因此本题的dp来源为 dp[j]与dp[j - stones[i]] + stones[i]的最大值。dp的初始化？默认为0。遍历顺序？石头的选择从头开始遍历到最后，背包的重量从最大开始遍历。 494. 目标和给你一个整数数组nums和一个整数target。向数组中的每个整数前添加’+’或’-‘，然后串联起所有整数，可以构造一个表达式：例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式”+2-1” 。返回可以通过上述方法构造的、运算结果等于target的不同表达式的数目。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int m = nums.size(); int sums = 0; for(int i = 0;i &lt; m;i++)&#123; sums += nums[i]; &#125; if(target &gt; sums)&#123; return 0; &#125; if((target + sums) % 2 == 1 || (target + sums) &lt; 0)&#123; return 0; &#125; int targetBag = (sums + target) / 2; vector&lt;int&gt; dp(targetBag + 1,0); dp[0] = 1; for(int i = 0;i &lt; m;i++)&#123; for(int j = targetBag;j &gt;= nums[i];j--)&#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[targetBag]; &#125;&#125;; 1.确定dp数组(dp table)以及下标的含义本题比较特殊，之前求的要么是背包的最大重量要么是背包里的物品的最大价值。但本题求的是不同表达式的组合数目，但思路还是能借鉴。比如之前的dp都是求最大物品重量，那么我们把这题分成两个背包，一个背包数字和为A，另一个背包数字和为B。A+B&#x3D;整数数组nums所有元素之和，A-B为target。所以我们只要讨论A和B其中一个背包，另一个背包也就直接出来。我们这里讨论A背包。dp[j]理解为当A背包里的数字和j时的不同组合方式最多为dp[j]种。2.确认状态转移方程，即递推公式模仿之前的题，我们的dp[j]的来源就为dp[j]本身与dp[j - nums[i]]的最大值，但这种方法是求最大“重量数”，而我们要求的是最大的“组合数”。打个比方：5的的组合方法有很多：1+4，2+3,3+2,4+1。当1为已知时，我们就得确认4的组合方法数量。当2为已知时，我们就得确认3的组合方法数量。当3为已知时，我们就得确认2的组合方法数量……所以5的最大组合方法数量为1+4，2+3,3+2,4+1的最大组合数之和，所以我们dp来源应该是某种数量的叠加。继续打比方：5的的组合方法有很多，但物品栏只有1和3，因此我们只需探求1和3时候的最大组合数量。即当1为已知时，我们就得确认4的组合方法数量。当3为已知时，我们就得确认2的组合方法数量，5的最大组合数量应为1+4,3+2的最大组合数之和。所以dp[j]的来源应为dp[j]+dp[j - nums[i]]。3.dp数组如何初始化因为dp[j]的来源应为dp[j]与dp[j - nums[i]]叠加，所以如果令dp[0]初始值为0，那后面的叠加全是0。然后根据我们对题目的分析，如果target为0的话也就是j&#x3D;0，那我们dp[0]初始值为1？说实话，在[代码随想录].pdf的解释为“装满容量为0的背包，有1种⽅法，就是装0件物品。”我觉得还是有点牵强，但我也不晓得如何解释(恼火)。4.遍历顺序的确定首先确定dp的末端数字，我们已经整数数组nums和一个整数target，我们可以根据一个背包数字和为A，另一个背包数字和为B。A+B&#x3D;整数数组nums所有元素之和，A-B为target得到(A的大小为nums所有元素之和+target)&#x2F;2，物品(nums元素)从头遍历，背包从end开始往前遍历。5.推导整个dp数组 474. 一和零给你一个二进制字符串数组strs和两个整数m和n。请你找出并返回strs的最大子集的长度，该子集中最多有m个0和n个1。如果x的所有元素也是y的元素，集合x是集合y的子集。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; getZeroOnes(string&amp; str)&#123; vector&lt;int&gt; zeroOnes(2,0); for(int i = 0;i&lt;str.length();i++)&#123; zeroOnes[str[i]-&#x27;0&#x27;]++; &#125; return zeroOnes; &#125; int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int l = 0;l &lt; strs.size();l++)&#123; vector&lt;int&gt; zero0nes = getZeroOnes(strs[l]); for(int i = m;i&gt;=zero0nes[0];i--)&#123; for(int j = n;j&gt;=zero0nes[1];j--)&#123; dp[i][j] = max(dp[i][j],dp[i - zero0nes[0]][j - zero0nes[1]] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 这题首先算出字符串数组strs里各个元素所含的0和1的个数，通过getZeroOnes函数，构建一个1x2向量，向量第0个位置代表0的数量，向量第1个位置代表1的数量。利用str[i]-‘0’的特性实现对元素含有1和0个数的计算。1.确定dp数组(dp table)以及下标的含义本题要求所选的元素的0和1个数和分别小于m和n，其实可以看做背包装一个物品，0的个数代表物品重量，1的个数代表物品价值。这个物品既要满足重量小于m，又要满足价值小于n。相比以往的题目即重量小于背包重量，价值取最大。多了一个限制条件。因此我们要在以往的题型基础上进行一个改进。以往对于只有一个条件即重量小于背包重量我们可以列dp[i][j]，又能dp[j]，我们一般采用后者，即dp[j]。现在多了一个条件即价值小于n，所以我们在这采用dp[i][j]。含义为0的个数最多为i，1的个数最多为j时，能在字符串数组sts中最多能挑选的元素个数为l。2.确认状态转移方程，即递推公式dp[i][j]的最大值要么来源于上次循环保留下来的dp[i][j]或者i&gt;&#x3D;zero0nes[0],j&gt;&#x3D;zero0nes[1]时，计算dp[i-zero0nes[0]][j - zero0nes[1]]的元素个数，再+1。即dp[i][j] &#x3D; max(dp[i][j],dp[i - zero0nes[0]][j - zero0nes[1]] + 1)。3.dp数组如何初始化再以往的题即“重量小于背包重量，价值取最大”中，一维数组dp默认为0.这题虽然有两个限制条件，但内核跟以往的题一模一样。所以同理，此题的初始化应全为0。4.遍历顺序的确定再以往的题即“重量小于背包重量，价值取最大”中，一维数组dp都是从后往前遍历，本题也如此，两个条件从后往前遍历。5.推导整个dp数组 完全背包有N件物品和⼀个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品都有⽆限个（也就是可以放⼊背包多次），求解将哪些物品装⼊背包⾥物品价值总和最⼤。先贴出答案，然后一步步讲解。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble2() &#123; vector&lt;int&gt; weight = &#123; 1 , 3 , 4 &#125;; vector&lt;int&gt; value = &#123; 15 , 20, 30 &#125;; int bagweight = 4; vector&lt;int&gt; dp1(bagweight + 1, 0); for (int i = 0; i &lt; weight.size(); i++) &#123; for (int j = bagweight; j &gt;= weight[i]; j--) &#123; int we = j / weight[i]; dp1[j] = max(dp1[j], dp1[j - weight[i]*we] + value[i] * we); &#125; &#125; cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble2(); system(&quot;pause&quot;); return 0;&#125;\\\\本人写的 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble2() &#123; vector&lt;int&gt; weight = &#123; 1 , 3 , 4 &#125;; vector&lt;int&gt; value = &#123; 15 , 20, 30 &#125;; int bagweight = 4; vector&lt;int&gt; dp1(bagweight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) &#123; for(int j = weight[i]; j &lt;= bagweight; j++) &#123; dp1[j] = max(dp1[j], dp1[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble2(); system(&quot;pause&quot;); return 0;&#125;\\\\代码随想录上的 此题为[代码随想录].pdf上的一道完全背包题目，所以运行环境不在LeetCode上而是在VS studio上。1.确定dp数组(dp table)以及下标的含义完全背包跟之前的背包不同，之前的背包有物品数量限制，但是完全背包是没有物品数量限制，也就是说可以同样的物品可以重复叠加。虽然有所区别，但原理还是一样。dp[j]意为背包重量为j时的最大价值。2.确认状态转移方程，即递推公式dp[j]来源于上一个循环的dp[j]与j&gt;&#x3D;weight[i]时 dp[j - weight[i]] + value[i]。3.dp数组如何初始化背包初始价值全部为0即可。4.遍历顺序的确定之前我们限制物品数量时都是从后往前遍历的。现在没有了物品数量限制，直接从前往后遍历，从前往后遍历能使同样的物品放在重量为j的背包中重复叠加。5.推导整个dp数组 518.零钱兑换 II给你一个整数数组coins表示不同面额的硬币，另给一个整数amount表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回0。假设每一种面额的硬币有无限个。 题目数据保证结果符合32位带符号整数。 先贴出答案，然后一步步讲解。 12345678910111213class Solution &#123;public: int change(int amount, vector&lt;int&gt;&amp; coins) &#123; vector&lt;int&gt; dp(amount + 1,0); dp[0] = 1; for(int i = 0;i &lt; coins.size();i++)&#123; for(int j = coins[i];j &lt;= amount;j++)&#123; dp[j] += dp[j - coins[i]]; &#125; &#125; return dp[amount]; &#125;&#125;; 1.确定dp数组(dp table)以及下标的含义本题为完全背包+组合(组合不分排序)。amount看成背包重量，“硬币组合数”可以看成物品的组合数，所以拿之前的[完全背包]与[目标和]两题进行一个缝合。dp[j]为重量为j时，最大的排列数为dp[j]，2.确认状态转移方程，即递推公式dp[j] +&#x3D; dp[j - coins[i]];3.dp数组如何初始化dp[0]&#x3D;14.遍历顺序的确定物品重量也就是组合数，从5.推导整个dp数组 377. 组合总和 Ⅳ给你一个由不同整数组成的数组nums，和一个目标整数target。请你从nums中找出并返回总和为target的元素组合的个数。题目数据保证答案符合 32 位整数范围。 先贴出答案，然后一步步讲解。 123456789101112131415class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; dp(target+1,0); dp[0] = 1; for(int i = 0;i &lt;= target;i++)&#123; for(int j = 0;j &lt; nums.size();j++)&#123; if(nums[j] &lt;= i &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]])&#123; dp[i] += dp[i - nums[j]]; &#125; &#125; &#125; return dp[target]; &#125;&#125;; 1.确定dp数组(dp table)以及下标的含义本题为完全背包+组合(组合分排序)。amount看成背包重量，“硬币组合数”可以看成物品的组合数，所以拿之前的[完全背包]与[目标和]两题进行一个缝合。dp[j]为重量为j时，最大的排列数为dp[j]，2.确认状态转移方程，即递推公式dp[j] +&#x3D; dp[j - coins[i]];3.dp数组如何初始化dp[0]&#x3D;14.遍历顺序的确定如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。5.推导整个dp数组 70. 爬楼梯(重制版)假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 先贴出答案，然后一步步讲解。 123456789101112131415class Solution &#123;public: int climbStairs(int n) &#123; if(n == 1) return n; vector&lt;int&gt; dp(n+1,0); dp[1]= 1; dp[2] = 2; for(int i = 3;i&lt;=n;i++)&#123; for(int j = 1;j &lt;= 2;j++)&#123; dp[i] += dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125;; OK~动态规划就学这么多，预计学到单词拆分就继续回到刷LeetCode题目。如果遇到新的算法就跟着[代码随想录].pdf刷算法专题(周末去的新区图书馆，但新区uu的特别招待，下午KTV晚上出去干饭- -，所以周一连忙补上学习内容T_T)。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"First learning record in May","slug":"record03","date":"2022-05-05T16:00:00.000Z","updated":"2022-05-08T13:38:25.777Z","comments":true,"path":"2022/05/06/record03/","link":"","permalink":"https://merr0r.github.io/2022/05/06/record03/","excerpt":"分享五月第一周学习内容","text":"分享五月第一周学习内容 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 343. 整数拆分给定一个正整数n，将其拆分为k个正整数的和（k &gt;&#x3D; 2），并使这些整数的乘积最大化。返回你可以获得的最大乘积。 先贴出答案，然后一步步讲解。 12345678910111213class Solution &#123;public: int integerBreak(int n) &#123; vector&lt;int&gt; dp(n+1); dp[2] = 1; for(int i = 2;i &lt;= n;i++)&#123; for(int j = 1;j &lt; i/2+1;j++)&#123; dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j)); &#125; &#125; return dp[n]; &#125;&#125;; 首先举个栗子当n&#x3D;2时，拆分的数字为1和1。乘积为1。当n&#x3D;3时，拆分的数字为2和1。乘积为2。当n&#x3D;4时，拆分的数字为2和2。乘积为4。当n&#x3D;5时，拆分的数字为2和3。乘积为6。当n&#x3D;6时，拆分的数字为3和3。乘积为9。当n&#x3D;7时，拆分的数字为2、3和2或者4和3。乘积为12。当n&#x3D;8时，拆分的数字为2、3和3。乘积为18。当n&#x3D;9时，拆分的数字为3、3和3。乘积为27。当n&#x3D;10时，拆分的数字为2、3、2和3。乘积为36。首先第一步要从这些栗子中找到动态规划的规律，我们才能列出dp的含义以及动态方程。乍一看没啥思路，其实我们可以把栗子作进一步拆解。当n&#x3D;2时，拆分的数字为1和1。最大乘积为1。当n&#x3D;3时，拆分的数字为2和1。2的最大乘积乘以1等于1，2的本身乘以1等于2。于是3的最大乘积等于2。当n&#x3D;4时，第一种拆分的数字为3和1。3的最大乘积乘以1等于2，3的本体乘以1等于3；第二种拆分的数字为2和2，2的最大乘积乘以2等于2，2的本身乘以2等于4。于是4的最大乘积等于4。当n&#x3D;5时，第一种拆分方式为4和1。4的最大乘积乘以1等于4，4的本身乘以1等于4。第二种拆分方式为3和2，3的最大乘积乘以2等于4，3的本身乘以2等于6。于是5的最大乘积等于6。当n&#x3D;6时，第一种拆分方式为4和2(1直接略过)。4的最大乘积乘以2等于8，4的本身乘以2等于8。第二种拆分方式为3和3。3的最大乘积乘以3等于6，3的本身乘以3等于9。于是6的最大乘积等于9。当n&#x3D;7时，第一种拆分方式为5和2(1直接略过)。5的最大乘积乘以2等于12，5的本身乘以2等于10。第二种拆分方式为4和3。4的最大乘积乘以3等于12，4的本身乘以3等于12。于是7的最大乘积等于12。当n&#x3D;8时，第一种拆分方式为6和2(1直接略过)。6的最大乘积乘以2等于18，6的本身乘以2等于12。第二种拆分方式为5和3。5的最大乘积乘以3等于18，5的本身乘以3等于15。第三种拆分方式为4和4。4的最大乘积乘以4等于16，4的本身乘以4等于16。于是8的最大乘积等于18。当n&#x3D;9时，第一种拆分方式为7和2(1直接略过)。7的最大乘积乘以2等于24，7的本身乘以2等于14。第二种拆分方式为6和3。6的最大乘积乘以3等于27，6的本身乘以3等于18。第三种拆分方式为5和4。5的最大乘积乘以4等于24，5的本身乘以4等于20。于是9的最大乘积等于27。当n&#x3D;10时，第一种拆分方式为8和2(1直接略过)。8的最大乘积乘以2等于36，8的本身乘以2等于16。第二种拆分方式为7和3。7的最大乘积乘以3等于36，7的本身乘以3等于21。第三种拆分方式为6和4。6的最大乘积乘以4等于36，6的本身乘以4等于24。第四种拆分方式为5和5。5的最大乘积乘以5等于30，5的本身乘以5等于25。于是10的最大乘积等于36。现在思路清晰了，我们先把数字A拆成1和A-1，直接讨论A-1的最大乘积大还是A-1本身大，最大的那个数乘以1得到的结果就是在1状态下数字A的最大乘积。继续把A拆成2和A-2，直接讨论A-2的最大乘积大还是A-2本身大，最大的那个数乘以2得到的结果就是在2状态下数字A的最大乘积……最后比较这些状态下的最大乘积，我们就能得到A的最大乘积。 1.确定dp数组(dp table)以及下标的含义 dp[i]的含义是在第i个数下的最大乘积。2.确认状态转移方程，即递推公式 dp[i] &#x3D; max(dp[i],max(dp[i-j]*j,(i-j)*j)) max(dp[i-j]*j,(i-j)*j)代表j状态下的i最大乘积，max里的dp[i]代表之前也就是j-1状态下的i最大乘积，两者需要相互比较。3.dp数组如何初始化 dp[2] &#x3D; 1;4.遍历顺序的确定 i表示从第2个数字，按照正序遍历到n。j就代表拆分下的j状态数字。5.推导整个dp数组 背包二维有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble() &#123; vector&lt;int&gt; weight = &#123;1 , 3 , 4&#125;; vector&lt;int&gt; value = &#123;15 , 20, 30 &#125;; int bagweight = 4; vector&lt;vector&lt;int&gt;&gt; dp(weight.size() + 1, vector&lt;int&gt;(bagweight + 1, 0)); for (int i = bagweight; i &gt;= weight[0]; i--) &#123; dp[0][i] = value[0]; &#125; for (int i = 1; i &lt; weight.size(); i++) &#123; for (int j = 0; j &lt;= bagweight; j++) &#123; if (j &lt; weight[i]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); &#125; &#125; &#125; cout &lt;&lt; dp[weight.size() - 1][bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble(); system(&quot;pause&quot;); return 0;&#125; 此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。首先我们联想一下上一道拆分数组。拆分数组的思路是把数字A拆分成1状态和A-1，然后搜寻A-1的最大值。然后拆分成2状态和A-2，然后搜寻1-2的最大值。我们照葫芦画瓢，运用到这题上：假设第一个物品重量为weight[0]，价值为value[0]。背包重量为j，我们就理解成当j&gt;weight[0]时，j此时的最大价值&#x3D;背包重量为j-weight[0]时的最大价值+value[0]。j&lt;weight[0]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。假设第二个物品重量为weight[1]，价值为value[1]。背包重量为j，我们就理解成当j&gt;weight[1]时，j此时的最大价值&#x3D;背包重量为j-weight[1]时的最大价值+value[1]。j&lt;weight[1]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。但怎么求“背包重量为W-weight[0]时的最大价值”呢？于是我们要遍历从0到W的背包重量，那么很容易看出dp应该是二维数组，dp[i][j]为背包重量为j时装第i个物品的最大价值。那么dp[i][j]是怎么来的？当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那怎么初始化？背包重量为0时，装不下任何物品，故dp[i][0]都为0。讨论第一个物品时，应该背包里没有其他物品，所以当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。 1.确定dp数组(dp table)以及下标的含义 dp[i][j]为背包重量为j时装第i个物品的最大价值。2.确认状态转移方程，即递推公式 当j&lt;weight[i]时，dp[i][j]&#x3D; dp[i - 1][j]。 当j&gt;weight[i]时，dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);3.dp数组如何初始化 dp[0][i] &#x3D; value[0] 当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。4.遍历顺序的确定 i代表物品，因为C++数组的原因，本应从0开始遍历，但之前初始化了，所以从1开始（也就是从第二个物品）开始遍历。j代表背包重量，从0开始5.推导整个dp数组 背包一维有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble() &#123; vector&lt;int&gt; weight = &#123; 1 , 3 , 4 &#125;; vector&lt;int&gt; value = &#123; 15 , 20, 30 &#125;; int bagweight = 4; vector&lt;int&gt; dp1(bagweight + 1, 0); for (int i = 0; i &lt; weight.size(); i++) &#123; for (int j = bagweight; j &gt;= weight[i]; j--) &#123; dp1[j] = max(dp1[j], dp1[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble(); system(&quot;pause&quot;); return 0;&#125; 此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。之前的dp为二维数组。那怎么运用到一维数组？二维dp数组的含义是 dp[i][j]为背包重量为j时装第i个物品的最大价值，dp[i]如果表示第i个物品的最大价值显然不行，那么表示成dp[j]为背包重量为j时的最大价值呢。那么dp[j]怎么来呢？回顾一下二维数组的dp来源当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那么更换成一维数组dp当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那么可以确认 dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i]) max里的dp[j]就是重量为j的背包装第i-1件时的物品时的最大值。那怎么初始化？众所周知重量为0时啥也装不下，所以价值必为0，所以dp[0] &#x3D; 0；从max和value不可能为负数可以得知，我们也可以把dp整个数组的数都初始为0，定义为0对之后在max里取最大值也没啥影响。遍历顺序怎么确定？如果是正序，那么会遇到一个问题。假如物品重量为1，价值为value[1]当j&#x3D;1时，dp[1]&#x3D;value[1]。当j&#x3D;2时候，因为dp[2] &#x3D; max(dp[2],dp[2 - weight[1]] + value[1])，max里的dp[2]&#x3D;0，dp[2 - weight[1]] + value[1]&#x3D;dp[1]+value[1]&#x3D;2xvalue[1]。也就是说在j&#x3D;2的时候value取了两次值。所以不能正序遍历，那逆序呢？当j&#x3D;4时，因为dp[4] &#x3D; max(dp[4],dp[4 - weight[1]] + value[1])，max里的dp[4]&#x3D;0，dp[4 - weight[1]] + value[1]&#x3D;dp[3]+value[1]&#x3D;value[1]。当j&#x3D;3时候，因为dp[3] &#x3D; max(dp[3],dp[3 - weight[1]] + value[1])，max里的dp[3]&#x3D;0，dp[3 - weight[1]] + value[1]&#x3D;dp[2]+value[1]&#x3D;value[1]。这样就不会产生取两次值的情况。 1.确定dp数组(dp table)以及下标的含义 dp[j]为背包重量为j时的最大价值。2.确认状态转移方程，即递推公式 dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i])3.dp数组如何初始化 dp[j]&#x3D; 04.遍历顺序的确定 逆序。5.推导整个dp数组 分割等和子集给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 先贴出答案，然后一步步讲解。 12345678910111213141516171819class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(int i = 0;i &lt; nums.size();i++)&#123; sum += nums[i]; &#125; if(sum % 2 == 1) return false; int sumHalf = sum/2; vector&lt;int&gt; dp(sumHalf + 1,0); for(int i = 0;i &lt; nums.size();i++)&#123; for(int j = sumHalf;j &gt;= nums[i];j--)&#123; dp[j] = max(dp[j],dp[j-nums[i]]+nums[i]); &#125; &#125; if(dp[sumHalf] == sumHalf) return true; return false; &#125;&#125;; 两个子集的元素和相等，可以推断出两个子集的元素和相加等于原数组nums各个数字之和，换句话说两个子集元素的和是nums各个元素和的一半，所以不难判断如果nums各个元素和为奇数，那么false。那么怎么确认dp[i]还是dp[i][j]？刚才我们分析出两个子集的元素和等于nums各个元素和的一半，我们令nums的和为sum，子集元素和为sumHalf。我们可以能把这题转换为刚才的背包问题，两个子集就是两个背包，sumHalf为背包重量，nums里的元素即为物品重量，这里的价值可以看成放入背包物品的最大重量，最大容量不能超过背包重量。根据之前的背包一维dp[j]为背包重量为j时的最大价值可以推断出dp[i]为背包重量为i时候的放入物品的最大重量。那么我要做的就是在背包重量为sumHalf时(dp[sumHalf])放入物品的最大重量等于sumHalf，那样的话另一个背包放入物品的最大重量必定sum-dp[sumHalf],如果sumHalf &#x3D;&#x3D; sum-dp[sumHalf]，或者dp[sumHalf] &#x3D; sumHalf，那直接返回true。那怎么初始化？跟之前一维背包一样，全部定义为0即可。遍历顺序跟一维背包一样，采用逆序。1.确定dp数组(dp table)以及下标的含义 dp[j]为背包重量为j时的放入物品的最大重量。2.确认状态转移方程，即递推公式 dp[j] &#x3D; max(dp[j],dp[j - nums[i]] + nums[i])3.dp数组如何初始化 dp[j]&#x3D; 04.遍历顺序的确定 逆序。5.推导整个dp数组 OK~动态规划就学这么多(其实还有一题- -)，因为最近学校解封，跟同学各种聚餐…所以就更了这么点- -下周好好干会来！！多学点知识！！","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Second learning record in April","slug":"record02","date":"2022-04-30T16:00:00.000Z","updated":"2022-05-01T13:53:48.532Z","comments":true,"path":"2022/05/01/record02/","link":"","permalink":"https://merr0r.github.io/2022/05/01/record02/","excerpt":"分享四月第二周学习内容","text":"分享四月第二周学习内容 leetcode 热题HOT 1003. 无重复字符的最长子串给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.length(); int ret = 0; int l = 0; unordered_map&lt;char,int&gt; Mirror; for(int i = 0;i &lt; n;i++)&#123; Mirror[s[i]]++; while(Mirror[s[i]] &gt;= 2)&#123; Mirror[s[l++]]--; &#125; ret = max(ret,i - l +1); &#125; return ret; &#125;&#125;; 本题的思路为：定义两个索引箭头指向字符串的两端，左端点的箭头先固定不动，右端点箭头右移进行索引，如果碰到重复字符，记录此时的长度，同时左端点往右移，直到没有重复字符为止。右端指针继续右移操作。重复上述过程 开始逐行分析与知识点回顾 123int n = s.length();int ret = 0;int l = 0; n为字符串长度，ret代表我们想返回的值，也就是最长子串的长度。l代表左端点指针 1unordered_map&lt;char,int&gt; Mirror; 定义一个名为Mirror的map容器，键值类型为char，用来存放单个字符。实值类型为int，用来存放字符在字符串的个数 特点是： 1.键只能有一个，但实值能有许多个 2.无序排列 3.通过 容器名[] 能直接添加键值 12345678for(int i = 0;i &lt; n;i++)&#123; Mirror[s[i]]++; while(Mirror[s[i]] &gt;= 2)&#123; Mirror[s[l++]]--; &#125; ret = max(ret,i - l +1); &#125; return ret; i代表右端点索引箭头，i++代表右端点箭头右移 Mirror[s[i]]++; 表示的是右端点指向字符存进map容器中，相应的实值从默认的0增加1个单位。 while(Mirror[s[i]] &gt;&#x3D; 2){ 当存放的数量大于1时候 我们就需要将左端点右移 Mirror[s[l++]]–; l++代表左端点右移。要注意l先执行之前的数字，执行完后才进行自身的加1操作。与++l要区分开。 左端点指针右移的同时(也就是l++)，map容器里存放的相应的字符数量-1。因为右端点索引箭头指向重复字符时，左端点右移要移动到“重复字符的右边一个单位”，这样才能使两端点内的字符不会有重复的字符，移动的同时会“损失一部分字符” ，所以要-1。 ret记录最长长度，循环结束后返回。 4. 寻找两个正序数组的中位数给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int findKth(const vector&lt;int&gt;&amp; a,int sta,const vector&lt;int&gt;&amp; b,int stb,int kth)&#123; if(sta &gt;= a.size()) return b[kth - 1 + stb]; if(stb &gt;= b.size()) return a[kth - 1 + sta]; if(kth == 1) return min(a[sta] , b[stb]); int h = kth / 2; int vala = a.size() - sta &gt;= h ? a[sta + h - 1] : a.back(); int h_a = a.size() - sta &gt;= h ? h : a.size() - sta; int valb = b.size() - stb &gt;= h ? b[stb + h - 1] : b.back(); int h_b = b.size() - stb &gt;= h ? h : b.size() - stb; if(vala &gt;= valb)&#123; return findKth(a,sta,b,stb + h_b,kth - h_b); &#125;else&#123; return findKth(a,sta + h_a,b,stb,kth - h_a); &#125; &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n = a.size(); int m = b.size(); int k = n + m; int k1 = (k + 1) / 2; int k2 = (k + 2) / 2; int ava_1 = findKth(a,0,b,0,k1); int ava_2 = findKth(a,0,b,0,k2); return 1.*(ava_1 + ava_2) / 2; &#125;&#125;; 本题用到数据结构中的二分查找法。二分查找法的基本思路：目标数组必须有序，我们找数组里的数通常会一个一个查找，这样的话效率非常低。二分查找是直接在有序数组中找到中间元素，我们想查找的数与中间元素进行对比，如果小就代表想找的数在中间元素的左方向(假设)，大的话就是右方向。于是我们在左边这一段找到左边这段的中间元素，通过比大小找到目标数字的区间，再从区间里继续寻找中间元素，反复比较，最后找到目标数字。以上介绍的思路为一个数组，而这题涉及到两个数组，换种查找思路。 首先计算两个数组的整体长度，中位数即为最中间的数或者是中间两数的平均数，所以我们只需要找到整体长度前半段，就能找到我们需要的中位数。因为这里有两个数组，因此，我们把整体长度前半段“一分为二”，一半放第一个数组的数字，另一半放第二个数组里的数字。(均为从小到大，不是随意抽取数组数字)。 我们把第一个数组放入“一半”里的最大数字(即最右边的数字)和第二个数组放入“另一半”里的最大数字(即最右边的数字)进行比较，假设第一组的最大数字比第二组大，那么可以判断中位数不在第二组放入“一半”的数字里，即中位数应当存在于第一组和第二组剩余的数字里。 开始逐行分析与知识点回顾 为了方便介绍思路:我们假定a&#x3D;{3，6，11，13}，b&#x3D;{4，9，12，14，16，20}， 123int n = a.size();//n = 4int m = b.size();//m = 6int k = n + m;//k = 10 先看主函数，m和n分别是向量a与向量b的长度，k为总长度。 12int k1 = (k + 1) / 2; //k1 = 5int k2 = (k + 2) / 2; //k2 = 6 常规来讲，长度可分为奇数与偶数，所以中位数位置都会有所不同。但通过c++环境的特性，我们可以把奇数偶数找中位数的算法统一为一个方式。如果是奇数，他们的+1 +2再除以2的结果是相同的，我们把这两个结果相加再除以2就能得到奇数的中位数的下标位置。同理，偶数+1 +2再除以2得到的是中间两个数的下标位置。 123int ava_1 = findKth(a,0,b,0,k1);int ava_2 = findKth(a,0,b,0,k2);return 1.*(ava_1 + ava_2) / 2; 通过算法找到下标所对应的数字，最后返回中位数 12//int ava_1 = findKth(a,0,b,0,k1);int findKth(const vector&lt;int&gt;&amp; a,int sta,const vector&lt;int&gt;&amp; b,int stb,int kth) 接下来看ava_1函数部分：a和b代表我们输入进来的向量，sta和stb是a向量与b向量输入进来的起始下标。kth为我们索引的长度。kth &#x3D; k1; 12345//int ava_1 = findKth(a,0,b,0,k1);if(sta &gt;= a.size()) return b[kth - 1 + stb];if(stb &gt;= b.size()) return a[kth - 1 + sta];if(kth == 1) return min(a[sta] , b[stb]); 此为结束递归函数的三种条件，即我们需要的初始下标大于a的长度时，就代表还没找到需要的数字，我们的a数组就已经索引完了，所以肯定我们需要找的数在b数组。第三种条件为我们找到最后索引长度为1，意味着我们找的数字要么在a数组或者b数组剩余的数字的第一位，所以只要比较a和b最小的数字就能找到我们需要找的数字 1234567int h = kth / 2;int vala = a.size() - sta &gt;= h ? a[sta + h - 1] : a.back();int h_a = a.size() - sta &gt;= h ? h : a.size() - sta;int valb = b.size() - stb &gt;= h ? b[stb + h - 1] : b.back();int h_b = b.size() - stb &gt;= h ? h : b.size() - stb; h为索引长度的一半，也可理解每个向量需要索引数字的个数 vala后面跟着三目运算，当a的长度减去起始长度大于需要索引的数字，就证明a数组是有空间提供“需要索引数字的个数”，于是vala&#x3D;“需要索引数字的个数”的最大值，也就是最右边的数，h_a意味着实际索引数字的个数，因为a是有空间提供，所以h_a&#x3D;h。如果a数组没有空间提供“需要索引数字的个数”，就直接vala&#x3D;a数组最右边的数组，h_a&#x3D;a的长度-a的索引的起始位置。 12345if(vala &gt;= valb)&#123; return findKth(a,sta,b,stb + h_b,kth - h_b);&#125;else&#123; return findKth(a,sta + h_a,b,stb,kth - h_a);&#125; 当a索引的最大数字大于b索引的最大数字时，说明中位数绝对不在b索引的数字里。于是a的起始下标不动，b的起始下标移动到索引数字的右边一个单位，索引长度由之前的h更新为h-h_b，进行递归迭代。后面的过程看图即可。 5. 最长回文子串给你一个字符串s，找到s中最长的回文子串。 先贴出答案，然后一步步讲解。 12345678910111213141516171819202122232425class Solution &#123;public: string longestPalindrome(string s) &#123; int m = s.length(); vector&lt;vector&lt;bool&gt;&gt; f(m , vector&lt;bool&gt;(m , false)); int p_left = 0; int maxlen = 1; for(int i = 0;i &lt; m;i++)&#123; f[i][i] = true; &#125; for(int len = 2;len &lt;= m;len++)&#123; for(int i = 0;i + len &lt;= m;i++)&#123; int j = i + len - 1; if(s[i] != s[j]) continue; if(len &gt; 2 &amp;&amp; f[i+1][j-1] == false) continue; f[i][j] = true; p_left = i; maxlen =len; &#125; &#125; return s.substr(p_left,maxlen); &#125;&#125;; 本题用到数据结构中的动态规划算法。思路：跟第三题类似，需要定义一个左指针和右指针，长度由小到大进行递增。一个满足条件的回文子串的&#x3D;他的两端字符相等+剩下的子串是回文子串。 开始逐行分析与知识点回顾 1234int m = s.length();//字符串长度vector&lt;vector&lt;bool&gt;&gt; f(m , vector&lt;bool&gt;(m , false)); //定义了bool类型的二维数组，默认为falseint p_left = 0;int maxlen = 1; bool类型二维数组[i][j]含义：如果字符串从i到j是回文子串，则返回true，否则就是false p_left为最长回文子串的左端点索引箭头，maxlen记录最长的回文子串长度 123for(int i = 0;i &lt; m;i++)&#123; f[i][i] = true;&#125; 因为单个字符某种意义上也是回文子串，所以单个字符的字符串为true。 12for(int len = 2;len &lt;= m;len++)&#123; for(int i = 0;i + len &lt;= m;i++) 长度从2开始递增，i为左端点索引箭头。 123int j = i + len - 1;if(s[i] != s[j]) continue;if(len &gt; 2 &amp;&amp; f[i+1][j-1] == false) continue; j为右端点索引箭头 如果目标字符串左端点与右端点不相同，则不是回文子串，continue跳过此次循环 如果长度大于2，即使认证了两个端点相同也要鉴定里面一层是否为字符串，如果为false，依然continue跳过此次循环 123f[i][j] = true;p_left = i;maxlen =len; 如果前面的满足都满足 证明此为回文子串，则p_left记录该指索引左端点，maxlen记录此时的长度 1return s.substr(p_left,maxlen); 最后通过string里的函数substr获得最长回文子串 substr(pos,len)：从pos位置开始拷贝len长度的字符 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 509. 斐波那契数斐波那契数（通常用 F(n)表示）形成的序列称为斐波那契数列。该数列由0和1开始，后面的每一项数字都是前面两项数字的和。 先贴出答案，然后一步步讲解。 123456789101112class Solution &#123;public: int fib(int N) &#123; int dp[31];//定义dp数组 dp[0] = 0;//初始化数组 dp[1] = 1;//初始化数组 for (int i = 2; i &lt;= N; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2];//状态方程 &#125; return dp[N]; &#125;&#125;; 斐波那契数是动态规划中最简单直观的题。它直接把步骤2的状态转移方程、步骤3初始化的数字和步骤4的遍历顺序直接告诉你，而且步骤1的dp数组有现成且下标含义也简单易懂，所以推导起来很容易 70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 先贴出答案，然后一步步讲解。 123456789101112class Solution &#123;public: int climbStairs(int n) &#123; int dp[46]; dp[1] = 1; dp[2] = 2; for(int i = 3;i &lt;= n;i++)&#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 爬楼梯这题稍微抽象点，但也简单。我们先从最底层开始理解起 假设我们的起始台阶为第0阶，爬到第一个台阶的方法只有1个，爬到第二个台阶的方法有两个，分别是2，1+1。如果我们想要爬到第三个台阶，有两种方式，从第一阶跨2个台阶或者从第二阶跨1个台阶。有两种方式但有几种方法呢？所以我们要得到跨第一个台阶的方法数量以及跨第二台阶的方法数量分别是1，2，所以爬到第三个台阶的方法数量为1+2&#x3D;3。如果我们想要爬到第四个台阶，依然有两种方式，从第二阶跨2个台阶或者从第三阶跨1个台阶。有两种方式但有几种方法呢？我们得到跨第二个台阶的方法数量为2以及跨第三台阶的方法数量为3，所以爬到第四个台阶的方法数量为2+3&#x3D;5。 跟之前的斐波那契数很相似所以1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[46]; 下标代表从0到下标位置需要的方法数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; dp[i - 1] + dp[i - 2]; 想要爬到第i个台阶，有两种方式，两种方式对应的方法数量为dp[i - 1]和dp[i - 2]。3.dp数组如何初始化 &#x3D;&gt;爬第一个阶梯和第二阶梯方法是很容易推导，所以我们定义dp[1] &#x3D; 1;dp[2] &#x3D; 2;4.遍历顺序的确定 &#x3D;&gt;从第三阶梯开始，故从3开始5.推导整个dp数组 746. 使用最小花费爬楼梯给你一个整数数组cost，其中cost[i]是从楼梯第i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为0或下标为1的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。 先贴出答案，然后一步步讲解。 1234567891011121314class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int m = cost.size(); vector&lt;int&gt; dp( m + 1, 0 ); dp[0] = 0; dp[1] = 0; for(int i = 2;i &lt;= m;i++)&#123; dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); &#125; return dp[m]; &#125;&#125;; 先理解一下题意 如果你从i台阶想向上爬，就需支付i对应的cost，你可以选择爬1台阶或者选择爬2台阶。这题跟之前的爬楼梯类似，但是增加了费用这一选项。如果跟之前一样dp数组的下标代表从0到下标位置需要的方法数量，我们的cost无法考虑进去，所以变换一种思路，dp数组表示从0到i台阶的费用，这样我们就把cost考虑进去，这里不需要考虑方法数量，题目只要求最小的费用。但是这种定义很难求得最小的费用，于是继续变换思路，dp数组表示从0到i台阶的最小费用。从“从下标为0或下标为1的台阶开始爬楼梯”得知，我们从0台阶到0台阶，或者0台阶到1台阶的最小费用都为0，所以初始化确定。假如我们到下标为2的台阶，他有两种方式，一种是0台阶选择跨2台阶，费用为0 + 0阶对应的cost；另一种是1台阶选择跨1台阶，费用为0 + 1阶对应的cost，我们需要求最小的费用所以就有了min(dp[0]+cost[0],dp[1]+cost[1])，这就是我们的状态转移方程了，遍历顺序从2起步1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector dp( m + 1, 0 ); 下标代表从0到下标位置需要的最小费用2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); 爬到第i个台阶，有两种付费方式，两种付费方式对应为dp[i-1]+cost[i-1]和dp[i-2]+cost[i-2]。3.dp数组如何初始化 &#x3D;&gt;dp[0] &#x3D; 0;dp[1] &#x3D; 0;4.遍历顺序的确定 &#x3D;&gt;从第二阶梯开始，故从2开始5.推导整个dp数组 62. 不同路径一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？ 先贴出答案，然后一步步讲解。 12345678910111213141516171819class Solution &#123;public: int uniquePaths(int m, int n) &#123; int dp[m][n] ; for(int i = 0;i &lt; m;i++) dp[i][0] = 1; for(int i = 0;i &lt; n;i++) dp[0][i] = 1; for(int i = 1;i &lt; m;i++)&#123; for(int j = 1;j &lt; n;j++)&#123; dp[i][j] = dp[i][j - 1] + dp [i-1][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 我们先从简单的2x2网格入手。我们从起始点1x1出发，移动到1x2或者是2x1因为机器人只能右移或者左移，所以只有一条路径选择。移动到2x2有两种方式，一个从1x2或者2x1，两种方式都是1种选择，所以不难判断移动到2x2的路径选择有1+1&#x3D;2种。所以dp数组得建立一个二维数组。[i][j]下标代表到达ixj的路径个数。我们的初始化很容易确定，即第一行和第一列的路径选择都是1。状态转移方程为dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j];从下标1还是遍历1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[m][n] ; 下标代表到达对应位置的路径数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和3.dp数组如何初始化 &#x3D;&gt;dp[i][0] &#x3D; 1; dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种4.遍历顺序的确定 &#x3D;&gt;从1x1开始5.推导整个dp数组 63. 不同路径 II一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用1和0来表示。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223242526class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int raws = obstacleGrid.size(); int cols = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(raws, vector&lt;int&gt;(cols, 0)); for(int i = 0;i &lt; raws &amp;&amp; obstacleGrid[i][0] == 0;i++)&#123; dp[i][0] = 1; &#125; for(int i = 0;i &lt; cols &amp;&amp; obstacleGrid[0][i] == 0;i++)&#123; dp[0][i] = 1; &#125; for(int i = 1;i &lt; raws;i++)&#123; for(int j = 1;j &lt; cols;j++)&#123; if(obstacleGrid[i][j] == 1)&#123; continue; &#125; dp[i][j] = dp[i][j - 1] + dp [i-1][j]; &#125; &#125; return dp[raws - 1][cols - 1]; &#125;&#125;; 这题思路跟之前的一样，只不过需要判断所到的点是否有障碍物。dp数组的含义依然是到达对应位置的路径数量，但是初始化的时候第一行或者第一列如果遇到障碍物则令其对应位置的路径数量为0，且这位置往右或者往下的所有位置都为0，因为有了阻碍所以让后面的位置不能初始化，先暂定为0。然后就判断当我们到达的位置判断0或1，如果是0则表示无障碍，可以进行动态规划，如果不可以则跳过此次循环。1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector&lt;vector&gt; dp(raws, vector(cols, 0)); 下标代表到达对应位置的路径数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和3.dp数组如何初始化 &#x3D;&gt;dp[i][0] &#x3D; 1; dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种4.遍历顺序的确定 &#x3D;&gt;从1x1开始5.推导整个dp数组 OK~动态规划就学这么多，因为之前在leetcode遇到的题以及接下来的题都遇到动态规划，所以特地先去网上找了些资料当专题刷了一下。leetcode先暂停更新，等动态规划所有题型刷完就回来继续刷热题100道！ 分享最近读的书《掌握习惯》很喜欢里面的几句话–你可能会出于某种动机而培养一种习惯，但让你长期保持这种习惯的唯一原因是它已经与你的身份融为一体。–你此时此刻是成就辉煌还是一事无成并不重要，重要的是你当前的习惯是否让你走上了通向成功的道路。希望我能坚持把Blog更新下去，然后培养读书的习惯，就像那本书所说，习惯培养起来了，目标不会太远。希望每一步一步脚印能让我变得更好~下周见","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"First learning record","slug":"record01","date":"2022-04-23T16:00:00.000Z","updated":"2022-04-24T05:19:30.989Z","comments":true,"path":"2022/04/24/record01/","link":"","permalink":"https://merr0r.github.io/2022/04/24/record01/","excerpt":"分享第一周学习内容","text":"分享第一周学习内容 leetcode 热题HOT 1001.两数相加给定一个整数数组nums和一个整数目标值target请你在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; a; vector&lt;int&gt; b(2,-1); for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; &#125;&#125;; 通常的作法为逐步尝试，首先第一个加第二个，再第一个加第三个……思路虽然简单暴力但运行速度慢且内存空间消耗大此代码采用的 开始逐行分析与知识点回顾 1map&lt;int,int&gt; a; //创建名为a的map容器，key与val的类型均为int 回顾map容器的相关知识： 1.map容器里的数值都是pair—&gt;成对出现 分别为键值key与实值val 2.我们可以通过key的索引查到对应的val 3.map不允许有重复的键值key存在 3.所有元素都会根据你所存的键值key进行自动排序 4.其中&lt;int,int&gt; 左边int代表key的类型为int 右边的int代表val为int 作用为：存储nums里的元素 1vector&lt;int&gt; b(2,-1);//创建名为b的vector容器，2代表初始长度，里面的值均为-1，存储nums里能满足target的两个值 回顾vector容器的相关知识： 1.与数组结构非常相似，与数组不同点在于数组是静态，而vector是动态扩展 12for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); 涉及到的知识： 1.nums.size()表示的是整数数组nums的长度 2.a.insert是调用map容器里的函数insert：在map中插入元素 3.map&lt;int,int&gt;::value_type：令元素的类型为map中含有key与val的pair类型 4.map&lt;int,int&gt;::mapped_type：令元素的类型为map中的val类型 5.map&lt;int,int&gt;::key_type：令元素的类型为map中的key类型 所以 我们把nums里的元素分别以key-val的pair形式传到名为a的map容器里 12345678for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; 涉及到的知识： 1.map容器的函数count(key)：如果key键值存在，则返回1，否则返回0 思路：通过target依次减去nums[i]，得到的结果通过count函数搜索是否存在于名为a的map容器中。且通过&amp;&amp;算法来满足“同一个元素在答案里不能重复出现”这一条件。if条件满足后，则赋予名为b的vector容器，最后返回b容器 2.两数相加给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* H = new ListNode(); ListNode* ptr = H; int carry = 0; while(l1 || l2 || carry)&#123; int val = 0; if(l1) val += l1-&gt;val,l1 = l1-&gt;next; if(l2) val += l2-&gt;val,l2 = l2-&gt;next; val +=carry; ListNode* node = new ListNode(val % 10); ptr-&gt;next = node; ptr = node; carry = val / 10; &#125; return H-&gt;next; &#125;&#125;; 开始逐行分析与知识点回顾 创建链表的详细过程 1.链表的概念 通过一组任意的存储单元来存储线性表中的数据元素，有一个个结点组成。 2.节点(Node)的框架 1234struct ListNode&#123; int data; ListNode* next;&#125;; 节点分为头节点和首元节点 a.头节点 设置链表前会额外增设一个节点，该节点一般不存放数据。好处是可以使问题简单化。对于链表来讲，不一定非得增设头节点。 b.首元节点 头节点后边的第一个节点，也是链表中的第一个节点。 节点包括数据data和指针Next a.指针的概念 指针是一个变量，存储另一个变量的地址 123int a = 10;int* p;//定义指针的格式为 数据类型* 指针变量名字p = &amp;a;//&amp;代表取址符号 b.结构体指针 12345678910111213#include &lt;iostream&gt;struct student&#123; string name; int age;&#125;//创建一个结构体int main()&#123; 1.创建结构体变量 student s =&#123;&quot;haha&quot;,18&#125;; 2.通过指针指向结构体变量 student* p = &amp;s;//p的类型必须跟s一致 3.指针访问结构体变量中的数据 cout &lt;&lt; p-&gt;name;//通过-&gt;访问结构体里的数据&#125; 结点的框架图： 创建链表的流程： 123456789101112131415161718192021222324#include &lt;iostream&gt;/*创建一个链表*/struct ListNode&#123; int data; ListNode* next;&#125;;void createList(ListNode* pHead)&#123; ListNode* p = pHead; for(int i = 0;i &lt; 10;i++)&#123; ListNode* pNewNode = new ListNode; pNewNode-&gt;data = i; pNewNode-&gt;next = NULL; p-&gt;next = pNewNode; p = pNewNode; &#125;&#125;int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 现来逐个分析 1234567int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 首先在main函数创建一个名为head的指针结构体变量，在这我们可以把head看成头节点，分配相应内存和初始化成员后如下图所示 把head指针代入函数createList，开始创建链表 12void createList(ListNode* pHead)&#123; ListNode* p = pHead; 创造p节点，令结构体指针p等于pHead，此时p的地址与pHead的地址一样，对p操作就是对pHead操作，所以p也是头节点。 12345 for(int i = 0;i &lt; 10;i++)&#123; //i = 0 ListNode* pNewNode = new ListNode; &#125;&#125; 进入for循环，处于i&#x3D;0时。在堆区new一个新内存，存放pNewNode。作为中间结构体为存放新节点提供过渡。 a.new的相关知识 new返回的使 该数据类型的指针 1234int* func()&#123; int* p = new int(10); return p;&#125; b.内存四区 程序运行前： 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 程序运行后： 堆区：堆区的数据由程序员开辟，程序员管理使用(delete) 栈区：栈区的数据由系统分配，一般存放函数的参数以及局部变量。函数执行完，栈区的数据都会自动释放。 指针本质是局部变量，放在栈上，但指针保存的数据使放在堆区。 回到链表创建上来 123//i = 0pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;0时，在pNewNode里存放数据 12//i = 0p-&gt;next = pNewNode; 头节点p指向我们的创建的链表的第一个节点 i&#x3D;0下的pNewNode，i&#x3D;0下的pNewNode也称之为首元节点。 12//i = 0p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与pHead没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们进入下一个循环 1234//i = 1ListNode* pNewNode = new ListNode;pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;1时，在pNewNode里存放数据 12//i = 1p-&gt;next = pNewNode; 节点p指向我们的创建的链表的第一个节点 i&#x3D;1下的pNewNode 12//i = 1p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与i&#x3D;0下的pNewNode没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们的创建链表的详细过程就结束了，回到LeetCode题上。 123ListNode* H = new ListNode();ListNode* ptr = H;int carry = 0; H为定义的头节点，ptr是中间节点，H存放的地址与ptr存放的地址一致。carry为进位数 1while(l1 || l2 || carry)&#123; 个人的看法只要当l1 l2的val为0(结构体里的data)及carry为0，才返回false，其他情况一律为true。 123if(l1) val += l1-&gt;val,l1 = l1-&gt;next;if(l2) val += l2-&gt;val,l2 = l2-&gt;next;val +=carry; 当l1不为0是 执行if语句 val为l1链表的第一个数字，l1从第一个链表转换成l1的第二个链表第二行代码同理carry是进位制 1ListNode* node = new ListNode(val % 10); 创建新链表的第一个节点，存储的数据为 val除以10的余数 123ptr-&gt;next = node;ptr = node;carry = val / 10; 因为node存放的数据是我们想要的数据，所以利用ptr的next指针即H的next指针指向node节点，ptr切断与H的联系，令ptr与node指向同一块内存，手法跟创建链表一样。通过相除判断carry是否进1位。 1return H-&gt;next; H为头节点，头节点下一个next才是链表中的节点。 Conclusion第一次写博客，刚开始上手不是很熟悉，所以暂时就写了这周学的LeetCode。下次尝试把参与的项目学到的知识分享在博客中。暂定每周日更新博客，如果有研究僧考试那就咕咕咕~See you next week","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每月学习","slug":"每月学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E6%9C%88%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"公司实习","slug":"公司实习","permalink":"https://merr0r.github.io/tags/%E5%85%AC%E5%8F%B8%E5%AE%9E%E4%B9%A0/"},{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"二叉树","slug":"二叉树","permalink":"https://merr0r.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"回溯","slug":"回溯","permalink":"https://merr0r.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"往期回顾","slug":"往期回顾","permalink":"https://merr0r.github.io/tags/%E5%BE%80%E6%9C%9F%E5%9B%9E%E9%A1%BE/"}]}