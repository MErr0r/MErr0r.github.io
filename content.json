{"meta":{"title":"MErr0rのBlog","subtitle":"I turn the page to drown you out","description":"合工大研究僧","author":"MErr0r","url":"https://merr0r.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-04-20T05:00:03.000Z","updated":"2022-04-20T05:01:05.337Z","comments":true,"path":"categories/index.html","permalink":"https://merr0r.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-19T00:30:08.000Z","updated":"2022-04-20T04:57:59.765Z","comments":true,"path":"tags/index.html","permalink":"https://merr0r.github.io/tags/index.html","excerpt":"","text":""},{"title":"record","date":"2022-04-18T08:38:21.000Z","updated":"2022-04-18T08:38:21.627Z","comments":true,"path":"record/index.html","permalink":"https://merr0r.github.io/record/index.html","excerpt":"","text":""},{"title":"special","date":"2022-04-18T08:38:31.000Z","updated":"2022-04-18T08:38:31.743Z","comments":true,"path":"special/index.html","permalink":"https://merr0r.github.io/special/index.html","excerpt":"","text":""}],"posts":[{"title":"First learning record in May","slug":"record03","date":"2022-05-05T16:00:00.000Z","updated":"2022-05-08T13:38:25.777Z","comments":true,"path":"2022/05/06/record03/","link":"","permalink":"https://merr0r.github.io/2022/05/06/record03/","excerpt":"分享五月第一周学习内容","text":"分享五月第一周学习内容 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 343. 整数拆分给定一个正整数n，将其拆分为k个正整数的和（k &gt;&#x3D; 2），并使这些整数的乘积最大化。返回你可以获得的最大乘积。 先贴出答案，然后一步步讲解。 12345678910111213class Solution &#123;public: int integerBreak(int n) &#123; vector&lt;int&gt; dp(n+1); dp[2] = 1; for(int i = 2;i &lt;= n;i++)&#123; for(int j = 1;j &lt; i/2+1;j++)&#123; dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j)); &#125; &#125; return dp[n]; &#125;&#125;; 首先举个栗子当n&#x3D;2时，拆分的数字为1和1。乘积为1。当n&#x3D;3时，拆分的数字为2和1。乘积为2。当n&#x3D;4时，拆分的数字为2和2。乘积为4。当n&#x3D;5时，拆分的数字为2和3。乘积为6。当n&#x3D;6时，拆分的数字为3和3。乘积为9。当n&#x3D;7时，拆分的数字为2、3和2或者4和3。乘积为12。当n&#x3D;8时，拆分的数字为2、3和3。乘积为18。当n&#x3D;9时，拆分的数字为3、3和3。乘积为27。当n&#x3D;10时，拆分的数字为2、3、2和3。乘积为36。首先第一步要从这些栗子中找到动态规划的规律，我们才能列出dp的含义以及动态方程。乍一看没啥思路，其实我们可以把栗子作进一步拆解。当n&#x3D;2时，拆分的数字为1和1。最大乘积为1。当n&#x3D;3时，拆分的数字为2和1。2的最大乘积乘以1等于1，2的本身乘以1等于2。于是3的最大乘积等于2。当n&#x3D;4时，第一种拆分的数字为3和1。3的最大乘积乘以1等于2，3的本体乘以1等于3；第二种拆分的数字为2和2，2的最大乘积乘以2等于2，2的本身乘以2等于4。于是4的最大乘积等于4。当n&#x3D;5时，第一种拆分方式为4和1。4的最大乘积乘以1等于4，4的本身乘以1等于4。第二种拆分方式为3和2，3的最大乘积乘以2等于4，3的本身乘以2等于6。于是5的最大乘积等于6。当n&#x3D;6时，第一种拆分方式为4和2(1直接略过)。4的最大乘积乘以2等于8，4的本身乘以2等于8。第二种拆分方式为3和3。3的最大乘积乘以3等于6，3的本身乘以3等于9。于是6的最大乘积等于9。当n&#x3D;7时，第一种拆分方式为5和2(1直接略过)。5的最大乘积乘以2等于12，5的本身乘以2等于10。第二种拆分方式为4和3。4的最大乘积乘以3等于12，4的本身乘以3等于12。于是7的最大乘积等于12。当n&#x3D;8时，第一种拆分方式为6和2(1直接略过)。6的最大乘积乘以2等于18，6的本身乘以2等于12。第二种拆分方式为5和3。5的最大乘积乘以3等于18，5的本身乘以3等于15。第三种拆分方式为4和4。4的最大乘积乘以4等于16，4的本身乘以4等于16。于是8的最大乘积等于18。当n&#x3D;9时，第一种拆分方式为7和2(1直接略过)。7的最大乘积乘以2等于24，7的本身乘以2等于14。第二种拆分方式为6和3。6的最大乘积乘以3等于27，6的本身乘以3等于18。第三种拆分方式为5和4。5的最大乘积乘以4等于24，5的本身乘以4等于20。于是9的最大乘积等于27。当n&#x3D;10时，第一种拆分方式为8和2(1直接略过)。8的最大乘积乘以2等于36，8的本身乘以2等于16。第二种拆分方式为7和3。7的最大乘积乘以3等于36，7的本身乘以3等于21。第三种拆分方式为6和4。6的最大乘积乘以4等于36，6的本身乘以4等于24。第四种拆分方式为5和5。5的最大乘积乘以5等于30，5的本身乘以5等于25。于是10的最大乘积等于36。现在思路清晰了，我们先把数字A拆成1和A-1，直接讨论A-1的最大乘积大还是A-1本身大，最大的那个数乘以1得到的结果就是在1状态下数字A的最大乘积。继续把A拆成2和A-2，直接讨论A-2的最大乘积大还是A-2本身大，最大的那个数乘以2得到的结果就是在2状态下数字A的最大乘积……最后比较这些状态下的最大乘积，我们就能得到A的最大乘积。 1.确定dp数组(dp table)以及下标的含义 dp[i]的含义是在第i个数下的最大乘积。2.确认状态转移方程，即递推公式 dp[i] &#x3D; max(dp[i],max(dp[i-j]*j,(i-j)*j)) max(dp[i-j]*j,(i-j)*j)代表j状态下的i最大乘积，max里的dp[i]代表之前也就是j-1状态下的i最大乘积，两者需要相互比较。3.dp数组如何初始化 dp[2] &#x3D; 1;4.遍历顺序的确定 i表示从第2个数字，按照正序遍历到n。j就代表拆分下的j状态数字。5.推导整个dp数组 背包二维有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble() &#123; vector&lt;int&gt; weight = &#123;1 , 3 , 4&#125;; vector&lt;int&gt; value = &#123;15 , 20, 30 &#125;; int bagweight = 4; vector&lt;vector&lt;int&gt;&gt; dp(weight.size() + 1, vector&lt;int&gt;(bagweight + 1, 0)); for (int i = bagweight; i &gt;= weight[0]; i--) &#123; dp[0][i] = value[0]; &#125; for (int i = 1; i &lt; weight.size(); i++) &#123; for (int j = 0; j &lt;= bagweight; j++) &#123; if (j &lt; weight[i]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); &#125; &#125; &#125; cout &lt;&lt; dp[weight.size() - 1][bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble(); system(&quot;pause&quot;); return 0;&#125; 此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。首先我们联想一下上一道拆分数组。拆分数组的思路是把数字A拆分成1状态和A-1，然后搜寻A-1的最大值。然后拆分成2状态和A-2，然后搜寻1-2的最大值。我们照葫芦画瓢，运用到这题上：假设第一个物品重量为weight[0]，价值为value[0]。背包重量为j，我们就理解成当j&gt;weight[0]时，j此时的最大价值&#x3D;背包重量为j-weight[0]时的最大价值+value[0]。j&lt;weight[0]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。假设第二个物品重量为weight[1]，价值为value[1]。背包重量为j，我们就理解成当j&gt;weight[1]时，j此时的最大价值&#x3D;背包重量为j-weight[1]时的最大价值+value[1]。j&lt;weight[1]时，j此时的最大价值&#x3D;没有装入第一个物品的最大价值。但怎么求“背包重量为W-weight[0]时的最大价值”呢？于是我们要遍历从0到W的背包重量，那么很容易看出dp应该是二维数组，dp[i][j]为背包重量为j时装第i个物品的最大价值。那么dp[i][j]是怎么来的？当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那怎么初始化？背包重量为0时，装不下任何物品，故dp[i][0]都为0。讨论第一个物品时，应该背包里没有其他物品，所以当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。 1.确定dp数组(dp table)以及下标的含义 dp[i][j]为背包重量为j时装第i个物品的最大价值。2.确认状态转移方程，即递推公式 当j&lt;weight[i]时，dp[i][j]&#x3D; dp[i - 1][j]。 当j&gt;weight[i]时，dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);3.dp数组如何初始化 dp[0][i] &#x3D; value[0] 当j&gt;weight[0]时，dp[0][j]价值都为第一物品的价值value[0]；当j&lt;weight[0]时，价值依然为0。4.遍历顺序的确定 i代表物品，因为C++数组的原因，本应从0开始遍历，但之前初始化了，所以从1开始（也就是从第二个物品）开始遍历。j代表背包重量，从0开始5.推导整个dp数组 背包一维有N件物品和⼀个最多能被重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void test_weibagPromble() &#123; vector&lt;int&gt; weight = &#123; 1 , 3 , 4 &#125;; vector&lt;int&gt; value = &#123; 15 , 20, 30 &#125;; int bagweight = 4; vector&lt;int&gt; dp1(bagweight + 1, 0); for (int i = 0; i &lt; weight.size(); i++) &#123; for (int j = bagweight; j &gt;= weight[i]; j--) &#123; dp1[j] = max(dp1[j], dp1[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp1[bagweight] &lt;&lt; endl;&#125;int main() &#123; test_weibagPromble(); system(&quot;pause&quot;); return 0;&#125; 此题为[代码随想录].pdf上的一道背包题目，所以运行环境不在LeetCode上而是在VS studio上。之前的dp为二维数组。那怎么运用到一维数组？二维dp数组的含义是 dp[i][j]为背包重量为j时装第i个物品的最大价值，dp[i]如果表示第i个物品的最大价值显然不行，那么表示成dp[j]为背包重量为j时的最大价值呢。那么dp[j]怎么来呢？回顾一下二维数组的dp来源当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[i][j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[i][j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那么更换成一维数组dp当j&lt;weight[i]时，代表重量为j的背包装不下第i个物品，于是最大价值dp[j]应等于重量为j的背包装第i-1件时的物品时的最大值。当j&gt;weight[i]时，代表重量为j的背包能装下第i个物品，于是最大价值dp[j]应从重量为j的背包装第i-1件时的物品时的最大值或者背包重量为j-weight[i]时的最大价值+value[i]中选出最大值。那么可以确认 dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i]) max里的dp[j]就是重量为j的背包装第i-1件时的物品时的最大值。那怎么初始化？众所周知重量为0时啥也装不下，所以价值必为0，所以dp[0] &#x3D; 0；从max和value不可能为负数可以得知，我们也可以把dp整个数组的数都初始为0，定义为0对之后在max里取最大值也没啥影响。遍历顺序怎么确定？如果是正序，那么会遇到一个问题。假如物品重量为1，价值为value[1]当j&#x3D;1时，dp[1]&#x3D;value[1]。当j&#x3D;2时候，因为dp[2] &#x3D; max(dp[2],dp[2 - weight[1]] + value[1])，max里的dp[2]&#x3D;0，dp[2 - weight[1]] + value[1]&#x3D;dp[1]+value[1]&#x3D;2xvalue[1]。也就是说在j&#x3D;2的时候value取了两次值。所以不能正序遍历，那逆序呢？当j&#x3D;4时，因为dp[4] &#x3D; max(dp[4],dp[4 - weight[1]] + value[1])，max里的dp[4]&#x3D;0，dp[4 - weight[1]] + value[1]&#x3D;dp[3]+value[1]&#x3D;value[1]。当j&#x3D;3时候，因为dp[3] &#x3D; max(dp[3],dp[3 - weight[1]] + value[1])，max里的dp[3]&#x3D;0，dp[3 - weight[1]] + value[1]&#x3D;dp[2]+value[1]&#x3D;value[1]。这样就不会产生取两次值的情况。 1.确定dp数组(dp table)以及下标的含义 dp[j]为背包重量为j时的最大价值。2.确认状态转移方程，即递推公式 dp[j] &#x3D; max(dp[j],dp[j - weight[i]] + value[i])3.dp数组如何初始化 dp[j]&#x3D; 04.遍历顺序的确定 逆序。5.推导整个dp数组 分割等和子集给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 先贴出答案，然后一步步讲解。 12345678910111213141516171819class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(int i = 0;i &lt; nums.size();i++)&#123; sum += nums[i]; &#125; if(sum % 2 == 1) return false; int sumHalf = sum/2; vector&lt;int&gt; dp(sumHalf + 1,0); for(int i = 0;i &lt; nums.size();i++)&#123; for(int j = sumHalf;j &gt;= nums[i];j--)&#123; dp[j] = max(dp[j],dp[j-nums[i]]+nums[i]); &#125; &#125; if(dp[sumHalf] == sumHalf) return true; return false; &#125;&#125;; 两个子集的元素和相等，可以推断出两个子集的元素和相加等于原数组nums各个数字之和，换句话说两个子集元素的和是nums各个元素和的一半，所以不难判断如果nums各个元素和为奇数，那么false。那么怎么确认dp[i]还是dp[i][j]？刚才我们分析出两个子集的元素和等于nums各个元素和的一半，我们令nums的和为sum，子集元素和为sumHalf。我们可以能把这题转换为刚才的背包问题，两个子集就是两个背包，sumHalf为背包重量，nums里的元素即为物品重量，这里的价值可以看成放入背包物品的最大重量，最大容量不能超过背包重量。根据之前的背包一维dp[j]为背包重量为j时的最大价值可以推断出dp[i]为背包重量为i时候的放入物品的最大重量。那么我要做的就是在背包重量为sumHalf时(dp[sumHalf])放入物品的最大重量等于sumHalf，那样的话另一个背包放入物品的最大重量必定sum-dp[sumHalf],如果sumHalf &#x3D;&#x3D; sum-dp[sumHalf]，或者dp[sumHalf] &#x3D; sumHalf，那直接返回true。那怎么初始化？跟之前一维背包一样，全部定义为0即可。遍历顺序跟一维背包一样，采用逆序。1.确定dp数组(dp table)以及下标的含义 dp[j]为背包重量为j时的放入物品的最大重量。2.确认状态转移方程，即递推公式 dp[j] &#x3D; max(dp[j],dp[j - nums[i]] + nums[i])3.dp数组如何初始化 dp[j]&#x3D; 04.遍历顺序的确定 逆序。5.推导整个dp数组 OK~动态规划就学这么多(其实还有一题- -)，因为最近学校解封，跟同学各种聚餐…所以就更了这么点- -下周好好干会来！！多学点知识！！","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Second learning record in April","slug":"record02","date":"2022-04-30T16:00:00.000Z","updated":"2022-05-01T12:56:02.234Z","comments":true,"path":"2022/05/01/record02/","link":"","permalink":"https://merr0r.github.io/2022/05/01/record02/","excerpt":"分享四月第二周学习内容","text":"分享四月第二周学习内容 leetcode 热题HOT 1003. 无重复字符的最长子串给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.length(); int ret = 0; int l = 0; unordered_map&lt;char,int&gt; Mirror; for(int i = 0;i &lt; n;i++)&#123; Mirror[s[i]]++; while(Mirror[s[i]] &gt;= 2)&#123; Mirror[s[l++]]--; &#125; ret = max(ret,i - l +1); &#125; return ret; &#125;&#125;; 本题的思路为：定义两个索引箭头指向字符串的两端，左端点的箭头先固定不动，右端点箭头右移进行索引，如果碰到重复字符，记录此时的长度，同时左端点往右移，直到没有重复字符为止。右端指针继续右移操作。重复上述过程 开始逐行分析与知识点回顾 123int n = s.length();int ret = 0;int l = 0; n为字符串长度，ret代表我们想返回的值，也就是最长子串的长度。l代表左端点指针 1unordered_map&lt;char,int&gt; Mirror; 定义一个名为Mirror的map容器，键值类型为char，用来存放单个字符。实值类型为int，用来存放字符在字符串的个数 特点是： 1.键只能有一个，但实值能有许多个 2.无序排列 3.通过 容器名[] 能直接添加键值 12345678for(int i = 0;i &lt; n;i++)&#123; Mirror[s[i]]++; while(Mirror[s[i]] &gt;= 2)&#123; Mirror[s[l++]]--; &#125; ret = max(ret,i - l +1); &#125; return ret; i代表右端点索引箭头，i++代表右端点箭头右移 Mirror[s[i]]++; 表示的是右端点指向字符存进map容器中，相应的实值从默认的0增加1个单位。 while(Mirror[s[i]] &gt;&#x3D; 2){ 当存放的数量大于1时候 我们就需要将左端点右移 Mirror[s[l++]]–; l++代表左端点右移。要注意l先执行之前的数字，执行完后才进行自身的加1操作。与++l要区分开。 左端点指针右移的同时(也就是l++)，map容器里存放的相应的字符数量-1。因为右端点索引箭头指向重复字符时，左端点右移要移动到“重复字符的右边一个单位”，这样才能使两端点内的字符不会有重复的字符，移动的同时会“损失一部分字符” ，所以要-1。 ret记录最长长度，循环结束后返回。 4. 寻找两个正序数组的中位数给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int findKth(const vector&lt;int&gt;&amp; a,int sta,const vector&lt;int&gt;&amp; b,int stb,int kth)&#123; if(sta &gt;= a.size()) return b[kth - 1 + stb]; if(stb &gt;= b.size()) return a[kth - 1 + sta]; if(kth == 1) return min(a[sta] , b[stb]); int h = kth / 2; int vala = a.size() - sta &gt;= h ? a[sta + h - 1] : a.back(); int h_a = a.size() - sta &gt;= h ? h : a.size() - sta; int valb = b.size() - stb &gt;= h ? b[stb + h - 1] : b.back(); int h_b = b.size() - stb &gt;= h ? h : b.size() - stb; if(vala &gt;= valb)&#123; return findKth(a,sta,b,stb + h_b,kth - h_b); &#125;else&#123; return findKth(a,sta + h_a,b,stb,kth - h_a); &#125; &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n = a.size(); int m = b.size(); int k = n + m; int k1 = (k + 1) / 2; int k2 = (k + 2) / 2; int ava_1 = findKth(a,0,b,0,k1); int ava_2 = findKth(a,0,b,0,k2); return 1.*(ava_1 + ava_2) / 2; &#125;&#125;; 本题用到数据结构中的二分查找法。二分查找法的基本思路：目标数组必须有序，我们找数组里的数通常会一个一个查找，这样的话效率非常低。二分查找是直接在有序数组中找到中间元素，我们想查找的数与中间元素进行对比，如果小就代表想找的数在中间元素的左方向(假设)，大的话就是右方向。于是我们在左边这一段找到左边这段的中间元素，通过比大小找到目标数字的区间，再从区间里继续寻找中间元素，反复比较，最后找到目标数字。以上介绍的思路为一个数组，而这题涉及到两个数组，换种查找思路。 首先计算两个数组的整体长度，中位数即为最中间的数或者是中间两数的平均数，所以我们只需要找到整体长度前半段，就能找到我们需要的中位数。因为这里有两个数组，因此，我们把整体长度前半段“一分为二”，一半放第一个数组的数字，另一半放第二个数组里的数字。(均为从小到大，不是随意抽取数组数字)。 我们把第一个数组放入“一半”里的最大数字(即最右边的数字)和第二个数组放入“另一半”里的最大数字(即最右边的数字)进行比较，假设第一组的最大数字比第二组大，那么可以判断中位数不在第二组放入“一半”的数字里，即中位数应当存在于第一组和第二组剩余的数字里。 开始逐行分析与知识点回顾 为了方便介绍思路:我们假定a&#x3D;{3，6，11，13}，b&#x3D;{4，9，12，14，16，20}， 123int n = a.size();//n = 4int m = b.size();//m = 6int k = n + m;//k = 10 先看主函数，m和n分别是向量a与向量b的长度，k为总长度。 12int k1 = (k + 1) / 2; //k1 = 5int k2 = (k + 2) / 2; //k2 = 6 常规来讲，长度可分为奇数与偶数，所以中位数位置都会有所不同。但通过c++环境的特性，我们可以把奇数偶数找中位数的算法统一为一个方式。如果是奇数，他们的+1 +2再除以2的结果是相同的，我们把这两个结果相加再除以2就能得到奇数的中位数的下标位置。同理，偶数+1 +2再除以2得到的是中间两个数的下标位置。 123int ava_1 = findKth(a,0,b,0,k1);int ava_2 = findKth(a,0,b,0,k2);return 1.*(ava_1 + ava_2) / 2; 通过算法找到下标所对应的数字，最后返回中位数 12//int ava_1 = findKth(a,0,b,0,k1);int findKth(const vector&lt;int&gt;&amp; a,int sta,const vector&lt;int&gt;&amp; b,int stb,int kth) 接下来看ava_1函数部分：a和b代表我们输入进来的向量，sta和stb是a向量与b向量输入进来的起始下标。kth为我们索引的长度。kth &#x3D; k1; 12345//int ava_1 = findKth(a,0,b,0,k1);if(sta &gt;= a.size()) return b[kth - 1 + stb];if(stb &gt;= b.size()) return a[kth - 1 + sta];if(kth == 1) return min(a[sta] , b[stb]); 此为结束递归函数的三种条件，即我们需要的初始下标大于a的长度时，就代表还没找到需要的数字，我们的a数组就已经索引完了，所以肯定我们需要找的数在b数组。第三种条件为我们找到最后索引长度为1，意味着我们找的数字要么在a数组或者b数组剩余的数字的第一位，所以只要比较a和b最小的数字就能找到我们需要找的数字 1234567int h = kth / 2;int vala = a.size() - sta &gt;= h ? a[sta + h - 1] : a.back();int h_a = a.size() - sta &gt;= h ? h : a.size() - sta;int valb = b.size() - stb &gt;= h ? b[stb + h - 1] : b.back();int h_b = b.size() - stb &gt;= h ? h : b.size() - stb; h为索引长度的一半，也可理解每个向量需要索引数字的个数 vala后面跟着三目运算，当a的长度减去起始长度大于需要索引的数字，就证明a数组是有空间提供“需要索引数字的个数”，于是vala&#x3D;“需要索引数字的个数”的最大值，也就是最右边的数，h_a意味着实际索引数字的个数，因为a是有空间提供，所以h_a&#x3D;h。如果a数组没有空间提供“需要索引数字的个数”，就直接vala&#x3D;a数组最右边的数组，h_a&#x3D;a的长度-a的索引的起始位置。 12345if(vala &gt;= valb)&#123; return findKth(a,sta,b,stb + h_b,kth - h_b);&#125;else&#123; return findKth(a,sta + h_a,b,stb,kth - h_a);&#125; 当a索引的最大数字大于b索引的最大数字时，说明中位数绝对不在b索引的数字里。于是a的起始下标不动，b的起始下标移动到索引数字的右边一个单位，索引长度由之前的h更新为h-h_b，进行递归迭代。后面的过程看图即可。 5. 最长回文子串给你一个字符串s，找到s中最长的回文子串。 先贴出答案，然后一步步讲解。 12345678910111213141516171819202122232425class Solution &#123;public: string longestPalindrome(string s) &#123; int m = s.length(); vector&lt;vector&lt;bool&gt;&gt; f(m , vector&lt;bool&gt;(m , false)); int p_left = 0; int maxlen = 1; for(int i = 0;i &lt; m;i++)&#123; f[i][i] = true; &#125; for(int len = 2;len &lt;= m;len++)&#123; for(int i = 0;i + len &lt;= m;i++)&#123; int j = i + len - 1; if(s[i] != s[j]) continue; if(len &gt; 2 &amp;&amp; f[i+1][j-1] == false) continue; f[i][j] = true; p_left = i; maxlen =len; &#125; &#125; return s.substr(p_left,maxlen); &#125;&#125;; 本题用到数据结构中的动态规划算法。思路：跟第三题类似，需要定义一个左指针和右指针，长度由小到大进行递增。一个满足条件的回文子串的&#x3D;他的两端字符相等+剩下的子串是回文子串。 开始逐行分析与知识点回顾 1234int m = s.length();//字符串长度vector&lt;vector&lt;bool&gt;&gt; f(m , vector&lt;bool&gt;(m , false)); //定义了bool类型的二维数组，默认为falseint p_left = 0;int maxlen = 1; bool类型二维数组[i][j]含义：如果字符串从i到j是回文子串，则返回true，否则就是false p_left为最长回文子串的左端点索引箭头，maxlen记录最长的回文子串长度 123for(int i = 0;i &lt; m;i++)&#123; f[i][i] = true;&#125; 因为单个字符某种意义上也是回文子串，所以单个字符的字符串为true。 12for(int len = 2;len &lt;= m;len++)&#123; for(int i = 0;i + len &lt;= m;i++) 长度从2开始递增，i为左端点索引箭头。 123int j = i + len - 1;if(s[i] != s[j]) continue;if(len &gt; 2 &amp;&amp; f[i+1][j-1] == false) continue; j为右端点索引箭头 如果目标字符串左端点与右端点不相同，则不是回文子串，continue跳过此次循环 如果长度大于2，即使认证了两个端点相同也要鉴定里面一层是否为字符串，如果为false，依然continue跳过此次循环 123f[i][j] = true;p_left = i;maxlen =len; 如果前面的满足都满足 证明此为回文子串，则p_left记录该指索引左端点，maxlen记录此时的长度 1return s.substr(p_left,maxlen); 最后通过string里的函数substr获得最长回文子串 substr(pos,len)：从pos位置开始拷贝len长度的字符 动态规划的入门学习动态规划：Dynamic Programming，简称DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。步骤：1.确定dp数组(dp table)以及下标的含义2.确认状态转移方程，即递推公式3.dp数组如何初始化4.遍历顺序的确定5.推导整个dp数组 509. 斐波那契数斐波那契数（通常用 F(n)表示）形成的序列称为斐波那契数列。该数列由0和1开始，后面的每一项数字都是前面两项数字的和。 先贴出答案，然后一步步讲解。 123456789101112class Solution &#123;public: int fib(int N) &#123; int dp[31];//定义dp数组 dp[0] = 0;//初始化数组 dp[1] = 1;//初始化数组 for (int i = 2; i &lt;= N; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2];//状态方程 &#125; return dp[N]; &#125;&#125;; 斐波那契数是动态规划中最简单直观的题。它直接把步骤2的状态转移方程、步骤3初始化的数字和步骤4的遍历顺序直接告诉你，而且步骤1的dp数组有现成且下标含义也简单易懂，所以推导起来很容易 70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 先贴出答案，然后一步步讲解。 123456789101112class Solution &#123;public: int climbStairs(int n) &#123; int dp[46]; dp[1] = 1; dp[2] = 2; for(int i = 3;i &lt;= n;i++)&#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 爬楼梯这题稍微抽象点，但也简单。我们先从最底层开始理解起 假设我们的起始台阶为第0阶，爬到第一个台阶的方法只有1个，爬到第二个台阶的方法有两个，分别是2，1+1。如果我们想要爬到第三个台阶，有两种方式，从第一阶跨2个台阶或者从第二阶跨1个台阶。有两种方式但有几种方法呢？所以我们要得到跨第一个台阶的方法数量以及跨第二台阶的方法数量分别是1，2，所以爬到第三个台阶的方法数量为1+2&#x3D;3。如果我们想要爬到第四个台阶，依然有两种方式，从第二阶跨2个台阶或者从第三阶跨1个台阶。有两种方式但有几种方法呢？我们得到跨第二个台阶的方法数量为2以及跨第三台阶的方法数量为3，所以爬到第四个台阶的方法数量为2+3&#x3D;5。 跟之前的斐波那契数很相似所以1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[46]; 下标代表从0到下标位置需要的方法数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; dp[i - 1] + dp[i - 2]; 想要爬到第i个台阶，有两种方式，两种方式对应的方法数量为dp[i - 1]和dp[i - 2]。3.dp数组如何初始化 &#x3D;&gt;爬第一个阶梯和第二阶梯方法是很容易推导，所以我们定义dp[1] &#x3D; 1;dp[2] &#x3D; 2;4.遍历顺序的确定 &#x3D;&gt;从第三阶梯开始，故从3开始5.推导整个dp数组 746. 使用最小花费爬楼梯给你一个整数数组cost，其中cost[i]是从楼梯第i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为0或下标为1的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。 先贴出答案，然后一步步讲解。 1234567891011121314class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int m = cost.size(); vector&lt;int&gt; dp( m + 1, 0 ); dp[0] = 0; dp[1] = 0; for(int i = 2;i &lt;= m;i++)&#123; dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); &#125; return dp[m]; &#125;&#125;; 先理解一下题意 如果你从i台阶想向上爬，就需支付i对应的cost，你可以选择爬1台阶或者选择爬2台阶。这题跟之前的爬楼梯类似，但是增加了费用这一选项。如果跟之前一样dp数组的下标代表从0到下标位置需要的方法数量，我们的cost无法考虑进去，所以变换一种思路，dp数组表示从0到i台阶的费用，这样我们就把cost考虑进去，这里不需要考虑方法数量，题目只要求最小的费用。但是这种定义很难求得最小的费用，于是继续变换思路，dp数组表示从0到i台阶的最小费用。从“从下标为0或下标为1的台阶开始爬楼梯”得知，我们从0台阶到0台阶，或者0台阶到1台阶的最小费用都为0，所以初始化确定。假如我们到下标为2的台阶，他有两种方式，一种是0台阶选择跨2台阶，费用为0 + 0阶对应的cost；另一种是1台阶选择跨1台阶，费用为0 + 1阶对应的cost，我们需要求最小的费用所以就有了min(dp[0]+cost[0],dp[1]+cost[1])，这就是我们的状态转移方程了，遍历顺序从2起步1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector dp( m + 1, 0 ); 下标代表从0到下标位置需要的最小费用2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i] &#x3D; min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); 爬到第i个台阶，有两种付费方式，两种付费方式对应为dp[i-1]+cost[i-1]和dp[i-2]+cost[i-2]。3.dp数组如何初始化 &#x3D;&gt;dp[0] &#x3D; 0;dp[1] &#x3D; 0;4.遍历顺序的确定 &#x3D;&gt;从第二阶梯开始，故从2开始5.推导整个dp数组 62. 不同路径一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？ 先贴出答案，然后一步步讲解。 12345678910111213141516171819class Solution &#123;public: int uniquePaths(int m, int n) &#123; int dp[m][n] ; for(int i = 0;i &lt; m;i++) dp[i][0] = 1; for(int i = 0;i &lt; n;i++) dp[0][i] = 1; for(int i = 1;i &lt; m;i++)&#123; for(int j = 1;j &lt; n;j++)&#123; dp[i][j] = dp[i][j - 1] + dp [i-1][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 我们先从简单的2x2网格入手。我们从起始点1x1出发，移动到1x2或者是2x1因为机器人只能右移或者左移，所以只有一条路径选择。移动到2x2有两种方式，一个从1x2或者2x1，两种方式都是1种选择，所以不难判断移动到2x2的路径选择有1+1&#x3D;2种。所以dp数组得建立一个二维数组。[i][j]下标代表到达ixj的路径个数。我们的初始化很容易确定，即第一行和第一列的路径选择都是1。状态转移方程为dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j];从下标1还是遍历1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;int dp[m][n] ; 下标代表到达对应位置的路径数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和3.dp数组如何初始化 &#x3D;&gt;dp[i][0] &#x3D; 1; dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种4.遍历顺序的确定 &#x3D;&gt;从1x1开始5.推导整个dp数组 63. 不同路径 II一个机器人位于一个mxn网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用1和0来表示。 先贴出答案，然后一步步讲解。 1234567891011121314151617181920212223242526class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int raws = obstacleGrid.size(); int cols = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(raws, vector&lt;int&gt;(cols, 0)); for(int i = 0;i &lt; raws &amp;&amp; obstacleGrid[i][0] == 0;i++)&#123; dp[i][0] = 1; &#125; for(int i = 0;i &lt; cols &amp;&amp; obstacleGrid[0][i] == 0;i++)&#123; dp[0][i] = 1; &#125; for(int i = 1;i &lt; raws;i++)&#123; for(int j = 1;j &lt; cols;j++)&#123; if(obstacleGrid[i][j] == 1)&#123; continue; &#125; dp[i][j] = dp[i][j - 1] + dp [i-1][j]; &#125; &#125; return dp[raws - 1][cols - 1]; &#125;&#125;; 这题思路跟之前的一样，只不过需要判断所到的点是否有障碍物。dp数组的含义依然是到达对应位置的路径数量，但是初始化的时候第一行或者第一列如果遇到障碍物则令其对应位置的路径数量为0，且这位置往右或者往下的所有位置都为0，因为有了阻碍所以让后面的位置不能初始化，先暂定为0。然后就判断当我们到达的位置判断0或1，如果是0则表示无障碍，可以进行动态规划，如果不可以则跳过此次循环。1.确定dp数组(dp table)以及下标的含义 &#x3D;&gt;vector&lt;vector&gt; dp(raws, vector(cols, 0)); 下标代表到达对应位置的路径数量2.确认状态转移方程，即递推公式 &#x3D;&gt;dp[i][j] &#x3D; dp[i][j - 1] + dp [i-1][j] 到ixj位置的方式有ix(j-1)下移 (i-1)xj右移 路径数量则是到达ix(j-1)和(i-1)xj的路径数量之和3.dp数组如何初始化 &#x3D;&gt;dp[i][0] &#x3D; 1; dp[0][i] &#x3D; 1;第一行和第一列的路径选择只有一种4.遍历顺序的确定 &#x3D;&gt;从1x1开始5.推导整个dp数组 OK~动态规划就学这么多，因为之前在leetcode遇到的题以及接下来的题都遇到动态规划，所以特地先去网上找了些资料当专题刷了一下。leetcode先暂停更新，等动态规划所有题型刷完就回来继续刷热题100道！ 分享最近读的书《掌握习惯》很喜欢里面的几句话–你可能会出于某种动机而培养一种习惯，但让你长期保持这种习惯的唯一原因是它已经与你的身份融为一体。–你此时此刻是成就辉煌还是一事无成并不重要，重要的是你当前的习惯是否让你走上了通向成功的道路。希望我能坚持把Blog更新下去，然后培养读书的习惯，就像那本书所说，习惯培养起来了，目标不会太远。希望每一步一步脚印能让我变得更好~下周见","categories":[],"tags":[]},{"title":"First learning record","slug":"record01","date":"2022-04-23T16:00:00.000Z","updated":"2022-04-24T05:19:30.989Z","comments":true,"path":"2022/04/24/record01/","link":"","permalink":"https://merr0r.github.io/2022/04/24/record01/","excerpt":"分享第一周学习内容","text":"分享第一周学习内容 leetcode 热题HOT 1001.两数相加给定一个整数数组nums和一个整数目标值target请你在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 先贴出答案，然后一步步讲解。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; a; vector&lt;int&gt; b(2,-1); for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; &#125;&#125;; 通常的作法为逐步尝试，首先第一个加第二个，再第一个加第三个……思路虽然简单暴力但运行速度慢且内存空间消耗大此代码采用的 开始逐行分析与知识点回顾 1map&lt;int,int&gt; a; //创建名为a的map容器，key与val的类型均为int 回顾map容器的相关知识： 1.map容器里的数值都是pair—&gt;成对出现 分别为键值key与实值val 2.我们可以通过key的索引查到对应的val 3.map不允许有重复的键值key存在 3.所有元素都会根据你所存的键值key进行自动排序 4.其中&lt;int,int&gt; 左边int代表key的类型为int 右边的int代表val为int 作用为：存储nums里的元素 1vector&lt;int&gt; b(2,-1);//创建名为b的vector容器，2代表初始长度，里面的值均为-1，存储nums里能满足target的两个值 回顾vector容器的相关知识： 1.与数组结构非常相似，与数组不同点在于数组是静态，而vector是动态扩展 12for(int i = 0;i &lt; nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); 涉及到的知识： 1.nums.size()表示的是整数数组nums的长度 2.a.insert是调用map容器里的函数insert：在map中插入元素 3.map&lt;int,int&gt;::value_type：令元素的类型为map中含有key与val的pair类型 4.map&lt;int,int&gt;::mapped_type：令元素的类型为map中的val类型 5.map&lt;int,int&gt;::key_type：令元素的类型为map中的key类型 所以 我们把nums里的元素分别以key-val的pair形式传到名为a的map容器里 12345678for(int i = 0;i &lt; nums.size();i++)&#123; if(a.count(target - nums[i]) != 0 &amp;&amp; (a[target - nums[i]] != i))&#123; b[0] = i; b[1] = a[target - nums[i]]; break; &#125; &#125; return b; 涉及到的知识： 1.map容器的函数count(key)：如果key键值存在，则返回1，否则返回0 思路：通过target依次减去nums[i]，得到的结果通过count函数搜索是否存在于名为a的map容器中。且通过&amp;&amp;算法来满足“同一个元素在答案里不能重复出现”这一条件。if条件满足后，则赋予名为b的vector容器，最后返回b容器 2.两数相加给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头。 先贴出答案，然后一步步讲解。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* H = new ListNode(); ListNode* ptr = H; int carry = 0; while(l1 || l2 || carry)&#123; int val = 0; if(l1) val += l1-&gt;val,l1 = l1-&gt;next; if(l2) val += l2-&gt;val,l2 = l2-&gt;next; val +=carry; ListNode* node = new ListNode(val % 10); ptr-&gt;next = node; ptr = node; carry = val / 10; &#125; return H-&gt;next; &#125;&#125;; 开始逐行分析与知识点回顾 创建链表的详细过程 1.链表的概念 通过一组任意的存储单元来存储线性表中的数据元素，有一个个结点组成。 2.节点(Node)的框架 1234struct ListNode&#123; int data; ListNode* next;&#125;; 节点分为头节点和首元节点 a.头节点 设置链表前会额外增设一个节点，该节点一般不存放数据。好处是可以使问题简单化。对于链表来讲，不一定非得增设头节点。 b.首元节点 头节点后边的第一个节点，也是链表中的第一个节点。 节点包括数据data和指针Next a.指针的概念 指针是一个变量，存储另一个变量的地址 123int a = 10;int* p;//定义指针的格式为 数据类型* 指针变量名字p = &amp;a;//&amp;代表取址符号 b.结构体指针 12345678910111213#include &lt;iostream&gt;struct student&#123; string name; int age;&#125;//创建一个结构体int main()&#123; 1.创建结构体变量 student s =&#123;&quot;haha&quot;,18&#125;; 2.通过指针指向结构体变量 student* p = &amp;s;//p的类型必须跟s一致 3.指针访问结构体变量中的数据 cout &lt;&lt; p-&gt;name;//通过-&gt;访问结构体里的数据&#125; 结点的框架图： 创建链表的流程： 123456789101112131415161718192021222324#include &lt;iostream&gt;/*创建一个链表*/struct ListNode&#123; int data; ListNode* next;&#125;;void createList(ListNode* pHead)&#123; ListNode* p = pHead; for(int i = 0;i &lt; 10;i++)&#123; ListNode* pNewNode = new ListNode; pNewNode-&gt;data = i; pNewNode-&gt;next = NULL; p-&gt;next = pNewNode; p = pNewNode; &#125;&#125;int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 现来逐个分析 1234567int main()&#123; ListNode* head = NULL; head-&gt;data = 0; head-&gt;next = NULL; createList(head); return 0;&#125; 首先在main函数创建一个名为head的指针结构体变量，在这我们可以把head看成头节点，分配相应内存和初始化成员后如下图所示 把head指针代入函数createList，开始创建链表 12void createList(ListNode* pHead)&#123; ListNode* p = pHead; 创造p节点，令结构体指针p等于pHead，此时p的地址与pHead的地址一样，对p操作就是对pHead操作，所以p也是头节点。 12345 for(int i = 0;i &lt; 10;i++)&#123; //i = 0 ListNode* pNewNode = new ListNode; &#125;&#125; 进入for循环，处于i&#x3D;0时。在堆区new一个新内存，存放pNewNode。作为中间结构体为存放新节点提供过渡。 a.new的相关知识 new返回的使 该数据类型的指针 1234int* func()&#123; int* p = new int(10); return p;&#125; b.内存四区 程序运行前： 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 程序运行后： 堆区：堆区的数据由程序员开辟，程序员管理使用(delete) 栈区：栈区的数据由系统分配，一般存放函数的参数以及局部变量。函数执行完，栈区的数据都会自动释放。 指针本质是局部变量，放在栈上，但指针保存的数据使放在堆区。 回到链表创建上来 123//i = 0pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;0时，在pNewNode里存放数据 12//i = 0p-&gt;next = pNewNode; 头节点p指向我们的创建的链表的第一个节点 i&#x3D;0下的pNewNode，i&#x3D;0下的pNewNode也称之为首元节点。 12//i = 0p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与pHead没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们进入下一个循环 1234//i = 1ListNode* pNewNode = new ListNode;pNewNode-&gt;data = i;pNewNode-&gt;next = NULL; 当i&#x3D;1时，在pNewNode里存放数据 12//i = 1p-&gt;next = pNewNode; 节点p指向我们的创建的链表的第一个节点 i&#x3D;1下的pNewNode 12//i = 1p = pNewNode; 将i&#x3D;1下的pNewNode的地址赋予给p，所以p与i&#x3D;0下的pNewNode没有联系，现在是指针p和i&#x3D;1下的指针pNewNode指向同一块内存。 我们的创建链表的详细过程就结束了，回到LeetCode题上。 123ListNode* H = new ListNode();ListNode* ptr = H;int carry = 0; H为定义的头节点，ptr是中间节点，H存放的地址与ptr存放的地址一致。carry为进位数 1while(l1 || l2 || carry)&#123; 个人的看法只要当l1 l2的val为0(结构体里的data)及carry为0，才返回false，其他情况一律为true。 123if(l1) val += l1-&gt;val,l1 = l1-&gt;next;if(l2) val += l2-&gt;val,l2 = l2-&gt;next;val +=carry; 当l1不为0是 执行if语句 val为l1链表的第一个数字，l1从第一个链表转换成l1的第二个链表第二行代码同理carry是进位制 1ListNode* node = new ListNode(val % 10); 创建新链表的第一个节点，存储的数据为 val除以10的余数 123ptr-&gt;next = node;ptr = node;carry = val / 10; 因为node存放的数据是我们想要的数据，所以利用ptr的next指针即H的next指针指向node节点，ptr切断与H的联系，令ptr与node指向同一块内存，手法跟创建链表一样。通过相除判断carry是否进1位。 1return H-&gt;next; H为头节点，头节点下一个next才是链表中的节点。 Conclusion第一次写博客，刚开始上手不是很熟悉，所以暂时就写了这周学的LeetCode。下次尝试把参与的项目学到的知识分享在博客中。暂定每周日更新博客，如果有研究僧考试那就咕咕咕~See you next week","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-17T10:54:08.712Z","updated":"2022-04-21T10:49:59.004Z","comments":true,"path":"2022/04/17/hello-world/","link":"","permalink":"https://merr0r.github.io/2022/04/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"c++","slug":"嵌入式/c","permalink":"https://merr0r.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/c/"}],"tags":[{"name":"每周学习","slug":"每周学习","permalink":"https://merr0r.github.io/tags/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"https://merr0r.github.io/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://merr0r.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}